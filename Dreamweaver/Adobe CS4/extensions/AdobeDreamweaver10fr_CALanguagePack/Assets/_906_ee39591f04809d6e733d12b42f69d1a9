<html><head>
<link rel="stylesheet" href="josh.css"></head><body bgcolor="#FFFFFF">
<div id="Description">
			<table width="100%" cellspacing="0" cellpadding="0" border="0">
				<tr><td valign="top" class="name">R&eacute;f&eacute;rence des commandes</td><td valign="top" nowrap class="compatibility">&#160; </td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr><td>Ce chapitre repr&eacute;sente l'essentiel de <span class="emphasis">SQL in a Nutshell</span>: il contient la liste des commandes SQL dans l'ordre alphab&eacute;tique, chacune accompagn&eacute;e d'exemples et d'explications d&eacute;taill&eacute;es. Un tableau g&eacute;n&eacute;ral montre pour chaque commande ou fonction si elle est &laquo;&#160; prise en charge&#160;&raquo;, &laquo;&#160; prise en charge avec des variations&#160;&raquo;, &laquo;&#160; prise en charge avec des limites&#160;&raquo; ou &laquo;&#160; non prise en charge&#160;&raquo; dans chacun des quatre dialectes SQL &eacute;voqu&eacute;s dans ce livre: SQL Server, MySQL, Oracle et PostgreSQL. Apr&egrave;s une courte description de la norme SQL99, chacune de ces applications est &eacute;voqu&eacute;e de fa&ccedil;on concise mais d&eacute;taill&eacute;e, avec des examples et des &eacute;chantillons de code.</td>
				</tr>
			</table>
		</div>
<div id="ALTER PROCEDURE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">ALTER PROCEDURE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p> <span class="emphasis"></span>L'instruction <span class="emphasis">ALTER PROCEDURE</span> permet de modifier une proc&eacute;dure stock&eacute;e existante. Le type et l'ampleur des changements possibles varient consid&eacute;rablement selon l'&eacute;diteur.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans SQL Server, cette instruction modifie une proc&eacute;dure cr&eacute;&eacute;e pr&eacute;c&eacute;demment (avec l'instruction <span class="emphasis">CREATE PROCEDURE</span> ), mais elle ne change pas les permissions et n'affecte pas les proc&eacute;dures stock&eacute;es ou les triggers qui en d&eacute;pendent.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Oracle, cette commande se contente de recompiler une proc&eacute;dure PL/SQL stock&eacute;e. Elle ne permet pas de modifier le code. Vous pouvez utiliser la commande Oracle <span class="emphasis">CREATE OR REPLACE PROCEDURE</span> pour obtenir une fonctionnalit&eacute; identique.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER PROCEDURE procedure_name {CASCADE | RESTRICT}[LANGUAGE | PARAMETER STYLE | &lt;SQL data access&gt; | &lt;null clause behavior&gt; | DYNAMIC RESULT SETS | NAME][parameter datatype [,...n]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Comme il est expliqu&eacute; sous <span class="emphasis">CREATE PROCEDURE</span>, la m&eacute;thode d'acc&egrave;s aux donn&eacute;es SQL <span class="emphasis">LANGUAGE</span>, <span class="emphasis">PARAMETER STYLE</span> (par exemple: <span class="emphasis">NO SQL</span>, <span class="emphasis">CONTAINS SQL</span>, etc.), le comportement en cas de clause nulle (par exemple: <span class="emphasis">CALL ON NULL INPUT</span>), <span class="emphasis">DYNAMIC RESULT SET</span>, et le nom de la proc&eacute;dure <span class="emphasis">NAME</span> peuvent tous &ecirc;tre modifi&eacute;s.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">ALTER PROCEDURE</span> peut aussi &ecirc;tre utilis&eacute;e pour modifier le nombre ou le type des param&egrave;tres d'entr&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe Microsoft SQL Server et variations</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER PROC[EDURE] procedure_name [;number][ {@parameter datatype } [VARYING] [= default] [OUTPUT] ][,...n][WITH { RECOMPILE | ENCRYPTION | RECOMPILE , ENCRYPTION } ][FOR REPLICATION]AST-SQL Block</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans SQL Server, cette commande permet de modifier tous les param&egrave;tres d'une proc&eacute;dure stock&eacute;e d&eacute;j&agrave; cr&eacute;&eacute;e. Il s'agit en fait d'un raccourci qui &eacute;vite d'avoir &agrave; &eacute;mettre une instruction <span class="emphasis">DROP PROCEDURE</span> suivie d'une nouvelle instruction <span class="emphasis">CREATE PROCEDURE</span>. Il n'est pas n&eacute;cessaire de r&eacute;-&eacute;tablir les permissions vers la proc&eacute;dure stock&eacute;e. Pour une explication d&eacute;taill&eacute;e de la syntaxe, reportez-vous &agrave; la commande <span class="emphasis">CREATE PROCEDURE</span>. Cette commande peut &ecirc;tre ex&eacute;cut&eacute;e dans SQL Server par le propri&eacute;taire de la proc&eacute;dure stock&eacute;e ou par un utilisateur dont le r&ocirc;le fixe est soit <span class="emphasis">db_owner</span>, soit <span class="emphasis">ddl_admin</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER PROCEDURE [user.]<span class="replaceable">procedure_name</span> COMPILE [DEBUG];</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Oracle, le nom de la proc&eacute;dure ou du paquet &agrave; compiler doit &ecirc;tre fourni. Le mot-cl&eacute; <span class="emphasis">COMPILE</span> est n&eacute;cessaire. L'option <span class="emphasis">COMPILE [DEBUG]</span> r&eacute;g&eacute;n&egrave;re les informations PL/SQL. Cette commande ne peut &ecirc;tre ex&eacute;cut&eacute;e que par le propri&eacute;taire de la proc&eacute;dure stock&eacute;e ou par les utilisateurs disposant de privil&egrave;ges qui leur permettent d'ex&eacute;cuter la commande <span class="emphasis">ALTER ANY PROCEDURE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cet exemple dans Microsoft SQL Server cr&eacute;e une proc&eacute;dure appel&eacute;e <span class="emphasis">get_next_br</span>, qui g&eacute;n&egrave;re une cha&icirc;ne de sortie CHAR(22) unique. Ensuite, lorsque cette proc&eacute;dure doit &ecirc;tre modifi&eacute;e pour r&eacute;cup&eacute;rer une valeur de sortie INT unique, <span class="emphasis">ALTER PROCEDURE</span> est utilis&eacute; pour la red&eacute;finir:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>-- Une proc&eacute;dure stock&eacute;e Microsoft SQL ServerCREATE PROCEDURE get_next_nbr  @next_nbr CHAR(22) OUTPUTASBEGIN DECLARE @random_nbr INT SELECT @random_nbr = RAND( ) * 1000000SELECT @next_nbr = RIGHT('000000'+ CAST(ROUND(RAND(@random_nbr)*1000000,0))AS CHAR(6), 6) + RIGHT('0000'+ CAST(DATEPART (yy, GETDATE( ) ) AS CHAR(4)), 2) + RIGHT('000'+ CAST(DATEPART (dy, GETDATE( ) ) AS CHAR(3)), 3) + RIGHT('00' + CAST(DATEPART (hh, GETDATE( ) ) AS CHAR(2)), 2) + RIGHT('00' + CAST(DATEPART (mi, GETDATE( ) ) AS CHAR(2)), 2) + RIGHT('00' + CAST(DATEPART (ss, GETDATE( ) ) AS CHAR(2)), 2) + RIGHT('000'+ CAST(DATEPART (ms, GETDATE( ) ) AS CHAR(3)), 3)ENDGOALTER PROCEDURE get_next_nbr  @next_nbr INT OUTPUTASBEGIN DECLARE @convert_to_nbr CHAR(22) DECLARE @random_nbr INT SELECT @random_nbr = RAND( ) * 1000000SELECT @convert_to_nbr = RIGHT('000000'+ CAST(ROUND(RAND(@random_nbr)*1000000,0))AS CHAR(6), 6) + RIGHT('0000'+ CAST(DATEPART (yy, GETDATE( ) ) AS CHAR(4)), 2) + RIGHT('000'+ CAST(DATEPART (dy, GETDATE( ) ) AS CHAR(3)), 3) + RIGHT('00' + CAST(DATEPART (hh, GETDATE( ) ) AS CHAR(2)), 2) + RIGHT('00' + CAST(DATEPART (mi, GETDATE( ) ) AS CHAR(2)), 2) + RIGHT('00' + CAST(DATEPART (ss, GETDATE( ) ) AS CHAR(2)), 2) + RIGHT('000'+ CAST(DATEPART (ms, GETDATE( ) ) AS CHAR(3)), 3)SELECT @next_nbr = CAST(@convert_to_nbr AS INT)ENDGO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="ALTER TABLE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">ALTER TABLE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">ALTER TABLE</span>permet de modifier une table existante sans l'effacer ni modifier les permissions associ&eacute;es. De ce fait, des changements mineurs peuvent &ecirc;tre effectu&eacute;s facilement sur une table existante.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle et Microsoft SQL Server reconnaissent tous les deux cette commande avec un certain nombre de variations adapt&eacute;es &agrave; leurs diff&eacute;rentes m&eacute;thodes d'affectation physique des fichiers.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des limites</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER TABLE table_name[ADD [COLUMN] column_name datatype attributes]| [ALTER [COLUMN] column_name SET DEFAULT default_value]| [ALTER [COLUMN] column_name DROP DEFAULT]| [ALTER [COLUMN] column_name ADD SCOPE table_name| [ALTER [COLUMN] column_name DROP SCOPE {RESTRICT | CASCADE}]| [DROP [COLUMN] column_name {RESTRICT | CASCADE}]| [ADD table_constraint_name]| [DROP CONSTRAINT table_constraint_name {RESTRICT | CASCADE}]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'instruction SQL99 <span class="emphasis">ALTER TABLE</span> permet d'apporter de nombreuses modifications utiles &agrave; une table. C'est une commande polyvalente qui permet aux utilisateurs d'ajouter une contrainte de colonne ( <span class="emphasis">ADD COLUMN</span>) de table, d'ajouter ou d'&eacute;liminer un <span class="emphasis">DEFAULT</span>, d'ajouter ou d'&eacute;liminer un <span class="emphasis">SCOPE</span> sur des colonnes qui font r&eacute;f&eacute;rence &agrave; un type d&eacute;fini par l'utilisateur et d'&eacute;liminer ( <span class="emphasis">DROP</span>) une contrainte de colonne ou de table.  <span class="emphasis">DROP RESTRICT</span> avertit l&acute;h&ocirc;te SGBD d'abandonner la commande s'il se rend compte que d'autres objets de la base de donn&eacute;es d&eacute;pendent de la contrainte de colonne ou de table.  <span class="emphasis">DROP CASCADE</span> lui demande d'&eacute;liminer tout objet de la base de donn&eacute;es qui d&eacute;pend de la contrainte de colonne ou de table. Pour de plus amples explications sur ces &eacute;l&eacute;ments de la commande, consultez l'instruction <span class="emphasis">CREATE TABLE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER TABLE table_name[ALTER COLUMN column_name new_data_type attributes {ADD | DROP}  ROWGUIDCOL]| [ADD [COLUMN] column_name datatype attributes][,...n]| [WITH CHECK | WITH NOCHECK] ADD table_constraint][,...n]| [DROP { [ CONSTRAINT ] constraint_name | COLUMN column_name }] [,...n]| [{ CHECK | NOCHECK } CONSTRAINT { ALL | constraint_name [,...n] }]| [{ ENABLE | DISABLE } TRIGGER { ALL | trigger_name [,...n] }]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'impl&eacute;mentation d'<span class="emphasis">ALTER TABLE</span>dans Microsoft SQL Server am&egrave;ne de nombreuses fonctionnalit&eacute;s.  <span class="emphasis">ALTER COLUMN</span> permet de modifier les propri&eacute;t&eacute;s d'une colonne existante comme le type de donn&eacute;es, la pr&eacute;sence ou non de valeurs nulles, les fonctions d'identit&eacute;, etc.  <span class="emphasis">ADD</span> ajoute une colonne, une colonne calcul&eacute;e ou une contrainte en toute derni&egrave;re position dans la table  (il est pour l'instant impossible d'ins&eacute;rer une colonne ailleurs qu'en derni&egrave;re position). Le mot <span class="emphasis">COLUMN</span> est indiqu&eacute; pour des raisons de clart&eacute;, mais il n'est pas n&eacute;cessaire. La nouvelle colonne doit &ecirc;tre d&eacute;finie de la m&ecirc;me fa&ccedil;on qu'avec l'instruction <span class="emphasis">CREATE TABLE</span>, y compris les contraintes, les param&egrave;tres par d&eacute;faut et les fusionnements.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les clauses <span class="emphasis">WITH CHECK</span> et <span class="emphasis">WITH NOCHECK</span> indiquent &agrave; SQL Server si les donn&eacute;es de la table doivent &ecirc;tre valid&eacute;es en accord avec de nouvelles contraintes ou cl&eacute;s. Lorsque les contraintes ajout&eacute;es portent la clause <span class="emphasis">WITH NOCHECK</span>, l'optimiseur de requ&ecirc;te l'ignore jusqu&acute;&agrave; ce qu'elles soient activ&eacute;es via <span class="emphasis">ALTER TABLE table_name CHECK CONSTRAINT ALL</span>. Les contraintes peuvent &ecirc;tre &eacute;limin&eacute;es avec <span class="emphasis">DROP CONSTRAINT</span> (le mot-cl&eacute; <span class="emphasis">CONSTRAINT</span> n'est cependant pas n&eacute;cessaire) et activ&eacute;es ou d&eacute;sactiv&eacute;es avec <span class="emphasis">CHECK CONSTRAINT</span> et <span class="emphasis">NOCHECK CONSTRAINT</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>De la m&ecirc;me fa&ccedil;on, un trigger auquel un nom a &eacute;t&eacute; attribu&eacute; peut &ecirc;tre activ&eacute; ou d&eacute;sactiv&eacute; via les clauses <span class="emphasis">ENABLE TRIGGER</span> et <span class="emphasis">DISABLE TRIGGER</span>. Pour activer ou d&eacute;sactiver simultan&eacute;ment tous les triggers d'une table, il suffit de remplacer le nom de la table par le mot-cl&eacute; <span class="emphasis">ALL</span>, comme dans l'exemple suivant: <span class="emphasis">ALTER TABLE employee DISABLE TRIGGER ALL</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans MySQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER [IGNORE] TABLE table_name[ADD [COLUMN] column_name datatype attributes ]  [FIRST | AFTER column_name]] [,...n]| [ADD INDEX [index_name] (index_col_name,...)] [,...n]| [ADD PRIMARY KEY (index_col_name,...)] [,...n]| [ADD UNIQUE [index_name] (index_col_name,...)] [,...n]| [ALTER [COLUMN] column_name {SET DEFAULT literal | DROP DEFAULT}] [,...n]| [CHANGE [COLUMN] old_col_name create_definition] [,...n]| [MODIFY [COLUMN] column_name datatype attributes] [,...n]| [DROP [COLUMN] column_name] [,...n]| [DROP PRIMARY KEY] [,...n]| [DROP INDEX index_name] [,...n]| [RENAME [AS] new_tbl_name] [,...n]| [table_options]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Reportez-vous &agrave; l'instruction <span class="emphasis">CREATE TABLE</span> pour plus de d&eacute;tails sur les attributs de colonne et les contraintes de table autoris&eacute;s.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'option <span class="emphasis">IGNORE</span> indique &agrave; MySQL d'effacer les lignes dupliqu&eacute;es lors de la d&eacute;finition d'une nouvelle cl&eacute; unique. Si <span class="emphasis">IGNORE</span> n'est pas pr&eacute;cis&eacute;, l'op&eacute;ration est abandonn&eacute;e si un enregistrement dupliqu&eacute; est identifi&eacute; sur une cl&eacute; unique.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'option <span class="emphasis">FIRST</span> ajoute une colonne en premi&egrave;re position dans la table. Il est possible de pr&eacute;ciser <span class="emphasis">AFTER column_name</span> pour ins&eacute;rer la nouvelle colonne apr&egrave;s le <span class="emphasis">column_name</span> sp&eacute;cifi&eacute;.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>En outre, MySQL permet une certaine flexibilit&eacute; dans l'instruction <span class="emphasis">ALTER TABLE</span> en permettant aux utilisateurs d'&eacute;mettre plusieurs clauses  <span class="emphasis">ADD</span>, <span class="emphasis">ALTER</span>, <span class="emphasis">DROP</span> et <span class="emphasis">CHANGE</span> dans une m&ecirc;me instruction <span class="emphasis">ALTER TABLE</span>. Ne pas oublier toutefois que les clauses <span class="emphasis">CHANGE column_name</span> et <span class="emphasis">DROP INDEX</span> sont des extensions de MySQL que l'on ne retrouve pas dans SQL99. MySQL inclut aussi l'extension Oracle <span class="emphasis">MODIFY column_name</span>. La clause <span class="emphasis">ALTER COLUMN</span> permet de d&eacute;finir ou d'&eacute;liminer une valeur par d&eacute;faut pour une colonne.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Une  table peut &ecirc;tre renomm&eacute;e via <span class="emphasis">RENAME AS</span>. De m&ecirc;me, on peut changer le nom d'une  colonne avec <span class="emphasis">CHANGE</span>. Par exemple, le code ci-dessous renomme &agrave; la fois une table et une colonne:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER TABLE employee RENAME AS emp;ALTER TABLE employee CHANGE employee_ssn emp_ssn INTEGER;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Comme MySQL permet de cr&eacute;er des index sur une partie seulement d'une colonne (par exemple, les dix premiers caract&egrave;res), les commandes <span class="emphasis">CHANGE</span> et <span class="emphasis">MODIFY</span> ne permettent pas de cr&eacute;er des colonnes d'une longueur inf&eacute;rieure &agrave; celle de leurs index. Lorsque <span class="emphasis">DROP COLUMN</span> est utilis&eacute;, la colonne est &eacute;limin&eacute;e &agrave; la fois de la table et des index dans lesquels elle para&icirc;t.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p> <span class="emphasis">DROP PRIMARY KEY</span> n'&eacute;choue pas syst&eacute;matiquement en l'absence de cl&eacute; primaire sur la table. Dans ce cas, MySQL &eacute;limine le premier index unique de la table.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>MySQL permet de red&eacute;finir le type de donn&eacute;es d'une colonne existante sans perdre de donn&eacute;es. Les valeurs incluses dans la colonne doivent &ecirc;tre compatibles avec le nouveau type de donn&eacute;es. Ainsi, une colonne "date" peut &ecirc;tre red&eacute;finie pour contenir des donn&eacute;es de type "caract&egrave;res", mais des donn&eacute;es de type "caract&egrave;res" ne peuvent &ecirc;tre red&eacute;fini en nombre entier. Voici un exemple:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER TABLE mytable MODIFY mycolumn LONGTEXT</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>MySQL permet les clauses <span class="emphasis">FOREIGN KEY</span>, <span class="emphasis">CHECK,</span> et <span class="emphasis">REFERENCES</span>, mais elles restent vides. Les commandes &eacute;mises avec ces clauses sont inop&eacute;rantes. MySQL les autorise essentiellement pour assurer la compatibilit&eacute; avec d'autres produits.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER TABLE [owner_name.]table_name[ADD column_name datatype attributes]| [MODIFY {column_name datatype  | column_constraint  | physical_storage_attributes [LOGGING | NOLOGGING]  | nested_table_attributes}]| [MODIFY CONSTRAINT {constraint_name {constraint_state}  | drop_constraint_clause  | drop_column_clause  | [ALLOCATE | DEALLOCATE extent_clause]  | [CACHE | NOCACHE]  | [LOGGING | NOLOGGING]  | [MONITORING | NOMONITORING] ]| [DROP {[COLUMN] column_name | constraint_name}]| [ALLOCATE EXTENT details]| [DEALLOCATE UNUSED details]| [RENAME TO new_table_name]| [OVERFLOW physical_storage_attributes]| [ADD OVERFLOW physical_storage_attributes]| [{ADD | DROP | MODIFY | MOVE | TRUNCATE | SPLIT | EXCHANGE | MODIFY}  PARTITION partition_details]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">ALTER TABLE</span> est un parfait exemple de la puissance et du nombre des fonctionnalit&eacute;s qu'Oracle met &agrave; la disposition de ses utilisateurs pour contr&ocirc;ler le stockage physique et la manipulation des tables, par exemple: prise en charge des zones de donn&eacute;es et des d&eacute;passements, et partitionnement des tables pour mieux assurer les p&eacute;riodes d'usage intensifs. Reportez-vous &agrave; l'impl&eacute;mentation de <span class="emphasis">CREATE TABLE</span> dans Oracle pour prendre connaissance de la syntaxe sp&eacute;cifique autoris&eacute;e pour certaines des lignes ci-dessus, comme <span class="emphasis">column_constraint</span>, <span class="emphasis">physical_storage_attributes</span> et <span class="emphasis">nested_table_attributes</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette commande peut &ecirc;tre utilis&eacute;e pour ajouter (<span class="emphasis">ADD</span>) de nouvelles colonnes ou contraintes et modifier (<span class="emphasis">MODIFY</span>) ou &eacute;liminer (<span class="emphasis">DROP</span>) des colonnes ou contraintes existantes. Toute nouvelle colonne doit &ecirc;tre d&eacute;finie comme <span class="emphasis">NULL</span>, &agrave; moins que la table n'ait aucune ligne. Le mot-cl&eacute; <span class="emphasis">MODIFY</span> permet de modifier les caract&eacute;ristiques d'une table existante. Avec <span class="emphasis">MODIFY CONSTRAINT</span>, vous pouvez &eacute;liminer ou modifier les contraintes d'une table, par exemple, activer <span class="emphasis">LOGGING</span>, <span class="emphasis">CACHE</span> ou <span class="emphasis">MONITOR</span>, et d&eacute;cider d'<span class="emphasis">ALLOCATE</span> ou <span class="emphasis">DEALLOCATE</span> les zones de stockage. Les mots-cl&eacute; <span class="emphasis">ENABLE</span> et <span class="emphasis">DISABLE</span> sont utilis&eacute;s pour activer ou d&eacute;sactiver les contraintes d'une table.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'impl&eacute;mentation d'<span class="emphasis">ALTER TABLE</span> dans Oracle est  tr&egrave;s complexe. Reportez-vous &agrave; l'instruction <span class="emphasis">CREATE TABLE</span> pour une explication d&eacute;taill&eacute;e des sous-clauses communes aux deux commandes.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Par exemple, le code ci-dessous ajoute simultan&eacute;ment une colonne et une nouvelle contrainte unique &agrave; une table dans Oracle:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER TABLE titlesADD subtitle VARCHAR2(32) NULLCONSTRAINT unq_subtitle UNIQUE;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Quand une contrainte de cl&eacute; &eacute;trang&egrave;re est ajout&eacute;e &agrave; une table, le SGBD v&eacute;rifie que toutes les donn&eacute;es existantes de la table la respectent. Si ce n'est pas le cas, la commande <span class="emphasis">ALTER TABLE</span> &eacute;choue.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Toute application qui inclut le mot-cl&eacute; <span class="literal">SELECT</span> <span class="literal">*</span> renvoie les nouvelles colonnes, m&ecirc;me si ce n'&eacute;tait pas pr&eacute;vu. En revanche, les objets pr&eacute;-compil&eacute;s, comme les proc&eacute;dures stock&eacute;es, peuvent ne renvoyer aucune nouvelle colonne.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet &eacute;galement d'effectuer simultan&eacute;ment plusieurs actions (<span class="emphasis">ADD</span>, <span class="emphasis">MODIFY</span>, etc.) sur un certain nombre de colonnes, en mettant l'action entre parenth&egrave;ses. Par exemple, la commande ci-dessous ajoute plusieurs colonnes &agrave; une table avec cette seule instruction:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER TABLE titlesADD (subtitles VARCHAR2(32) NULL,  year_of_copyright INT,  date_of_origin DATE);</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER TABLE table [*][ADD [COLUMN] column_name datatype attributes]| [ALTER [COLUMN] column_name {SET DEFAULT value | DROP DEFAULT}]| [RENAME [COLUMN] column_name TO new_column_name]| [RENAME TO new_table_name]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'impl&eacute;mentation de <span class="emphasis">ALTER TABLE</span> dans PostgreSQL permet d'ajouter des  colonnes &agrave; l'aide du mot-cl&eacute; <span class="emphasis">ADD</span>. Il est possible d'attribuer de nouvelles valeurs par d&eacute;faut aux colonnes existantes avec <span class="emphasis">ALTER COLUMN... SET DEFAULT</span>, tandis qu'<span class="emphasis">ALTER COLUMN... DROP DEFAULT</span> permet d'&eacute;liminer la valeur par d&eacute;faut d'une colonne. En outre, de nouvelles valeurs par d&eacute;faut peuvent &ecirc;tre ajout&eacute;es &agrave; des colonnes avec la clause <span class="emphasis">ALTER</span>, mais elles ne s'appliqueront qu'aux lignes ins&eacute;r&eacute;es. <span class="emphasis">RENAME</span> permet de renommer les colonnes et tables existantes.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="ALTER TRIGGER">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">ALTER TRIGGER </td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">ALTER TRIGGER</span> modifie la d&eacute;finition d'un trigger existant sans qu'il soit n&eacute;cessaire de modifier les permissions ou les d&eacute;pendances.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il n'existe pour l'instant pas de norme SQL99 pour cette commande.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER TRIGGER trigger_nameON {table_name | view_name}[WITH ENCRYPTION]{FOR | AFTER | INSTEAD OF} {[DELETE] [,] [INSERT] [,] [UPDATE]}[WITH APPEND][NOT FOR REPLICATION]AS T-SQL_block| [FOR { [INSERT] [,] [UPDATE] }[NOT FOR REPLICATION]AS { IF UPDATE(column) [{AND | OR} UPDATE(column)] [...n]  |  IF (COLUMNS_UPDATED( ) {bitwise_operator} updated_bitmask)  { comparison_operator} column_bitmask [...n] }  T-SQL_block ] } ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server permet de sp&eacute;cifier <span class="emphasis">FOR | AFTER | INSTEAD OF { [DELETE] [,] [UPDATE] [,][INSERT] } | { [INSERT] [,] [UPDATE] }</span> pour d&eacute;crire le trigger de modification des donn&eacute;es affect&eacute; par la commande. Toutes les permutations sont possibles &agrave; condition qu'au moins un de ces &eacute;l&eacute;ments soit inclus. Il suffit de s&eacute;parer les options suppl&eacute;mentaires par des virgules. Les options <span class="emphasis">FOR</span> et <span class="emphasis">AFTER</span> sont essentiellement identiques et indiquent que le code du trigger doit s'ex&eacute;cuter une fois la manipulation des donn&eacute;es termin&eacute;e. On peut &eacute;galement utiliser l'expression <span class="emphasis">INSTEAD OF</span> pour indiquer &agrave; SQL Server de remplacer l'op&eacute;ration par le code du trigger.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'expression <span class="emphasis">WITH APPEND</span> demande &agrave; SQL Server d'ajouter un trigger du type indiqu&eacute; &agrave; la table de base. Cette option n'est autoris&eacute;e que sur les triggers <span class="emphasis">FOR</span>. L'expression <span class="emphasis">NOT FOR REPLICATION</span> indique &agrave; SQL Server de ne pas ex&eacute;cuter le trigger lorsque l'action est lanc&eacute;e par un nom d'utilisateur dupliqu&eacute;, comme <span class="emphasis">sqlrepl</span>. La clause <span class="emphasis">IF UPDATE (column)</span> v&eacute;rifie s'il existe une action <span class="emphasis">INSERT</span> ou <span class="emphasis">UPDATE</span> (mais pas <span class="emphasis">DELETE</span>) sur une colonne donn&eacute;e, ce qui peut &ecirc;tre tr&egrave;s utile lorsqu'on proc&egrave;de &agrave; des op&eacute;rations sur les lignes avec un curseur. Les op&eacute;rateurs <span class="emphasis">{AND | OR}</span> permettent de tester des colonnes suppl&eacute;mentaires dans la m&ecirc;me phrase.  <span class="emphasis">IF (COLUMNS_UPDATED( ))</span> teste un trigger <span class="emphasis">INSERT</span> ou <span class="emphasis">UPDATE</span> pour voir si les colonnes mentionn&eacute;es ont &eacute;t&eacute; affect&eacute;es. Les r&eacute;sultats sont d&eacute;livr&eacute;s sous la forme d'op&eacute;rateurs binaires.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER TRIGGER [user.]<span class="replaceable">trigger_name </span>[ENABLE | DISABLE | COMPILE [DEBUG] ];</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle ne permet pas de modifier compl&egrave;tement le code sous-jacent du trigger via cette commande (mais on obtient cette m&ecirc;me fonctionnalit&eacute; avec <span class="emphasis">CREATE OR REPLACE TRIGGER</span>). Dans Oracle, <span class="emphasis">ALTER TRIGGER</span> permet d'activer, de d&eacute;sactiver ou de recompiler un trigger. L'option <span class="emphasis">COMPILE [DEBUG]</span> r&eacute;g&eacute;n&egrave;re les informations PL/SQL.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle ne permet l'utilisation de    triggers <span class="emphasis">que</span> sur les tables (bien que les triggers <span class="emphasis">INSTEAD OF</span> soient autoris&eacute;s sur les vues). Microsoft SQL Server permet l'utilisation de triggers sur les tables et sur les vues qui peuvent &ecirc;tre mises &agrave; jour.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="ALTER VIEW">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">ALTER VIEW</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>Comme il n'existe pas, pour l'instant, de norme SQL99 pour l'instruction <span class="emphasis">ALTER VIEW</span>  , il est important de noter que cette commande se comporte diff&eacute;remment dans chacune des applications majeures qui la proposent. Oracle l'utilise pour recompiler les vues, tandis que dans Microsoft SQL Server, elle permet de modifier une  vue sans n&eacute;cessairement mettre &agrave; jour les proc&eacute;dures stock&eacute;es, triggers ou permissions qui en d&eacute;pendent.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il n'existe pour l'instant pas de norme SQL99 pour cette commande.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER VIEW <span class="replaceable">view_name </span>[(<span class="replaceable">column</span> [,...n])][WITH {ENCRYPTION | SCHEMABINDING | VIEW_METADATA]AS<span class="replaceable">select_statement</span>[WITH CHECK OPTION]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Comme c'est le cas pour l'instruction <span class="emphasis">CREATE VIEW</span>, <span class="emphasis">ALTER VIEW</span> permet &agrave; un programmeur de pr&eacute;ciser les alias que la vue utilise pour nommer les colonnes, ainsi que la totalit&eacute; de l'instruction <span class="emphasis">SELECT</span> qui est le composant central de la vue.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les autres clauses de l'instruction <span class="emphasis">ALTER VIEW</span> sont d&eacute;crites sous l'instruction <span class="emphasis">CREATE VIEW</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server ne peut conserver les permissions sur les colonnes que si leurs noms sont maintenus apr&egrave;s ex&eacute;cution de la commande. Le mot-cl&eacute; <span class="emphasis">ENCRYPTION</span> permet de chiffrer les codes de vues au sein de la table syst&egrave;me syscomments dans SQL Server. Le mot-cl&eacute; <span class="emphasis">CHECK OPTION</span> oblige toutes les modifications de donn&eacute;es ex&eacute;cut&eacute;es dans une vue &agrave; ob&eacute;ir aux crit&egrave;res du <span class="emphasis">select_statement</span> qui la d&eacute;finissent. Si l'une ou l'autre de ces options figuraient auparavant dans la vue, elles doivent &ecirc;tre activ&eacute;es &agrave; l'aide de l'instruction <span class="emphasis">ALTER VIEW</span> pour &ecirc;tre op&eacute;rantes.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ALTER VIEW [user.]<span class="replaceable">view_name </span>COMPILE</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Oracle, l'instruction <span class="emphasis">ALTER VIEW</span> recompile une vue. Elle est utile pour valider une vue apr&egrave;s avoir apport&eacute; des changements &agrave; une table de base. Si les tables de base changent sans que la vue correspondante soit recompil&eacute;e, celle-ci est invalide.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple </span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cet exemple tir&eacute; de SQL Server cr&eacute;e une vue intitul&eacute;e <span class="emphasis">california_authors</span> qui contient les noms d'auteurs vivant en Californie,  puis se sert de la commande <span class="emphasis">ALTER VIEW</span> pour &eacute;largir et remplacer la vue:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE VIEW california_authorsASSELECT au_lname, au_fname, city, stateFROM authorsWHERE state = 'CA'WITH CHECK OPTIONGOALTER VIEW california_authorsASSELECT au_fname, au_lname, address, city, state, zipFROM pubs..authorsWHERE state = "CA"GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CALL">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CALL </td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">CALL</span>  invoque une proc&eacute;dure stock&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Non prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CALL procedure_name [(parameter [,...n] )]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">CALL</span> facilite l'invocation d'une proc&eacute;dure stock&eacute;e. Il suffit de saisir le nom de la proc&eacute;dure et d'inclure entre parenth&egrave;ses les param&egrave;tres qu'elle utilise. Les parenth&egrave;ses peuvent &ecirc;tre vides si la proc&eacute;dure stock&eacute;e n'a que des param&egrave;tres <span class="emphasis">OUT</span> ou n'a pas de param&egrave;tres du tout.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server ne prend pas en charge l'instruction <span class="emphasis">CALL</span>. Toutefois, l'instruction <span class="emphasis">EXECUTE</span>. Reportez-vous &agrave; la documentation de l'&eacute;diteur pour une explication d&eacute;taill&eacute;e de cette extension SQL Server.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CALL [schema.][{type_name | package_name}.]procedure_name@dblink[(parameter [,...n] )][INTO:variable_name [INDICATOR:indicator_name] ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet d'utiliser l'instruction <span class="emphasis">CALL</span> pour invoquer des proc&eacute;dures stock&eacute;es, des fonctions et des m&eacute;thodes autonomes, ainsi que des proc&eacute;dures stock&eacute;es et des fonctions contenues dans un type ou un paquet. Si la proc&eacute;dure ou la fonction r&eacute;side dans une autre base de donn&eacute;es, il suffit de d&eacute;clarer la base de donn&eacute;es (en pr&eacute;cisant o&ugrave; l'objet r&eacute;side) avec une instruction  dblink dans l'instruction <span class="emphasis">CALL</span>. dblink doit se r&eacute;f&eacute;rer &agrave; un lien de base de donn&eacute;es existant.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Si la routine ainsi appel&eacute;e est une fonction, Oracle exige la clause <span class="emphasis">INTO</span>. Par cons&eacute;quent, INTO ne peut &ecirc;tre utilis&eacute;e que lorsqu'une fonction est invoqu&eacute;e. La variable qui stockera la valeur renvoy&eacute;e par la fonction doit &ecirc;tre fournie. Enfin, si la fonction est une routine Pro*C/C++ pr&eacute;-compil&eacute;e, un indicateur peut aussi &ecirc;tre pr&eacute;cis&eacute; pour retenir la condition de la variable h&ocirc;te.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans cet exemple, une proc&eacute;dure stock&eacute;e simple est cr&eacute;&eacute;e, puis invoqu&eacute;e ind&eacute;pendamment:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE PROCEDURE update_employee_salary(emp_id NUMBER, updated_salary NUMBER)ISBEGIN UPDATE employee SET salary = updated_salary WHERE employee_id =emp_id;END;CALL update_employee_salary(1517, 95000);</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CASE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CASE </td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>La fonction <span class="emphasis">CASE</span> assure la fonctionnalit&eacute; <span class="emphasis">IF-THEN-ELSE</span> au sein d'une instruction <span class="emphasis">SELECT</span> ou <span class="emphasis">UPDATE</span>. Elle &eacute;value une liste de conditions et renvoie l&acute;une des valeurs possibles.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Non prise en charge (la fonction <span class="emphasis">DECODE</span> offre une fonctionnalit&eacute; &eacute;quivalente;  voir la documentation de l'&eacute;diteur)</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p> <span class="emphasis">CASE</span> peut &ecirc;tre utilis&eacute; de deux fa&ccedil;ons: simple et conditionnelle. Les expressions <span class="emphasis">CASE</span> simples comparent une valeur, <span class="emphasis">input_value</span>, avec une liste d'autres valeurs et renvoient un r&eacute;sultat associ&eacute; &agrave; la premi&egrave;re concordance. Les expressions <span class="emphasis">CASE</span> conditionnelles permettent d'analyser plusieurs conditions logiques et renvoient un r&eacute;sultat associ&eacute; &agrave; la premi&egrave;re qui soit vraie.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>-- Op&eacute;ration de comparaison simpleCASE input_valueWHEN when_condition THEN resulting_value[...n][ELSE else_result_value]END-- Op&eacute;ration conditionnelle logiqueCASEWHEN Boolean_condition THEN resulting_value[...n][ELSE else_result_expression]END</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans la fonction <span class="emphasis">CASE</span> simple, la valeur <span class="emphasis">input_value</span> est &eacute;valu&eacute;e et compar&eacute;e &agrave; chaque clause <span class="emphasis">WHEN</span>. Le r&eacute;sultat <span class="emphasis">resulting_value</span> est renvoy&eacute; pour la premi&egrave;re instance o&ugrave; <span class="emphasis">input_value</span> = <span class="emphasis">when_condition</span>est TRUE. Si aucune <span class="emphasis">when_condition</span> n'est TRUE, alors <span class="emphasis">else_result_value</span> est renvoy&eacute;e. Si <span class="emphasis">else_result_value</span> n'est pas sp&eacute;cifi&eacute;e, alors le r&eacute;sultat NULL est renvoy&eacute;.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La structure de l'op&eacute;ration conditionnelle logique, plus complexe, est essentiellement identique &agrave; celle de l'op&eacute;ration de comparaison simple, sauf que chaque clause <span class="emphasis">WHEN</span> a sa propre op&eacute;ration de comparaison logique.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Quelle que soit la version choisie, on utilise des clauses <span class="emphasis">WHEN</span> multiples, bien qu'une seule clause <span class="emphasis">ELSE</span> soit n&eacute;cessaire.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Voici une comparaison simple o&ugrave; la fonction <span class="emphasis">CASE</span> modifie l'apparence de la colonne "contrat" pour en faciliter la compr&eacute;hension:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT au_fname,    au_lname,    CASE contract      WHEN 1 THEN 'Yes'      ELSE 'No'    END 'contract'FROM  authorsWHERE  state = 'CA'</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Voici une fonction conditionnelle <span class="emphasis">CASE</span> plus complexe, int&eacute;gr&eacute;e &agrave; une instruction <span class="emphasis">SELECT</span> qui montre le cumul des ventes par titre pour l'ann&eacute;e en cours:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT CASE      WHEN ytd_sales IS NULL THEN 'Unknown'      WHEN ytd_sales &lt;=  200 THEN 'Not more than 200'      WHEN ytd_sales &lt;= 1000 THEN 'Between 201 and 1000'      WHEN ytd_sales &lt;= 5000 THEN 'Between 1001 and 5000'      WHEN ytd_sales &lt;= 10000 THEN 'Between 5001 and 10000'      ELSE 'Over 10000'    END 'YTD Sales',    COUNT(*) 'Number of Titles'FROM  titlesGROUP BY CASE      WHEN ytd_sales IS NULL THEN 'Unknown'      WHEN ytd_sales &lt;=  200 THEN 'Not more than 200'      WHEN ytd_sales &lt;= 1000 THEN 'Between 201 and 1000'      WHEN ytd_sales &lt;= 5000 THEN 'Between 1001 and 5000'      WHEN ytd_sales &lt;= 10000 THEN 'Between 5001 and 10000'      ELSE 'Over 10000'     ENDORDER BY MIN( ytd_sales )</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette instruction donne les r&eacute;sultats suivants:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>YTD Sales       Number of Titles---------------------- ----------------Unknown        2Not more than 200   1Between 201 and 1000 2Between 1001 and 5000 9Between 5001 and 10000 1Over 10000       3</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Voici une instruction <span class="emphasis">UPDATE</span> qui applique une remise sur tous les titres. La commande suivante est plus complexe: elle applique une remise de 25 % sur tous les titres ayant trait &agrave; la microinformatique, de 5 % sur les titres dont les ventes cumul&eacute;es d&eacute;passent 10 000 exemplaires, et de 10 % sur tous les autres titres.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La requ&ecirc;te <span class="emphasis">UPDATE</span> ci-dessous a recours &agrave; une expression <span class="emphasis">CASE</span> conditionnelle pour ajuster les prix:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>UPDATE titlesSET   price = price *    CASE      WHEN ytd_sales &gt; 10000   THEN 0.95 -- 5% discount      WHEN type = 'popular_comp'THEN 0.75 -- 25% discount      ELSE 0.9               -- 10% discount    ENDWHERE  pub_date IS NOT NULL</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Trois op&eacute;rations de mise &agrave; jour diff&eacute;rentes sont donc ex&eacute;cut&eacute;es simultan&eacute;ment, avec une seule instruction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CAST">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CAST </td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">CAST</span> convertit explicitement une expression d'un type de donn&eacute;es &agrave; un autre.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Non prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CAST(expression AS data_type[(length)])</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La fonction <span class="emphasis">CAST</span> convertit une expression quelconque, par exemple une valeur ou une variable prises dans une colonne, en un type de donn&eacute;es d&eacute;fini. Il est possible de pr&eacute;ciser la longueur des donn&eacute;es en caract&egrave;res pour les types qui la reconnaissent (comme <span class="emphasis">CHAR</span> ou <span class="emphasis">VARCHAR</span>).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il faut savoir que certaines conversions, par exemple la conversion d'une valeur d&eacute;cimale (<span class="emphasis">DECIMAL</span>) &agrave; un nombre entier (<span class="emphasis">INTEGER</span>), auront pour r&eacute;sultat d'arrondir le chiffre concern&eacute;. En outre, il peut arriver que les conversions aboutissent &agrave; des erreurs si le nouveau type de donn&eacute;es ne dispose pas de l'espace n&eacute;cessaire pour afficher la valeur convertie.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans cet exemple, la commande r&eacute;cup&egrave;re le chiffre des ventes cumul&eacute;es pour l'ann&eacute;e en cours sous forme de <span class="emphasis">CHAR</span> et y accole une cha&icirc;ne en langage clair suivie d'une partie du titre du livre. Elle convertit <span class="emphasis">ytd_sales</span> &agrave; <span class="emphasis">CHAR(5),</span> et raccourcit <span class="emphasis">title</span> pour que les r&eacute;sultats soient plus faciles &agrave; lire:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT CAST(ytd_sales AS CHAR(5)) + "Copies sold of " + CAST(title ASVARCHAR(30))FROM titlesWHERE ytd_sales IS NOT NULL AND ytd_sales &gt; 10000ORDER BY ytd_sales DESC</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>On obtient ce qui suit:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>---------------------------------------------------22246 Copies sold of The Gourmet Microwave18722 Copies sold of You Can Combat Computer Stress15096 Copies sold of Fifty Years in Buckingham Pala</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CLOSE CURSOR">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CLOSE CURSOR</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">CLOSE CURSOR</span> ferme un curseur serveur cr&eacute;&eacute; &agrave; l'aide d'une instruction <span class="emphasis">DECLARE CURSOR</span> . MySQL ne prend pas en charge les curseurs serveur, mais offre quantit&eacute; d'options de programmation en C.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CLOSE { cursor_name }</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p> <span class="emphasis">cursor_name</span> repr&eacute;sente le nom du curseur cr&eacute;&eacute; &agrave; l'aide de la commande <span class="emphasis">DECLARE CURSOR</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cet exemple tir&eacute; de Microsoft SQL Server ouvre un curseur et extrait toutes les lignes:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DECLARE employee_cursor CURSOR FOR SELECT lname, fname FROM pubs.dbo.authors WHERE lname LIKE 'K%'OPEN employee_cursorFETCH NEXT FROM employee_cursorWHILE @@FETCH_STATUS = 0BEGIN FETCH NEXT FROM Employee_CursorENDCLOSE employee_cursorDEALLOCATE employee_cursor</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Microsoft SQL Server, l'instruction  <span class="emphasis">DEALLOCATE</span> lib&egrave;re les ressources et les structures de donn&eacute;es mobilis&eacute;es par le curseur, mais elle n'est utilis&eacute;e ni par Oracle, ni par PostgreSQL, ni par MySQL.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="COMMIT TRANSACTION">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">COMMIT TRANSACTION</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">COMMIT</span>  <span class="emphasis">TRANSACTION</span> conclut de fa&ccedil;on explicite une transaction ouverte, qu'elle ait &eacute;t&eacute; ouverte explicitement avec <span class="emphasis">BEGIN,</span> ou implicitement dans le cadre d'une instruction <span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span> ou <span class="emphasis">DELETE</span>. Cette commande permet de mettre fin manuellement de fa&ccedil;on permanente &agrave; une op&eacute;ration de manipulation des donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>COMMIT [WORK]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Outre le fait de mettre un point final &agrave; une s&eacute;rie d'op&eacute;rations de  manipulation des donn&eacute;es (ou &agrave; une op&eacute;ration unique), l'instruction <span class="emphasis">COMMIT</span> a des effets int&eacute;ressants sur d'autres aspects d'une transaction. Premi&egrave;rement, elle ferme tous les curseurs associ&eacute;s rest&eacute;s ouverts. Deuxi&egrave;mement, les donn&eacute;es sont effac&eacute;es de toutes les  tables temporaires pour lesquelles <span class="emphasis">ON COMMIT DELETE ROWS</span>a &eacute;t&eacute; sp&eacute;cifi&eacute;. Troisi&egrave;mement, tous les verrous pos&eacute;s par la transaction sont lib&eacute;r&eacute;s. Enfin, toutes les contraintes diff&eacute;r&eacute;es sont v&eacute;rifi&eacute;es. Si les contraintes diff&eacute;r&eacute;es sont enfreintes, la transaction est annul&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il est &agrave; noter que, selon la norme SQL99, une transaction est <span class="emphasis">implicitement ouverte</span> lorsque l'une des instructions suivantes est ex&eacute;cut&eacute;e:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ul><li> <span class="emphasis">ALTER</span> </li><li> <span class="emphasis">CLOSE</span> </li><li> <span class="emphasis">COMMIT AND CHAIN</span> (nouveau dans SQL99)</li><li> <span class="emphasis">CREATE</span> </li><li> <span class="emphasis">DELETE</span> </li><li> <span class="emphasis">DROP</span> </li><li> <span class="emphasis">FETCH</span> </li><li> <span class="emphasis">FREE LOCATOR</span> </li><li> <span class="emphasis">GRANT</span> </li><li> <span class="emphasis">HOLD LOCATOR</span></li><li> <span class="emphasis">INSERT</span> </li><li> <span class="emphasis">OPEN</span> </li><li> <span class="emphasis">RETURN</span></li><li> <span class="emphasis">REVOKE</span></li><li> <span class="emphasis">ROLLBACK AND CHAIN</span> (nouveau dans SQL99)</li><li> <span class="emphasis">SELECT</span> </li><li> <span class="emphasis">START TRANSACTION</span> (nouveau dans SQL99)</li><li> <span class="emphasis">UPDATE</span> </li></ul>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>SQL99 permet d'utiliser le nouveau mot-cl&eacute; optionnel <span class="emphasis">AND CHAIN</span>. Aucun de nos &eacute;diteurs ne prend en charge cette commande pour l'instant. La nouvelle syntaxe est:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>COMMIT [WORK] [AND [NO] CHAIN]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'option <span class="emphasis">AND CHAIN</span> demande au SGBD de traiter la transaction qui suit comme si elle faisait partie de la pr&eacute;c&eacute;dente. C'est utile pour traiter deux transactions qui repr&eacute;sentent des unit&eacute;s de travail s&eacute;par&eacute;es, mais qui partage un m&ecirc;me environnement (comme le niveau d'isolation des transactions). L'option <span class="emphasis">AND NO CHAIN</span> cl&ocirc;t simplement la transaction unique. D'un point de vue fonctionnel, la commande <span class="emphasis">COMMIT</span> est &eacute;quivalente &agrave; la commande <span class="emphasis">COMMIT WORK AND NO CHAIN</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>COMMIT [TRAN[SACTION] [transaction_name | @tran_name_variable] ]|COMMIT [WORK]GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server permet de valider une transaction sp&eacute;cifique &agrave; laquelle un nom a &eacute;t&eacute; attribu&eacute;. La commande <span class="emphasis">COMMIT</span> doit &ecirc;tre associ&eacute;e &agrave; une commande <span class="emphasis">BEGIN TRAN</span>. La syntaxe de <span class="emphasis">COMMIT TRANSACTION</span> permet aux programmeurs de sp&eacute;cifier une transaction explicite pour fermer ou stocker un nom de transaction dans une variable. Curieusement, SQL Server ne valide toujours que la derni&egrave;re transaction ouverte, quel que soit le nom de transaction sp&eacute;cifi&eacute;. <span class="emphasis">COMMIT WORK</span> permet d'omettre le nom de transaction ou la variable contenant un nom de transaction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Toutefois, cette syntaxe peut porter &agrave; confusion en pr&eacute;sence de triggers imbriqu&eacute;s, puisqu'elle ferme la transaction la plus &agrave; gauche. Dans SQL Server, les transactions sont identifi&eacute;es de fa&ccedil;on num&eacute;rique par la variable globale <span class="emphasis">@@TRANCOUNT</span>  . Les transactions ne sont valid&eacute;es que lorsque <span class="emphasis">@@TRANCOUNT</span> &eacute;gale 0.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>COMMIT [WORK];</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle ne permet pas d'attribuer un nom sp&eacute;cifique &agrave; une transaction (mais il autorise les points de sauvegarde);  par cons&eacute;quent, la commande <span class="emphasis">COMMIT</span> sert simplement &agrave; valider toutes les op&eacute;rations de manipulation des donn&eacute;es effectu&eacute;es depuis l'ex&eacute;cution de la derni&egrave;re instruction <span class="emphasis">COMMIT</span> implicite or explicite. Oracle autorise le mot-cl&eacute; <span class="emphasis">WORK</span> , mais il est enti&egrave;rement facultatif.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>COMMIT [WORK | TRANSACTION];</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans PostgreSQL, les mots-cl&eacute; <span class="emphasis">WORK</span> et <span class="emphasis">TRANSACTION</span> sont tous deux facultatifs. Le r&eacute;sultat de la commande est le m&ecirc;me, avec ou sans l'un ou l'autre des mots-cl&eacute;. Lorsque la commande est termin&eacute;e, toutes les transactions valid&eacute;es ont &eacute;t&eacute; sauvegard&eacute;es et peuvent &ecirc;tre vues par les autres utilisateurs.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>INSERT INTO sales VALUES('7896','JR3435','Oct 281997',25,'Net60','BU7832');COMMIT WORK;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="Op&eacute;rateurs de Concat&eacute;nation">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">Op&eacute;rateurs de Concat&eacute;nation</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>Si n&eacute;cessaire, on peut utiliser le symbole de concat&eacute;nation reconnu par le SGBD pour combiner les donn&eacute;es de plusieurs colonnes dans le  jeu de r&eacute;sultats <span class="emphasis">SELECT</span> .</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT lname || ', '|| fname FROM customers WHERE cust_id = 41;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Selon la norme ANSI, le symbole de la concat&eacute;nation est le signe  <span class="literal">||</span>, soit une double barre verticale, comme dans l'exemple de code ci-dessus. Ce symbole est pris en charge par Oracle et PostgreSQL.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Microsoft SQL Server, c'est le signe  plus (+) qui sert &agrave; indiquer la concat&eacute;nation.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>MySQL utilise la fonction <span class="emphasis">CONCAT(string1, numeric1, string2, numeric2 [,...n])</span> pour op&eacute;rer la concat&eacute;nation.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CONNECT">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CONNECT</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">CONNECT</span> &eacute;tablit une connexion au SGBD et &agrave; une base de donn&eacute;es sp&eacute;cifique au sein du SGBD.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des limites</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CONNECT [TO] DEFAULT| {[server_specification] [AS connection_name] [USER user_name ] }</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Si l'instruction <span class="emphasis">CONNECT</span> est invoqu&eacute;e sans qu'il y ait eu de d&eacute;connexion explicite, la session en cours devient inactive et une nouvelle session est ouverte. La p&eacute;riode comprise entre l'&eacute;mission d'une instruction <span class="emphasis">CONNECT</span> et celle d'une instruction <span class="emphasis">DISCONNECT</span> est appel&eacute;e <span class="emphasis">session</span>. Habituellement, les utilisateurs accomplissent leur travail sur un SGBD au cours d'une session invoqu&eacute;e de fa&ccedil;on explicite.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'outil Oracle SQL*Plus utilise la commande <span class="emphasis">CONNECT</span> d'une fa&ccedil;on assez diff&eacute;rente,  puisqu'il s'en sert pour connecter un utilisateur &agrave; un sch&eacute;ma particulier.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">CONNECT TO DEFAULT</span>  donne des r&eacute;sultats variables selon les &eacute;diteurs car elle est impl&eacute;ment&eacute;e de fa&ccedil;on diff&eacute;rente. Toutefois, selon la norme, cette commande devrait lancer une session sur le serveur par d&eacute;faut avec l'identifiant d'autorisation par d&eacute;faut et ouvrir la base de donn&eacute;es active.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Contrairement &agrave; <span class="emphasis">CONNECT TO DEFAULT</span>, <span class="emphasis">CONNECT TO server_name</span> permet &agrave; l'utilisateur de pr&eacute;ciser le serveur &agrave; utiliser. Ici, la connexion se fait vers le serveur explicitement d&eacute;sign&eacute;. En outre, la connexion peut &ecirc;tre d&eacute;clar&eacute;e en utilisant <span class="emphasis">AS</span> et un nom d'utilisateur sp&eacute;cifique avec <span class="emphasis">USER</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CONN[ECT] [[username/password] [AS [SYSOPER | SYSDBA] ] ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">CONNECT</span> permet de se connecter &agrave; une base de donn&eacute;es avec un nom d'utilisateur sp&eacute;cifique. Il est aussi possible d'&eacute;tablir une connexion avec des privil&egrave;ges particuliers en utilisant <span class="emphasis">AS SYSOPER</span> ou <span class="emphasis">AS SYSDBA</span>. Si une autre connexion est d&eacute;j&agrave; active, <span class="emphasis">CONNECT</span> valide les transactions ouvertes, ferme la session en cours et en ouvre une nouvelle.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL ne prend pas explicitement en charge la commande <span class="emphasis">CONNECT</span>. Toutefois, il admet l'instruction <span class="emphasis">SPI_CONNECT</span>  sous l&acute;Interface de Programmation du Serveur et <span class="emphasis">PG_CONNECT</span> sous l'outil de programmation PG/tcl.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour se connecter avec un nom d'utilisateur sp&eacute;cifique, l'utilisateur (ou le programme automatis&eacute;) peut &eacute;mettre la commande suivante:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CONNECT TO USER pubs_admin</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Si le SGBD exige qu'un nom soit utilis&eacute; pour permettre une connexion, on peut se servir de cette syntaxe:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CONNECT TO USER pubs_admin AS pubs_administrative_session;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server ne prend en charge <span class="emphasis">CONNECT TO</span> que lorsqu'elle est int&eacute;gr&eacute;e dans Embedded SQL (ESQL):</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>EXEC SQL CONNECT TO new_york.pubs USER pubs_admin</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CREATE DATABASE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CREATE DATABASE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>En fait, il n'existe pas d'instruction <span class="emphasis">CREATE DATABASE</span>   dans SQL99. Les instructions SQL99 les plus proches de <span class="emphasis">CREATE DATABASE</span> sont <span class="emphasis">CREATE SCHEMA</span> et <span class="emphasis">CREATE CATALOG</span> (<span class="emphasis">CREATE SCHEMA</span> est d&eacute;crite ci-apr&egrave;s). Toutefois, il est presque impossible de travailler sur une base de donn&eacute;es SQL sans cette commande. Presque tous les &eacute;diteurs de bases de donn&eacute;es en proposent une version.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE database_name</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans cette syntaxe, <span class="emphasis">database_name</span> est l'identifiant de la base de donn&eacute;es en cours de cr&eacute;ation. Cette commande cr&eacute;e une base de donn&eacute;es vierge dot&eacute;e d'un nom qui lui est propre. Dans la plupart des SGBD, l'utilisateur doit &ecirc;tre connect&eacute; au compte root, master, ou system database pour proc&eacute;der &agrave; la cr&eacute;ation d'une base de donn&eacute;es. Une fois la nouvelle base de donn&eacute;es cr&eacute;&eacute;e, elle est pr&ecirc;te &agrave; recevoir des objets de base de donn&eacute;es (tables, vues, triggers, etc.), et les tables &agrave; accueillir des donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans SQL Server et Oracle, la base de donn&eacute;es est instanci&eacute;e dans une  structure de fichiers cr&eacute;&eacute;e &agrave; l'avance. Les fichiers servent d'interm&eacute;diaires entre le syst&egrave;me de base de donn&eacute;es et le syst&egrave;me d'exploitation. En cons&eacute;quence, les variantes SQL Server et Oracle de <span class="emphasis">CREATE DATABASE</span> sont plus &eacute;labor&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La syntaxe dans Microsoft SQL Server ressemble &agrave; ce qui suit:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE DATABASE database_name[ ON [PRIMARY][ &lt;file&gt; [,...n] ][, &lt;file_group&gt; [,...n] ]][ LOG ON { &lt;file&gt; [,...n]} ][ FOR LOAD | FOR ATTACH ]GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans cette impl&eacute;mentation, il est non seulement possible de fournir le nom de la base de donn&eacute;es, mais aussi de sp&eacute;cifier  l'emplacement o&ugrave; on souhaite qu'elle soit stock&eacute;e. Oracle et SQL Server utilisent tous les deux <span class="emphasis">files</span> (un espace pr&eacute;d&eacute;fini dans la structure du disque) comme d&eacute;p&ocirc;t pour les bases de donn&eacute;es. Les bases de donn&eacute;es peuvent &ecirc;tre stock&eacute;es dans un ou plusieurs fichiers ou groupes de fichiers. SQL Server permet aussi de conserver le journal des transactions dans un emplacement s&eacute;par&eacute; via la clause <span class="emphasis">LOG ON</span>. Gr&acirc;ce &agrave; ces fonctions, il est possible de planifier les fichiers de fa&ccedil;on &agrave; permettre un contr&ocirc;le optimal des E-S sur disque.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les clauses <span class="emphasis">FOR LOAD</span> pr&eacute;cisent que d&egrave;s sa cr&eacute;ation, la base de donn&eacute;es sera charg&eacute;e &agrave; partir d'une copie de sauvegarde, ce qui permet d'acc&eacute;l&eacute;rer le processus de cr&eacute;ation initial. La clause <span class="emphasis">FOR ATTACH</span> indique &agrave; SQL Server que la base de donn&eacute;es est rattach&eacute;e &agrave; partir d'une structure de fichiers de syst&egrave;me d'exploitation existante, soit un DVD-ROM, un CD-ROM ou un disque dur portable.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL et MySQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans MySQL, <span class="emphasis">CREATE DATABASE</span> revient essentiellement &agrave; cr&eacute;er un nouveau r&eacute;pertoire qui contient les objets de la base de donn&eacute;es. Ainsi, avec les syst&egrave;mes de ces &eacute;diteurs, il n'est gu&egrave;re plus difficile de cr&eacute;er une base de donn&eacute;es que de cr&eacute;er un r&eacute;pertoire de syst&egrave;me de fichiers. La base de donn&eacute;es est cr&eacute;&eacute;e sous forme de r&eacute;pertoire dans le r&eacute;pertoire principal de l'&eacute;diteur, et les nouveaux objets cr&eacute;&eacute;s au sein de la base de donn&eacute;es sont plac&eacute;s dans ce m&ecirc;me r&eacute;pertoire. PostgreSQL offre la m&ecirc;me fonctionalit&eacute;, mais permet en plus de sp&eacute;cifier l'emplacement de la base de donn&eacute;es avec l'option <span class="emphasis">WITH LOCATION</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE DATABASE name [ WITH LOCATION = 'dbpath'];</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Par exemple, pour cr&eacute;er la base de donn&eacute;es <span class="emphasis">sales_revenue</span> dans le r&eacute;pertoire <span class="emphasis">/home/teddy/private_db</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE DATABASE sales_revenue WITH LOCATION = '/home/teddy/private_db';</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE DATABASE [database_name][CONTROLFILE REUSE][LOGFILE [GROUP1 integer] file1 integer [K | M] [,...n] [REUSE]]  [MAXLOGFILES integer]  [[MAXLOGMEMBERS] integer]  [[MAXLOGHISTORY] integer][DATAFILE file1 [AUTOEXTEND [,...n] [ON | OFF]]   [NEXT integer [K | M]]   [MAXSIZE [UNLIMITED | integer [K | M]]  [MAXDATAFILES integer]  [,...n]][MAXINSTANCES integer][MAXDATAFILES integer][ARCHIVELOG | NOARCHIVELOG]{CHARACTER SET charset}{NATIONAL CHARACTER SET charset};</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Oracle, <span class="emphasis">CREATE DATABASE</span> est une commande tr&egrave;s puissante et devrait &ecirc;tre r&eacute;serv&eacute;e aux administrateurs de bases de donn&eacute;es exp&eacute;riment&eacute;s. Les novices devraient &ecirc;tre conscients que l'utilisation de cette commande pose un risque de destruction de la base de donn&eacute;es existante.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Comme Microsoft SQL Server, Oracle permet de contr&ocirc;ler de nombreux aspects des structures de fichiers de la base de donn&eacute;es, bien au-del&agrave; de l'attribution d'un nom ou de la d&eacute;signation du chemin d'acc&egrave;s de ses fichiers. De m&ecirc;me, le fichier <span class="emphasis">INIT.ORA</span>, qui pr&eacute;cise le nom et toute une s&eacute;rie d'autres options au moment de la cr&eacute;ation et du d&eacute;marrage de la base de donn&eacute;es, est une particularit&eacute; de l'environnement Oracle. Le fichier <span class="emphasis">INIT.ORA</span>, qui indique les fichiers de contr&ocirc;le, doit obligatoirement &ecirc;tre utilis&eacute;. Dans le cas contraire, il serait impossible de lancer la base de donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Lorsque l'option <span class="emphasis">the file1 [,...n]</span> est disponible, le nom et la taille du fichier peuvent &ecirc;tre indiqu&eacute;s en octets, kilooctets ou m&eacute;gaoctets selon le format suivant:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>'file_path_and_name'SIZE bytes [K | M] REUSE</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les options <span class="emphasis">[K | M]</span> multiplient respectivement la taille du fichier en octets par 1024 et 1048576. Tandis que l'option <span class="emphasis">REUSE</span> peut soit cr&eacute;er un nouveau fichier, soit, le cas &eacute;ch&eacute;ant, r&eacute;utiliser un fichier existant, <span class="emphasis">CONTROLFILE REUSE</span> efface les fichiers de contr&ocirc;le. De la m&ecirc;me fa&ccedil;on, <span class="emphasis">LOGFILE... REUSE</span> efface les fichiers journaux.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les groupes de fichiers journaux sont habituellement affich&eacute;s entre parenth&egrave;ses. Les parenth&egrave;ses ne sont pas n&eacute;cessaires lorsqu'on cr&eacute;e un groupe qui ne compte qu'un seul membre, mais elles sont rarement omises. Voici un exemple de liste de fichiers journaux entre parenth&egrave;ses:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE DATABASE publicationsLOGFILE ('/s01/oradata/loga01','/s01/oradata/loga02') SIZE 5MDATAFILE</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>En outre, les options et sous-options <span class="emphasis">LOGFILE</span> et <span class="emphasis">DATAFILE</span> permettent un contr&ocirc;le pr&eacute;cis de la taille et des modes de croissance des fichiers de reprise et des fichiers de donn&eacute;es.  <span class="emphasis">MAXLOGFILES</span> et <span class="emphasis">MAXDATAFILES</span> d&eacute;finissent respectivement le nombre maximal absolu de fichiers de reprise et de fichiers de donn&eacute;es. Quand <span class="emphasis">AUTOEXTEND</span> est activ&eacute;, le fichier de donn&eacute;es grossit par incr&eacute;ments de <span class="emphasis">NEXT</span> jusqu&acute;&agrave; atteindre <span class="emphasis">MAXSIZE,</span> &agrave; moins qu'il ne soit param&eacute;tr&eacute; sur <span class="emphasis">UNLIMITED</span>.  <span class="emphasis">MAXLOGMEMBERS</span> contr&ocirc;le le nombre maximum de copies d'un groupe de fichiers de reprise.  <span class="emphasis">MAXLOGHISTORY</span>, qui est utilis&eacute; dans Oracle Parallel Server, contr&ocirc;le le nombre maximum de fichiers de reprise archiv&eacute;s de telle sorte que la quantit&eacute; d'espace inscrite dans le fichier de contr&ocirc;le est correcte.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le param&egrave;tre <span class="emphasis">MAXINSTANCES</span> fixe le nombre maximum d'instances qui peuvent &ecirc;tre introduites dans la base de donn&eacute;es en cours de cr&eacute;ation.  <span class="emphasis">ARCHIVELOG</span> | <span class="emphasis">NOARCHIVELOG</span> sont des options contradictoires qui d&eacute;finissent le fonctionnement des fichiers de reprise.  <span class="emphasis">ARCHIVELOG</span> sauvegarde les donn&eacute;es vers un fichier d'archivage suppl&eacute;mentaire, assurant la possibilit&eacute; de r&eacute;tablir le support. Ces options offrent toutes les deux une facult&eacute; de r&eacute;cup&eacute;ration, mais <span class="emphasis">NOARCHIVELOG</span> (le r&eacute;glage par d&eacute;faut) ne permet en g&eacute;n&eacute;ral pas de r&eacute;tablir le support. <span class="emphasis">CHARACTER SET</span>, qui d&eacute;pend du syst&egrave;me d'exploitation, contr&ocirc;le la langue et le jeu de caract&egrave;res dans lesquels les donn&eacute;es sont stock&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CREATE FUNCTION">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CREATE FUNCTION</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L'instruction  <span class="emphasis">CREATE FUNCTION</span>    cr&eacute;e une <span class="emphasis">fonction d&eacute;finie par l'utilisateur</span> qui part des arguments saisis et renvoie une valeur unique, de la m&ecirc;me fa&ccedil;on que <span class="emphasis">CAST( )</span>. Comme toute autre fonction syst&egrave;me, une fonction utilisateur peut &ecirc;tre invoqu&eacute;e dans une requ&ecirc;te.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Reportez-vous au chapitre 4 pour une description exhaustive des fonctions SQL et de leur impl&eacute;mentation par les diff&eacute;rents &eacute;diteurs.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">CREATE FUNCTION</span> permet aux programmeurs de base de donn&eacute;es de cr&eacute;er des fonctions qu'ils d&eacute;finissent eux-m&ecirc;mes, les fonctions utilisateur. Ces fonctions, une fois cr&eacute;&eacute;es, peuvent &ecirc;tre invoqu&eacute;es dans des requ&ecirc;tes et des op&eacute;rations de manipulation des donn&eacute;es comme <span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span> et la clause <span class="emphasis">WHERE</span> des instructions <span class="emphasis">DELETE</span>. Bien que la syntaxe de base de l'instruction ait &eacute;t&eacute; montr&eacute;e plus haut, cette commande a &eacute;t&eacute; impl&eacute;ment&eacute;e de tant de fa&ccedil;ons diff&eacute;rentes par les diff&eacute;rents &eacute;diteurs que les syntaxes sont reprises plus bas dans cette section.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE FUNCTION function_name[(parameter datatype attributes [,...n])]RETURNS datatype [LANGUAGE {ADA | C | FORTRAN | MUMPS | PASCAL | PLI | SQL}] [PARAMETER STYLE {SQL | GENERAL}] [SPECIFIC specific_name] [DETERMINISTIC | NOT DETERMINISTIC] [NO SQL | CONTAINS SQL | READS SQL DATA | MODIFIES SQL DATA] [RETURNS NULL ON NULL INPUT | CALL ON NULL INPUT] [STATIC DISPATCH]code block</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La norme SQL99 pour l'instruction <span class="emphasis">CREATE FUNCTION</span> comprend un composant principal et un composant plus &eacute;labor&eacute;, moins souvent utilis&eacute;. Dans la plupart des fonctions utilisateur, l'utilisateur d&eacute;finit le nom de la fonction, les param&egrave;tres d'entr&eacute;e souhait&eacute;s, et la valeur qu'elle renvoie. Ce sont les usages de base de cette commande.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cependant, la norme SQL99 permet d'en faire beaucoup plus.  <span class="emphasis">LANGUAGE</span> sp&eacute;cifie le langage de la fonction (par exemple: PostgreSQL).  <span class="emphasis">PARAMETER STYLE</span> permet de d&eacute;clarer un style de param&egrave;tre autre que le style SQL typique via le mot-cl&eacute; <span class="emphasis">GENERAL</span> (SQL demeure le langage par d&eacute;faut).  <span class="emphasis">SPECIFIC</span> est utilis&eacute; pour pr&eacute;ciser davantage le nom de la fonction dans un type d&eacute;fini par l'utilisateur. Les clauses <span class="emphasis">DETERMINISTIC</span> ou <span class="emphasis">NOT DETERMINISTIC</span> indiquent au SGBD h&ocirc;te si la fonction doit toujours renvoyer le m&ecirc;me r&eacute;sultat pour les m&ecirc;mes param&egrave;tres d'entr&eacute;e (elle est d&eacute;terministique) ou non. Seules les fonctions d&eacute;terministiques peuvent &ecirc;tre utilis&eacute;es dans les contraintes.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause d'acc&egrave;s aux donn&eacute;es SQL indique au SGBD h&ocirc;te si la fonction contient du code SQL ou non par <span class="emphasis">CONTAINS SQL</span> ou <span class="emphasis">NO SQL</span>, si elle utilise les instructions <span class="emphasis">SELECT</span> ou <span class="emphasis">FETCH</span> par <span class="emphasis">READS SQL DATA</span>, ou enfin si elle comporte une instruction de modification des donn&eacute;es par <span class="emphasis">MODIFIES SQL DATA</span>.  <span class="emphasis">CONTAINS SQL</span> est la valeur par d&eacute;faut.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour les langages h&ocirc;tes qui n'acceptent pas les nuls, il est possible de d&eacute;clarer <span class="emphasis">RETURNS NULL ON NULL INPUT</span> pour demander &agrave; la fonction de renvoyer imm&eacute;diatement un nul en &eacute;change d'un nul. En revanche, <span class="emphasis">CALL ON NULL INPUT</span> (la valeur par d&eacute;faut) traite le param&egrave;tre nul normalement, et peut renvoyer des r&eacute;sultats inconnus.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">STATIC DISPATCH</span> est utilis&eacute;e pour les fonctions non-SQL dont certains param&egrave;tres utilisent les types utilisateur, ou <span class="emphasis">ARRAYS</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE FUNCTION [owner_name.]function_name( [ {@parameter1 datatype [=default]} [,...n] ] )RETURNS {datatype | TABLE][WITH {ENCRYPTION | SCHEMABINDING}]AS &lt;Transact-SQL body&gt;GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p> Les fonctions SQL Server peuvent renvoyer plusieurs valeurs via le type de donn&eacute;es <span class="emphasis">TABLE</span>. Le type de donn&eacute;es <span class="emphasis">TABLE</span> est consid&eacute;r&eacute; comme <span class="emphasis">inline</span> s'il n'est pas accompagn&eacute; d'une liste de colonnes et s'il est d&eacute;fini &agrave; l'aide d'une seule instruction <span class="emphasis">SELECT</span>. Si la clause <span class="emphasis">RETURN</span> livre plusieurs valeurs via le type de donn&eacute;es <span class="emphasis">TABLE</span>, et si la <span class="emphasis">TABLE</span> a d&eacute;fini des colonnes avec leur type de donn&eacute;es, cette fonction est une fonction <span class="emphasis">multi-instructions</span> &agrave; valeur table.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>SQL Server exige qu'un ou plusieurs param&egrave;tres fournis par l'utilisateur soient d&eacute;clar&eacute;s pour une fonction utilisateur donn&eacute;e. Tous les types de donn&eacute;es SQL Server sont reconnus comme des param&egrave;tres, sauf <span class="emphasis">timestamp</span>. Les valeurs renvoy&eacute;es par la fonction peuvent appartenir &agrave; n'importe quel type de donn&eacute;es sauf <span class="emphasis">timestamp</span>, <span class="emphasis">text</span>, <span class="emphasis">ntext</span> ou <span class="emphasis">image</span>. Si une valeur de table inline est requise, l'option <span class="emphasis">TABLE</span> sans liste de colonnes peut &ecirc;tre utilis&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les fonctions utilisateur de Microsoft SQL Server, comme de nombreux autres objets de base de donn&eacute;es dans SQL Server, peuvent &ecirc;tre cr&eacute;&eacute;es avec les options <span class="emphasis">ENCRYPTION</span> ou <span class="emphasis">SCHEMABINDING</span>. L'option <span class="emphasis">ENCRYPTION</span> indique &agrave; SQL Server de chiffrer la table &agrave; colonnes du syst&egrave;me o&ugrave; le texte de la fonction est stock&eacute;, et ainsi d'emp&ecirc;cher une r&eacute;vision intempestive du code de la fonction. L'option <span class="emphasis">SCHEMABINDING</span> pr&eacute;cise que la fonction est li&eacute;e &agrave; un objet de base de donn&eacute;es sp&eacute;cifique, tel qu'une table ou une vue. Cet objet de base de donn&eacute;es ne peut &ecirc;tre ni modifi&eacute;, ni abandonn&eacute; aussi longtemps que la fonction existe (ou qu'elle conserve l'option <span class="emphasis">SCHEMABINDING</span>).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le corps du code Transact-SQL consiste soit en une seule instruction <span class="emphasis">SELECT</span> pour une fonction inline, selon le format <span class="emphasis">RETURN (SELECT...)</span>, soit en une s&eacute;rie d'instructions Transact-SQL pour une op&eacute;ration multi-instructions. Le corps du Transact-SQL contenu dans un bloc <span class="emphasis">BEGIN... END</span> ne peut pas modifier les donn&eacute;es de fa&ccedil;on permanente, ni causer d'effets secondaires durables. La derni&egrave;re instruction du bloc doit &ecirc;tre un <span class="emphasis">RETURN</span> inconditionnel qui renvoie une valeur de type de donn&eacute;es ou une valeur <span class="emphasis">TABLE</span> unique.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le bloc Transact-SQL ne peut contenir de variables globales renvoyant des valeurs changeantes, comme <span class="emphasis">@@CONNECTIONS</span> ou <span class="emphasis">GETDATE</span>, mais il peut contenir des variables renvoyant des valeurs uniques toujours identiques, comme <span class="emphasis">@@SERVERNAME</span>. Il existe un certain nombre d'autres restrictions dues au fait le code ne peut modifier les donn&eacute;es de fa&ccedil;on permanente, ni causer d'effets secondaires durables. Par exemple, les instructions <span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span> et <span class="emphasis">DELETE</span> ne peuvent modifier que des variables <span class="emphasis">TABLE</span> locales de la fonction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'exemple suivant montre une fonction scalaire qui renvoie une valeur unique:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE FUNCTION metric_volume -- Input dimensions in centimeters.  (@length decimal(4,1),  @width decimal(4,1),  @height decimal(4,1) )RETURNS decimal(12,3) -- Cubic Centimeters.AS BEGIN   RETURN ( @length * @width * @height )  ENDGO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Comme n'importe quelle autre fonction, cette fonction utilisateur peut &ecirc;tre utilis&eacute;e dans une requ&ecirc;te ou pour toute autre op&eacute;ration. Par exemple, on peut d&eacute;terminer le nom et le volume m&eacute;trique de tous les projets de construction d&eacute;passant 300 000 en volume m&eacute;trique:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT project_name,  metric_volume(construction_height,   construction_length,   construction_width)FROM housing_constructionWHERE metric_volume(construction_height,   construction_length,   construction_width) &gt;= 300000GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les fonctions utilisateur qui renvoient une valeur de table sont souvent s&eacute;lectionn&eacute;es comme valeurs d'un jeu de r&eacute;sultats ou utilis&eacute;es dans la clause <span class="emphasis">FROM</span> d'une instruction <span class="emphasis">SELECT</span>, tout comme une table ordinaire. Dans une clause <span class="emphasis">FROM</span>, une fonction alias de table peut &ecirc;tre d&eacute;sign&eacute;e exactement comme une table ordinaire. Par exemple:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT co.order_id, co.order_priceFROM  construction_orders AS co,    fn_construction_projects('Cancelled') AS fcpWHERE co.construction_id = fcp.construction_idORDER BY co.order_idGO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans MySQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [AGGREGATE] FUNCTION function_nameRETURNS {STRING | REAL | INTEGER}SONAME shared_program_library_name;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans MySQL, <span class="emphasis">CREATE FUNCTION</span> rassemble des fonctions utilisateur, comme <span class="emphasis">SUM( )</span> et <span class="emphasis">COUNT( )</span>, via l'option <span class="emphasis">AGGREGATE</span>. Le type de valeur renvoy&eacute;e peut &ecirc;tre soit <span class="emphasis">STRING</span> pour les donn&eacute;es de type caract&egrave;re, <span class="emphasis">REAL</span> pour les nombres &agrave; virgule flottante ou <span class="emphasis">INTEGER</span> pour les nombres entiers.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'impl&eacute;mentation de <span class="emphasis">CREATE FUNCTION</span> dans MySQL diff&egrave;re consid&eacute;rablement de celle des autres &eacute;diteurs puisque le code proc&eacute;dural doit &ecirc;tre en C/C++ et s'ex&eacute;cuter sous un syst&egrave;me d'exploitation qui supporte le chargement dynamique. Le programme C/C++ est nomm&eacute; dans l'option <span class="emphasis">shared_program_library_name</span>. La fonction peut &ecirc;tre compil&eacute;e soit directement dans le serveur MySQL, ce qui la rend disponible de fa&ccedil;on permanente, soit comme un programme appel&eacute; dynamiquement. La fonction utilisateur &eacute;tant r&eacute;dig&eacute;e sous la forme d'un programme en C/C++, sa description d&eacute;taill&eacute;e d&eacute;passe le cadre de cet ouvrage.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [OR REPLACE] FUNCTION [owner_name.]function_name[(parameter1 [IN | OUT | IN OUT] [NOCOPY] datatype][,...n)]]RETURN datatype [DETERMINISTIC | AUTHID {CURRENT_USER | DEFINER} ] {IS | AS} {PL/SQL block | external program};</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Oracle,les fonctions utilisateur et les proc&eacute;dures stock&eacute;es pr&eacute;sentent une composition et une structure tout &agrave; fait similaires. La diff&eacute;rence essentielle est que les proc&eacute;dures stock&eacute;es ne peuvent pas renvoyer de valeurs au processus d'invocation, tandis que les fonctions peuvent renvoyer une valeur unique.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans une fonction utilisateur Oracle, les arguments et param&egrave;tres sp&eacute;cifi&eacute;s incluent  <span class="emphasis">IN</span>, <span class="emphasis">OUT</span> et <span class="emphasis">IN OUT</span>. Le qualificateur <span class="emphasis">IN</span> est fourni lorsque la fonction est invoqu&eacute;e et il envoie une valeur &agrave; la fonction, tandis que l'argument <span class="emphasis">OUT</span> renvoie une valeur au processus d'invocation. En d'autres termes, le qualificateur <span class="emphasis">IN</span> est fourni par l'utilisateur ou le processus qui appelle la fonction, tandis que l'argument <span class="emphasis">OUT</span> est renvoy&eacute; par la fonction. Les arguments <span class="emphasis">IN OUT</span> ex&eacute;cutent aussi bien les fonctionnalit&eacute;s de <span class="emphasis">IN</span> que de <span class="emphasis">OUT</span>. Le mot-cl&eacute; NOCOPY est utile pour acc&eacute;l&eacute;rer la performance quand un argument <span class="emphasis">OUT</span> ou <span class="emphasis">IN OUT</span> est tr&egrave;s volumineux, comme c'est le cas pour les donn&eacute;es de type varray ou enregistrement.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le mot-cl&eacute; <span class="emphasis">RETURN</span> sp&eacute;cifie le type de donn&eacute;es de la valeur renvoy&eacute;e par la fonction. Le mot-cl&eacute; <span class="emphasis">DETERMINISTIC</span> sert &agrave; acc&eacute;l&eacute;rer le traitement par les fonctions qui ont &eacute;t&eacute; explicitement d&eacute;clar&eacute;es d&eacute;terministiques. La valeur de retour stock&eacute;e peut provenir d'une vue mat&eacute;rialis&eacute;e, d'un appel simultan&eacute; de la m&ecirc;me fonction ou d'un index bas&eacute; sur la fonction. Il est aussi possible d'obliger la fonction &agrave; s'ex&eacute;cuter soit dans le contexte de permission de l'utilisateur actif avec l'expression <span class="emphasis">AUTHID CURRENT_USER</span>, soit dans celui du propri&eacute;taire de la fonction avec l'expression <span class="emphasis">AUTHID DEFINER</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Par exemple, les profits engendr&eacute;s par un projet de construction peuvent &ecirc;tre determin&eacute;s en envoyant le nom du projet avec cette fonction:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE FUNCTION project_revenue (project IN varchar2)RETURN NUMBERAS  proj_rev NUMBER(10,2);BEGIN  SELECT SUM(DECODE(action,'COMPLETED',amount,0)) -     SUM(DECODE(action,'STARTED',amount,0))  +     SUM(DECODE(action,'PAYMENT',amount,0))  INTO proj_rev  FROM construction_actions  WHERE project_name = project;  RETURN (proj_rev);END;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans cet exemple, la fonction utilisateur accepte le nom de projet comme argument. Ensuite, elle traite les revenus du projet, de mani&egrave;re invisible, en soustrayant les co&ucirc;ts de d&eacute;part du paiement final, et en y ajoutant tous les autres paiements re&ccedil;us. La ligne  <span class="literal">RETURN(proj_rev);</span> renvoie le montant au processus d'invocation.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE FUNCTION name ( [ parameter1 [,...n] ] )RETURNS datatypeAS {definition | object_file, link_symbol}LANGUAGE {'C'| 'SQL'| 'PLPGSQL'| 'PLTCL'| 'PLTCLU'| 'PLPERL'  | 'internal'}[WITH ISCACHABLE];</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'impl&eacute;mentation de la commande <span class="emphasis">CREATE FUNCTION</span> par PostgreSQL compte parmi les plus souples qui soient. Comme pour les autres impl&eacute;mentations, les <span class="emphasis">parameters</span> sont invoqu&eacute;s et renvoient une valeur de type de donn&eacute;es. PostgreSQL permet aussi  la <span class="emphasis">surcharge</span> de la fonction, c'est-&agrave;-dire que plusieurs fonctions peuvent porter le m&ecirc;me nom, &agrave; conditions qu'elles acceptent des param&egrave;tres d'entr&eacute;e distincts.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'attribut de type de donn&eacute;es <span class="emphasis">WITH ISCACHABLE</span> optimise la performance de PostgreSQL en indiquant que la fonction renvoie toujours les m&ecirc;mes valeurs pour les m&ecirc;mes param&egrave;tres. Cette configuration permet ensuite &agrave; l'optimiseur de pr&eacute;-&eacute;valuer l'appel de la fonction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La <span class="emphasis">definition</span> peut consister en une cha&icirc;ne qui d&eacute;finit la  fonction (selon le langage dans lequel la fonction est &eacute;crite), comme un nom de fonction interne, le chemin d'acc&egrave;s et le nom d'un fichier objet, une requ&ecirc;te SQL ou le texte d'un langage proc&eacute;dural. La d&eacute;finition peut aussi &ecirc;tre un <span class="emphasis">object file</span> et un <span class="emphasis">link symbol</span> vers une fonction en C.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Voici un exemple de fonction SQL simple dans PostgreSQL:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE FUNCTION max_project_nbrRETURNS int4AS "SELECT MAX(project_ID) FROM housing_construction AS RESULT"LANGUAGE 'sql';</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans PostgreSQL, <span class="emphasis">CREATE FUNCTION</span> remplace <span class="emphasis">CREATE PROCEDURE</span>et sert &eacute;galement &agrave; d&eacute;finir des actions pour <span class="emphasis">CREATE TRIGGER</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le mot-cl&eacute; <span class="emphasis">LANGUAGE</span> permet &agrave; la fonction PostgreSQL d'appeler un programme ext&eacute;rieur. Ces programmes &eacute;tant compil&eacute;s dans d'autres langages, ils d&eacute;passent le cadre de cet ouvrage. Toutefois, il convient d'utiliser la clause <span class="emphasis">LANGUAGE `sql'</span> pour &eacute;crire des fonctions utilisateur en SQL.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CREATE INDEX">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CREATE INDEX</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>  Les index sont des objets particuliers cr&eacute;&eacute;s &agrave; partir des tables et qui acc&eacute;l&egrave;rent de nombreuses op&eacute;rations de manipulation des donn&eacute;es, comme les instructions <span class="emphasis">SELECT</span>, <span class="emphasis">UPDATE</span> et <span class="emphasis">DELETE</span>. Lorsqu'un index est cr&eacute;&eacute;, l'emplacement et l'&eacute;tendue des valeurs de la colonne index&eacute;e (appel&eacute;s statistiques) sont d&eacute;termin&eacute;s. La s&eacute;lectivit&eacute; d'une clause <span class="emphasis">WHERE</span> donn&eacute;e est habituellement fond&eacute;e sur la qualit&eacute; des index plac&eacute;s sur la table.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">CREATE INDEX</span> varie beaucoup d'un &eacute;diteur &agrave; l'autre. L'une des raisons en est que certains &eacute;diteurs de SGBD l'utilisent pour d&eacute;terminer la fa&ccedil;on dont les donn&eacute;es d'une table sont physiquement tri&eacute;es et rang&eacute;es sur le disque. </p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE INDEX index_name ON table_name (column_name [,...n])</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Tous les principaux &eacute;diteurs reconnaissent les <span class="emphasis">index compos&eacute;s</span>, aussi nomm&eacute;s <span class="emphasis">index concat&eacute;n&eacute;s</span>. Ces index sont utilis&eacute;s lorsqu'il est pr&eacute;f&eacute;rable d'effectuer une recherche sur deux colonnes (ou plus), en les traitant comme une seule entit&eacute; (par exemple, les colonnes &laquo;&#160; nom&#160;&raquo; et &laquo;&#160; pr&eacute;nom&#160;&raquo;).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [UNIQUE] [CLUSTERED | NONCLUSTERED] INDEX <span class="replaceable">index_name</span>ON {<span class="replaceable">table | view}</span> <span class="replaceable">(column [ASC | DESC]</span> [,...n])[WITH [PAD_INDEX]  [[,] FILLFACTOR = fillfactor]  [[,] IGNORE_DUP_KEY]  [[,] DROP_EXISTING]  [[,] STATISTICS_NORECOMPUTE] ][ON filegroup]GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server offre des options d'importance. Par exemple, on peut cr&eacute;er des index soit ascendants, soit descendants sur les tables. On peut &eacute;galement cr&eacute;er des index sur les vues et les  colonnes calcul&eacute;es (comme <span class="emphasis">UPPER(book_name)</span> ou <span class="emphasis">((qty * amt) / royalty)</span> ). SQL Server permet aussi de sp&eacute;cifier plusieurs arguments optionnels:  <span class="emphasis">UNIQUE</span>, <span class="emphasis">CLUSTERED</span>, ou <span class="emphasis">NONCLUSTERED</span> (d&eacute;faut). <span class="emphasis">Les index uniques</span>  interdisent la saisie de valeurs identiques dans les colonnes index&eacute;es. Toute tentative d'insertion ou de mise &agrave; jour qui dupliquerait une valeur d&eacute;j&agrave; pr&eacute;sente dans l'index causerait une erreur. <span class="emphasis">Les index clusteris&eacute;s</span> pr&eacute;cisent l'ordre de tri physique des donn&eacute;es sur le disque. <span class="emphasis">Les index non clusteris&eacute;s</span> cr&eacute;ent un ordre logique qui est utilis&eacute; pour acc&eacute;l&eacute;rer les op&eacute;rations de manipulation des donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>SQL Server permet des syntaxes additionnelles:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ol><li> <span class="emphasis">PAD_INDEX</span> pr&eacute;cise que tel espace devrait rester vierge sur chaque page de l'index, en fonction de la valeur de <span class="emphasis">FILLFACTOR</span>.</li><li> <span class="emphasis">FILLFACTOR</span> est une valeur exprim&eacute;e en pourcentage (de 1 &agrave; 100) qui indique &agrave; SQL Server le taux de remplissage &agrave; respecter pour chaque page de 8 Ko au moment de la cr&eacute;ation de l'index. C'est utile pour &eacute;viter d'avoir &agrave; trop diviser les pages &agrave; mesure qu'elles se remplissent, et donc r&eacute;duire les op&eacute;rations de disque &agrave; forte proportion d'E/S. La cr&eacute;ation d'un index clusteris&eacute; avec un facteur de remplissage explicite peut augmenter la taille de l'index et, dans certaines circonstances, en acc&eacute;l&eacute;rer le traitement.</li><li> <span class="emphasis">IGNORE_DUP_KEY</span> d&eacute;termine l'action entreprise lorsqu'un enregistrement d'un index unique est dupliqu&eacute; suite &agrave; une op&eacute;ration d'insertion ou de mise &agrave; jour. Si l'option est configur&eacute;e, seule la ligne dupliqu&eacute;e est exclue de l'op&eacute;ration. Sinon, alors tous les enregistrements sur lesquels porte l'op&eacute;ration sont annul&eacute;s (m&ecirc;me s'ils ne sont pas dupliqu&eacute;s).</li><li> <span class="emphasis">DROP_EXISTING</span> est une option utile puisqu'elle permet d'indiquer &agrave; SQL Server d'abandonner tous les index existants et de recr&eacute;er l'index sp&eacute;cifi&eacute;.</li><li> <span class="emphasis">STATISTICS_NORECOMPUTE</span> emp&ecirc;che SQL Server de recalculer les statistiques d'index. Ceci peut acc&eacute;l&eacute;rer l'op&eacute;ration <span class="emphasis">CREATE INDEX</span>, mais tend &agrave; r&eacute;duire l'utilit&eacute; de l'index.</li><li>ON <span class="emphasis">filegroup</span> cr&eacute;e un index sur un groupe de fichiers existant. Il devient alors possible de placer les index sur un disque dur ou un p&eacute;riph&eacute;rique RAID sp&eacute;cifique.</li></ol>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La cr&eacute;ation d'un index demande habituellement 1,2 &agrave; 1,5 fois plus d' espace que la table n'en occupe normalement. La majorit&eacute; de cet espace suppl&eacute;mentaire est lib&eacute;r&eacute;e une fois l'index cr&eacute;&eacute;.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans MySQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [UNIQUE] INDEX index_name ON table_name (column_name(length) [,...n])</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>MySQL suit la norme ANSI de base pour l'instruction <span class="emphasis">CREATE INDEX</span>, y compris la facult&eacute; de g&eacute;n&eacute;rer unindex sur plusieurs colonnes. Un index peut &ecirc;tre d&eacute;fini comme <span class="emphasis">UNIQUE</span>, ce qui l'oblige &agrave; n'accepter que des valeurs uniques. Toute tentative d'ins&eacute;rer une valeur non-unique dans une table dot&eacute;e d'un index <span class="emphasis">UNIQUE</span> est rejet&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il est int&eacute;ressant de noter que MySQL laisse &eacute;galement ses utilisateurs g&eacute;n&eacute;rer un index &agrave; partir des premiers <span class="emphasis">(length)</span> caract&egrave;res d'une colonne <span class="emphasis">CHAR</span> ou <span class="emphasis">VARCHAR</span>. Ceci peut &ecirc;tre utile lorsque la s&eacute;lectivit&eacute; des 10 premiers caract&egrave;res (par exemple) d'une colonne est suffisante, et lorsqu'il est essentiel d'&eacute;conomiser l'espace disque. </p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [UNIQUE | BITMAP] INDEX [owner_name.]index_nameON [schema.]{table ({column | expression} [ASC | DESC] [,...n])  | CLUSTER cluster_name}[physical_attributes_clause | {LOGGING | NOLOGGING} | | [ONLINE] | [COMPUTE [STATISTICS] ] | {TABLESPACE tablespace_name | DEFAULT} | {COMPRESS int | NOCOMPRESS} | {NOSORT |REVERSE} ],... [GLOBAL PARTITION BY RANGE (column_list)  (PARTITION [partition_name] VALUES LESS THAN (value_list)  [physical_attributes_clause | {LOGGING | NOLOGGING} ] ,...n )| LOCAL [ (PARTITION [partition_name]  [physical_attributes_clause | {LOGGING | NOLOGGING} ] ,...n ) ] ][PARALLEL [int] | NOPARALLEL]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet de cr&eacute;er des index bas&eacute;s non seulement sur les valeurs des colonnes, mais aussi sur des expressions calcul&eacute;es, comme <span class="emphasis">UPPER(book_name)</span> ou <span class="emphasis">((qty * amt) / royalty)</span>. Ces index peuvent &ecirc;tre <span class="emphasis">UNIQUE</span> ou non-uniques. Oracle permet aussi de cr&eacute;er un index <span class="emphasis">BITMAP</span>  , ce qui est utile pour les colonnes qui n'ont pas beaucoup de valeurs distinctes. En outre, Oracle permet de g&eacute;n&eacute;rer des index ascendants ( <span class="emphasis">ASC</span>) et descendants (<span class="emphasis">DESC</span>). Toutefois, il faut noter qu'Oracle traite les index <span class="emphasis">DESC</span> comme des index bas&eacute;s sur des fonctions. Il y a quelques diff&eacute;rences de fonctionnalit&eacute; entre les index <span class="emphasis">ASC</span> et <span class="emphasis">DESC</span>. Il est &eacute;galement possible de sp&eacute;cifier une cl&eacute; de cluster pour l'index &agrave; l'aide de l'option <span class="emphasis">CLUSTER</span>. Les clusters sont cr&eacute;&eacute;s via la commande Oracle exclusive <span class="emphasis">CREATE CLUSTER.</span> )</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La d&eacute;finition d'un index clusteris&eacute; varie de fa&ccedil;on significative entre Oracle et SQL Server. Dans SQL Server, un <span class="emphasis">clustered index</span>  d&eacute;termine l'ordre de tri des donn&eacute;es d'une table au plan physique. Dans Oracle, un <span class="emphasis">cluster</span> est un index sp&eacute;cial portant sur deux tables ou plus et qui acc&eacute;l&egrave;re consid&eacute;rablement les op&eacute;rations de jointure.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">physical_attributes_clause</span> se rapporte aux configurations qui peuvent &ecirc;tre &eacute;tablies pour les options suivantes:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>[ PCTFREE int| PCTUSED int| INITRANS int| MAXTRANS int| STORAGE storage...]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p> <span class="emphasis">PCTFREE</span> se rapproche de l'option <span class="emphasis">FILLFACTOR</span> de SQL Server, puisqu'il pr&eacute;cise le pourcentage d'espace &agrave; laisser libre dans l'index pour accommoder les nouvelles saisies et les mises &agrave; jour. <span class="emphasis">PCTFREE</span> ne peut &ecirc;tre utilis&eacute; que pour les index qui ne sont pas <span class="emphasis">UNIQUE</span>.  <span class="emphasis">PCTUSED</span> est le pourcentage d'espace qui doit &ecirc;tre disponible dans un bloc pour qu'Oracle y autorise les insertions.  <span class="emphasis">PCTUSED</span> peut &ecirc;tre utilis&eacute; pour les tables, mais pas pour les index.  <span class="emphasis">STORAGE</span>, <span class="emphasis">INITRANS,</span> et <span class="emphasis">MAXTRANS</span> sont d&eacute;crits sous <span class="emphasis">CREATE TABLE</span>, dans cette section .</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">TABLESPACE</span> affecte l'index &agrave; un tablespace sp&eacute;cifique. Si la clause <span class="emphasis">TABLESPACE</span> est ignor&eacute;e, l'index est plac&eacute; dans le tablespace par d&eacute;faut. Le mot-cl&eacute; <span class="emphasis">DEFAULT</span> a le m&ecirc;me effet.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p> <span class="emphasis">LOGGING</span> indique &agrave; Oracle d'inscrire la cr&eacute;ation de l'index dans le fichier de reprise, tandis que <span class="emphasis">NOLOGGING</span> l'en emp&ecirc;che. Ce mot-cl&eacute; d&eacute;termine &eacute;galement le comportement par d&eacute;faut lors des chargements ult&eacute;rieurs de gros volumes de donn&eacute;es &agrave; l'aide d'Oracle Direct Loader. Lors de la mise en place de partitions d'index, ces mots-cl&eacute; peuvent adopter des comportements sp&eacute;ciaux. Reportez-vous toujours &agrave; la documentation de l'&eacute;diteur avant de proc&eacute;der &agrave; ce type d'op&eacute;rations.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p> <span class="emphasis">ONLINE</span> signale &agrave; Oracle de permettre la manipulation des donn&eacute;es de la table pendant la cr&eacute;ation de l'index. La commande <span class="emphasis">COMPUTE STATISTICS</span> rassemble les statistiques pendant l'op&eacute;ration. Le co&ucirc;t de la collecte des statistiques est relativement faible. <span class="emphasis">COMPRESS</span> active la compression des cl&eacute;s dans les index non partitionn&eacute;s, ce qui lib&egrave;re de l'espace en &eacute;liminant les valeurs de cl&eacute; r&eacute;p&eacute;titives. Le nombre entier qui accompagne l'option <span class="emphasis">COMPRESS</span> indique le nombre de colonnes pr&eacute;fixes &agrave; comprimer.  <span class="emphasis">NOCOMPRESS</span>, qui constitue la configuration par d&eacute;faut, d&eacute;sactive la compression.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet la cr&eacute;ation d'   index et de tables partitionn&eacute;s via la clause <span class="emphasis">PARTITION</span>. Par cons&eacute;quent, les index d'Oracle reconnaissent &eacute;galement les tables partitionn&eacute;es. La clause <span class="emphasis">LOCAL</span> indique &agrave; Oracle de cr&eacute;er des index s&eacute;par&eacute;s pour chaque partition d'une table. La clause <span class="emphasis">GLOBAL</span> sert &agrave; cr&eacute;er un index commun pour toutes les partitions. L'&eacute;tendue des valeurs de l'index peut diff&eacute;rer des &eacute;tendues stock&eacute;es par les partitions.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'option <span class="emphasis">NOSORT</span> permet de g&eacute;n&eacute;rer rapidement un index pour une colonne d&eacute;j&agrave; tri&eacute;e dans l'ordre ascendant. Si les valeurs de la colonne ne sont pas dans parfaitement class&eacute;es dans l'ordre ascendant, l'op&eacute;ration s'interrompt. Il est alors possible de r&eacute;essayer sans l'option <span class="emphasis">NOSORT</span>. <span class="emphasis">REVERSE</span>, au contraire, stocke les blocs de l'index dans l'ordre invers&eacute; (sauf rowed).  <span class="emphasis">REVERSE</span> et <span class="emphasis">NOSORT</span> s'excluent l'un l'autre et ne peuvent &ecirc;tre utilis&eacute;s sur un index bitmap ou une table organis&eacute;e par index.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">PARALLEL</span> permet d'acc&eacute;l&eacute;rer la cr&eacute;ation de l'index en la faisant traiter par des processeurs distincts. Il est possible de d&eacute;finir une valeur (qui doit &ecirc;tre un nombre entier) pour pr&eacute;ciser le nombre exact de threads parall&egrave;les &agrave; utiliser dans l'op&eacute;ration.  <span class="emphasis">NOPARALLEL</span>, qui constitue la configuration par d&eacute;faut, signifie que l'index sera cr&eacute;&eacute; en s&eacute;rie.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [UNIQUE] INDEX index_name ON table[USING [BTREE | RTREE | HASH] ](function_name (column [operator_class] [,...] ))</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL permet la cr&eacute;ation d' index dans l'ordre ascendant standard, ainsi que d'index <span class="emphasis">UNIQUE</span> . Son impl&eacute;mentation inclut &eacute;galement une option permettant d'am&eacute;liorer la performance, la clause <span class="emphasis">WITH access_method</span>. Cette clause permet d'employer l'une des trois m&eacute;thodes d'acc&egrave;s dynamique suivantes:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ul><li><i> <span class="emphasis">BTREE</span></i><br>&#160;						  C'est la m&eacute;thode par d&eacute;faut, quand aucune autre n'est pr&eacute;cis&eacute;e. Elle utilise les arborescences-B de haute concurrence de Lehman-Yao.</li><li><i> <span class="emphasis">RTREE</span></i><br>&#160;						  Cette m&eacute;thode met en &oacute;uvre les arborescences-r standard avec l'algorithme de Guttman.</li><li><i> <span class="emphasis">HASH</span></i><br>&#160;						  Cette m&eacute;thode est une impl&eacute;mentation du hachage lin&eacute;aire de Litwin.</li></ul>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans PostgreSQL, les colonnes peuvent aussi &ecirc;tre associ&eacute;es &agrave; une <span class="emphasis">classe op&eacute;rateur</span> bas&eacute;e sur le type de donn&eacute;es de la colonne. Une classe op&eacute;rateur pr&eacute;cise quels sont les op&eacute;rateurs pour un index particulier. Bien que les utilisateurs soient libres de d&eacute;finir une classe op&eacute;rateur valide quelconque pour une colonne donn&eacute;e, la classe op&eacute;rateur par d&eacute;faut est la classe appropri&eacute;e &agrave; chaque type de champ.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL permet &eacute;galement de d&eacute;finir un index en utilisant soit une fonction, soit une fonction utilisateur, soit une expression. Par exemple, il est possible de d&eacute;finir un index sur <span class="emphasis">UPPER(book_name)</span> pour acc&eacute;l&eacute;rer une op&eacute;ration de transformation souvent appliqu&eacute;e aux donn&eacute;es de base de l'index.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cet exemple dans MySQL cr&eacute;e un simple index ascendant sur la colonne <span class="emphasis">au_id</span> de la table <span class="emphasis">authors</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE INDEX au_id_indON authors (au_id);</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'exemple suivant cr&eacute;e une table <span class="emphasis">housing_construction</span> (comme celle de la section sur <span class="emphasis">CREATE FUNCTION</span>) et g&eacute;n&egrave;re un index clusteris&eacute;. La clause <span class="emphasis">CLUSTERED</span> &eacute;tant sp&eacute;cifi&eacute;e, l'index trie physiquement les donn&eacute;es sur le disque:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TABLE housing_construction  (project_number   INT NOT NULL,  project_date     DATETIME NULL,  project_name     VARCHAR(50)    COLLATE SQL_Latin1_General_CP1_CI_AS NULL ,  construction_color  NCHAR(20)    COLLATE SQL_Latin1_General_CP1_CI_AS NULL ,  construction_height DECIMAL(4, 1) NULL ,  construction_length DECIMAL(4, 1) NULL ,  construction_width  DECIMAL(4, 1) NULL ,  construction_volume INT NULLGOCREATE UNIQUE CLUSTERED INDEX project_id_indON housing_construction(project_id)GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il est souvent n&eacute;cessaire de g&eacute;n&eacute;rer un index qui porte sur plusieurs colonnes, c'est &agrave; dire une <span class="emphasis">cl&eacute; compos&eacute;e</span>. En voici un exemple:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE UNIQUE INDEX project2_indON housing_construction(project_name, project_date)WITH PAD_INDEX, FILLFACTOR = 80GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>En ajoutant la clause <span class="emphasis">PAD_INDEX</span> et en configurant le <span class="emphasis">FILLFACTOR</span> sur 80, on indique &agrave; SQL Server de ne remplir l'index et les pages de donn&eacute;es qu'&agrave; 80&#160;% au lieu de 100&#160;%.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'exemple ci-dessous g&eacute;n&egrave;re le m&ecirc;me index dans Oracle sur un tablespace pr&eacute;cis et avec des instructions indiquant la mani&egrave;re sp&eacute;cifique dont les donn&eacute;es doivent &ecirc;tre stock&eacute;es:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE UNIQUE INDEX project2_indON housing_construction(project_name, project_date)STORAGE (INITIAL 10M NEXT 5M PCTINCREASE 0)TABLESPACE construction;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Si la table <span class="emphasis">housing_construction</span> est cr&eacute;&eacute;e sous forme de table partitionn&eacute;e sur un serveur Oracle, il convient de cr&eacute;er &eacute;galement un index partitionn&eacute;:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE UNIQUE CLUSTERED INDEX project_id_indON housing_construction(project_id)GLOBAL PARTITION BY RANGE (project_id)  (PARTITION part1 VALUES LESS THAN ('K')   TABLESPACE construction_part1_ndx_ts,  PARTITION part2 VALUES LESS THAN (MAXVALUE)   TABLESPACE construction_part2_ndx_ts);</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CREATE PROCEDURE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CREATE PROCEDURE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>Les proc&eacute;dures stock&eacute;es offrent des possibilit&eacute;s de traitement et de programmation condionnelles dans l'environnement du serveur de base de donn&eacute;es. Elles consistent en "capsules" de code de code programme qui peuvent accepter des param&egrave;tres saisis et ex&eacute;cuter des t&acirc;ches complexes. De plus, elles sont pr&eacute;-compil&eacute;es, ce qui les rend tr&egrave;s appr&eacute;ciables, puisqu'elle peuvent ex&eacute;cuter leurs t&acirc;ches rapidement et efficacement, l'optimiseur de la base de donn&eacute;es ayant d&eacute;j&agrave; mis en place un plan d'ex&eacute;cution de leur code.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge (voir la commande CREATE FUNCTION)</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Comme de nombreuses autres instructions <span class="emphasis">CREATE</span>, les &eacute;diteurs ont fait preuve d'une grande diversit&eacute; dans l'impl&eacute;mentation de cette commande.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE PROCEDURE procedure_name[parameter data_type attributes ][,...n]AScode block</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour plus de d&eacute;tails sur la syntaxe SQL99, reportez-vous &agrave; <span class="emphasis">CREATE FUNCTION</span>. Les fonctionnalit&eacute;s perfectionn&eacute;es de <span class="emphasis">CREATE FUNCTION</span> s'appliquent aussi &agrave; <span class="emphasis">CREATE PROCEDURE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Parce que chacun des &eacute;diteurs a impl&eacute;ment&eacute; ses propres extensions proc&eacute;durales au langage SQL, une discussion d&eacute;taill&eacute;e du codage des  proc&eacute;dures stock&eacute;es d&eacute;passe le cadre de cet ouvrage. Toutefois, les notions de base de la programmation de proc&eacute;dures stock&eacute;es y sont pr&eacute;sent&eacute;es. D'autres publications d'O'Reilly, comme <span class="emphasis">Transact-SQL Programming</span>, par Kevin Kline, Lee Gould et Andrew Zanevsky (1999), et <span class="emphasis">Oracle PL/SQL Programming, Second Edition</span>, par Steven Feuerstein avec Bill Pribyl (1997),<span class="emphasis">  </span> contiennent d'excellents expos&eacute;s concernant leurs langages de programmation respectifs.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE PROC[EDURE] <span class="replaceable">procedure_name </span>[;<span class="replaceable">number</span>][{@<span class="replaceable">parameter_name datatype</span>}<span class="replaceable"> </span>[VARYING] [= <span class="replaceable">default</span>] [OUTPUT]][,...<span class="replaceable">n</span>][WITH {RECOMPILE | ENCRYPTION | RECOMPILE, ENCRYPTION}][FOR REPLICATION]ASTransact-SQL_blockGO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>En plus d'un nom de proc&eacute;dure, Microsoft SQL Server permet aussi de pr&eacute;ciser un num&eacute;ro de version selon le format suivant: <span class="emphasis">procedure_name;1,</span>, ou 1 est un nombre entier indiquant la version. Ceci permet d'acc&eacute;der &agrave; plusieurs versions d'une m&ecirc;meproc&eacute;dure stock&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Comme pour les tables (voir CREATE TABLE), il est possible de d&eacute;clarer des soniaproc&eacute;dures temporaires locales et globales en ajoutant ledi&egrave;se (#) ou le    double di&egrave;se (##) respectivement comme pr&eacute;fixe au nom de la proc&eacute;dure. Les proc&eacute;dures temporaires n'existent que pour la dur&eacute;e de la session d'utilisateur ou de processus durant laquelle elles ont &eacute;t&eacute; cr&eacute;&eacute;es. Lorsque cette session se termine, la proc&eacute;dure temporaire s'efface automatiquement.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Une proc&eacute;dure stock&eacute;e SQL Server peut avoir jusqu&acute;&agrave; 1024 param&egrave;tres d'entr&eacute;e, sp&eacute;cifi&eacute;s par un    arobasae (@) et n'importe quel type de donn&eacute;es consid&eacute;r&eacute; acceptable par SQL Server. Les param&egrave;tres des donn&eacute;es de type curseur doivent &ecirc;tre &agrave; la fois <span class="emphasis">VARYING</span> et <span class="emphasis">OUTPUT</span>. Le mot-cl&eacute;  <span class="emphasis">VARYING</span> n'est utilis&eacute; qu'avec les param&egrave;tres de donn&eacute;es de type curseur pour indiquer que le jeu de r&eacute;sultats est g&eacute;n&eacute;r&eacute; dynamiquement par la proc&eacute;dure.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les valeurs des param&egrave;tres d'entr&eacute;e doivent &ecirc;tre fournies par l'utilisateur ou par le processus d'appel. Toutefois, il est possible d'utiliser une valeur par d&eacute;faut pour permettre &agrave; la proc&eacute;dure de s'ex&eacute;cuter m&ecirc;me si l'utilisateur ou le processus n'ont pas fourni de valeur. La valeur par d&eacute;faut doit obligatoirement &ecirc;tre soit une constante, soit NULL, mais elle peut contenir des caract&egrave;res g&eacute;n&eacute;riques, comme l'explique la section <span class="emphasis">LIKE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>De la m&ecirc;me fa&ccedil;on, un param&egrave;tre peut &ecirc;tre d&eacute;clar&eacute; param&egrave;tre de retour en utilisant le mot-cl&eacute; <span class="emphasis">OUTPUT</span>. La valeur stock&eacute;e dans le param&egrave;tre de retour est rapport&eacute;e &agrave; chaque proc&eacute;dure d'appel via les variables de retour de la commande <span class="emphasis">EXEC[UTE]</span> de  SQL Server. Les param&egrave;tres de sortie peuvent consister en n'importe quel type de donn&eacute;es sauf <span class="emphasis">TEXT</span> et <span class="emphasis">IMAGE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les options <span class="emphasis">WITH RECOMPILE</span>, <span class="emphasis">WITH ENCRYPTION</span> et <span class="emphasis">WITH RECOMPILE, ENCRYPTION</span> fonctionnent de la fa&ccedil;on suivante:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ul><li><i>WITH RECOMPILE </i><br>&#160;						  Indique &agrave; SQL Server de ne pas stocker le plan d'ex&eacute;cution dans le cache pour la proc&eacute;dure stock&eacute;e, mais de le recompiler &agrave; chaque ex&eacute;cution. C'est utile lorsque la proc&eacute;dure emploie des valeurs atypiques ou temporaires.</li><li><i>WITH ENCRYPTION </i><br>&#160;						  Chiffre le code de la proc&eacute;dure stock&eacute;e dans la table <span class="emphasis">syscomments</span> de SQL Server.</li><li><i>WITH RECOMPILE, ENCRYPTION</i><br>&#160;						  Permet d'utiliser simultan&eacute;ment les deux options.</li></ul>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">FOR REPLICATION</span>, qui exclue <span class="emphasis">WITH RECOMPILE</span>, d&eacute;sactive l'ex&eacute;cution de la proc&eacute;dure stock&eacute;e sur un serveur abonn&eacute;. Elle est principalement utilis&eacute;e pour cr&eacute;er une proc&eacute;dure stock&eacute;e de filtrage qui n'est ex&eacute;cut&eacute;e que par le moteur de r&eacute;plication int&eacute;gr&eacute; de SQL Server.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">AS Transact-SQL_block</span> contient une ou plusieurs commandes Transact-SQL, jusqu'&agrave; la taille maximum de Mo. Microsoft SQL Server autorise la plupart des instructions Transact-SQL valides, mais <span class="emphasis">SET SHOWPLAN_TEXT</span> et <span class="emphasis">SET SHOWPLAN_ALL</span> sont interdites. Certaines autres commandes voient leur utilisation limit&eacute;e dans les proc&eacute;dures stock&eacute;es. Ce sont en particulier <span class="emphasis">ALTER TABLE</span>, <span class="emphasis">CREATE INDEX</span>, <span class="emphasis">CREATE TABLE</span>, toutes les instructions <span class="emphasis">DBCC</span>, <span class="emphasis">DROP TABLE</span>, <span class="emphasis">DROP INDEX</span>, <span class="emphasis">TRUNCATE TABLE</span> et <span class="emphasis">UPDATE STATISTICS</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>SQL Server permet   la r&eacute;solution des noms diff&eacute;r&eacute;e. La proc&eacute;dure stock&eacute;e peut donc &ecirc;tre compil&eacute;e sans erreur, m&ecirc;me si elle fait r&eacute;f&eacute;rence &agrave; un objet qui n'a pas encore &eacute;t&eacute; cr&eacute;&eacute;. Un plan d'ex&eacute;cution est &eacute;tabli, qui n'&eacute;chouera qu'au moment de l'ex&eacute;cution si l'objet n'existe toujours pas. </p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans SQL Server, il est facile d'imbriquer des proc&eacute;dures stock&eacute;es. Lorsqu'une proc&eacute;dure stock&eacute;e invoque une autre proc&eacute;dure stock&eacute;e, la variable syst&egrave;me <span class="emphasis">@@NESTLEVEL</span> est augment&eacute;e de 1. Elle est diminu&eacute;e de 1 quand la procedure ainsi invoqu&eacute;e est achev&eacute;e. On sp&eacute;cifie <span class="emphasis">SELECT @@NESTLEVEL</span> pour conna&icirc;tre le nombre de niveaux d'imbrication dans la session en cours.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [OR REPLACE] PROCEDURE [owner_name.]procedure_name[(parameter1 [IN | OUT | IN OUT] [NOCOPY] datatype][,...n)]][AUTHID {CURRENT_USER | DEFINER} ]{IS | AS} {PL/SQL block | LANGUAGE {java_spec | C_spec}};</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Oracle,  les proc&eacute;dures stock&eacute;es sont tout &agrave; fait similaires aux fonctions utilisateur par la composition et la structure. La diff&eacute;rence essentielle est que les proc&eacute;dures stock&eacute;es ne peuvent pas renvoyer de valeurs au processus d'invocation, tandis que les fonctions peuvent renvoyer une valeur unique.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans une proc&eacute;dure stock&eacute;e Oracle, les arguments et param&egrave;tres sp&eacute;cifi&eacute;s incluent <span class="emphasis">IN</span>, <span class="emphasis">OUT</span> ou <span class="emphasis">IN OUT</span>. Le qualificateur <span class="emphasis">IN</span> est fourni lorsque la fonction est invoqu&eacute;e et il envoie une valeur &agrave; la fonction, tandis que l'argument <span class="emphasis">OUT</span> renvoie une valeur au processus d'invocation. En d'autres termes, le qualificateur <span class="emphasis">IN</span> est fourni par l'utilisateur ou le processus qui appelle la fonction, tandis que l'argument <span class="emphasis">OUT</span> est renvoy&eacute; par la fonction. Les arguments <span class="emphasis">IN OUT</span> ex&eacute;cutent aussi bien les fonctionnalit&eacute;s de <span class="emphasis">IN</span> que de <span class="emphasis">OUT</span>. Le mot-cl&eacute; <span class="emphasis">NOCOPY</span> est utile pour acc&eacute;l&eacute;rer la performance quand un argument  <span class="emphasis">OUT</span> ou <span class="emphasis">IN OUT</span> est tr&egrave;s volumineux, comme c'est le cas pour les donn&eacute;es de type varray ou enregistrement.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il est aussi possible d'obliger la fonction &agrave; s'ex&eacute;cuter soit dans le contexte de permission de l'utilisateur actif avec l'expression <span class="emphasis">AUTHID CURRENT_USER</span>, soit dans celui du propri&eacute;taire de la fonction avec l'expression <span class="emphasis">AUTHID DEFINER</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet aussi &agrave; une  proc&eacute;dure d'appeler des programmes externes via le mot-cl&eacute; <span class="emphasis">LANGUAGE</span>. Ces programmes externes doivent &ecirc;tre &eacute;crits en C ou en Java. La syntaxe sp&eacute;cifique pour ce type d'appels d&eacute;passe le cadre de cet ouvrage. Reportez-vous &agrave; la documentation de l'&eacute;diteur pour plus de renseignements sur cette fonctionnalit&eacute;.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Microsoft SQL Server, les proc&eacute;dures stock&eacute;es <span class="emphasis">peuvent</span> &ecirc;tre utilis&eacute;es pour renvoyer des jeux de resultats, tandis que les proc&eacute;dures stock&eacute;es d'Oracle <span class="emphasis">ne peuvent pas</span> renvoyer des jeux de r&eacute;sultats au processus d'appel.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette proc&eacute;dure stock&eacute;e Microsoft SQL Server g&eacute;n&egrave;re une valeur unique de 22 chiffres (bas&eacute;e sur la date et l'heure du syst&egrave;me) et la renvoie au processus d'appel:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>-- Une proc&eacute;dure stock&eacute;e Microsoft SQL ServerCREATE PROCEDURE get_next_nbr  @next_nbr CHAR(22) OUTPUTASBEGIN DECLARE @random_nbr INT SELECT @random_nbr = RAND( ) * 1000000SELECT @next_nbr = RIGHT('000000'+ CAST(ROUND(RAND(@random_nbr)*1000000,0))AS CHAR(6), 6) + RIGHT('0000'+ CAST(DATEPART (yy, GETDATE( ) ) AS CHAR(4)), 2) + RIGHT('000'+ CAST(DATEPART (dy, GETDATE( ) ) AS CHAR(3)), 3) + RIGHT('00' + CAST(DATEPART (hh, GETDATE( ) ) AS CHAR(2)), 2) + RIGHT('00' + CAST(DATEPART (mi, GETDATE( ) ) AS CHAR(2)), 2) + RIGHT('00' + CAST(DATEPART (ss, GETDATE( ) ) AS CHAR(2)), 2) + RIGHT('000'+ CAST(DATEPART (ms, GETDATE( ) ) AS CHAR(3)), 3)ENDGO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CREATE ROLE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CREATE ROLE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p><span class="emphasis">CREATE ROLE</span>    permet la cr&eacute;ation d'un ensemble de privil&egrave;ges auquel on peut attribuer un nom, et assigner les utilisateurs de la base de donn&eacute;es. Lorsqu'on attribue un r&ocirc;le &agrave; un utilisateur, il obtient tous les privil&egrave;ges et les permissions li&eacute;s &agrave; ce r&ocirc;le.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Non prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server ne prend pas en charge la commande <span class="emphasis">CREATE ROLE</span>, mais offre une fonctionnalit&eacute; &eacute;quivalente via la proc&eacute;dure syst&egrave;me stock&eacute;e <span class="emphasis">sp_add_role</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE ROLE role_name [WITH ADMIN {CURRENT_USER | CURRENT_ROLE}]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'instruction ci-dessous cr&eacute;e un nouveau r&ocirc;le et le diff&eacute;rencie d'un  utilisateur de SGBD h&ocirc;te. La clause <span class="emphasis">WITH ADMIN</span> attribue instantan&eacute;ment un r&ocirc;le &agrave; l'utilisateur ou au r&ocirc;le actif. La configuration par d&eacute;faut de l'instruction est <span class="emphasis">WITH ADMIN CURRENT_USER</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE ROLE role_name [NOT IDENTIFIED | IDENTIFIED  {BY password | EXTERNALLY | GLOBALLY}]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Oracle, on commence par cr&eacute;er un r&ocirc;le, puis on lui attribue des privil&egrave;ges et permissions comme s'il s'agissait d'un utilisateur, via la commande <span class="emphasis">GRANT</span>. Quand les utilisateurs veulent acc&eacute;der aux permissions d'un r&ocirc;le prot&eacute;g&eacute; par un mot de passe, ils saisissent la commande <span class="emphasis">SET ROLE</span>. Lorsqu'un r&ocirc;le est dot&eacute; d'un mot de passe, tout utilisateur qui souhaite y acc&eacute;der doit fournir le mot de passe avec la commande <span class="emphasis">SET ROLE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle est livr&eacute; avec plusieurs r&ocirc;les pr&eacute;configur&eacute;s.  <span class="emphasis">CONNECT</span>, <span class="emphasis">DBA</span> et <span class="emphasis">RESOURCE</span> sont disponibles dans toutes les versions d'Oracle.  <span class="emphasis">EXP_FULL_DATABASE</span> et <span class="emphasis">IMP_FULL_DATABASE</span> sont des r&ocirc;les plus r&eacute;cents, utilis&eacute;s pour les op&eacute;rations d'importation et d'exportation.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'exemple suivant fait appel &agrave; <span class="emphasis">CREATE</span> pour sp&eacute;cifier un nouveau r&ocirc;le dans Oracle, lui attribuer des privil&egrave;ges avec <span class="emphasis">GRANT</span>, le prot&eacute;ger d'un mot de passe avec <span class="emphasis">ALTER ROLE</span>, et y assigner quelques utilisateurs, &agrave; nouveau avec <span class="emphasis">GRANT</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE ROLE boss;GRANT ALL ON employee TO boss;GRANT CREATE SESSION, CREATE DATABASE LINK TO boss;ALTER ROLE boss IDENTIFIED BY le_grande_fromage;GRANT boss TO nancy, dale;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CREATE SCHEMA">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CREATE SCHEMA</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p> <span class="emphasis"></span>  Cette instruction cr&eacute;e un <span class="emphasis">schema</span> &8212; c.&agrave;.d., un groupe d'objets associ&eacute;s auquel on attribue un nom. Un sch&eacute;ma consiste en un assortiment de tables et de vues accompagn&eacute;es de leurs permissions. Le sch&eacute;ma est associ&eacute; &agrave; un identifiant utilisateur valide existant (appel&eacute; le <span class="emphasis">propri&eacute;taire</span>).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE SCHEMA [schema_name] [AUTHORIZATION owner_name][DEFAULT CHARACTER SET char_set_name][PATH schema_name [,...n] ]  [ &lt;create_table_statement1&gt; [...n] ]  [ &lt;create_view_statement1&gt; [...n] ]  [ &lt;grant statement1&gt; [...n] ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">CREATE SCHEMA</span> agit comme un conteneur qui peut englober de nombreuses autres instructions <span class="emphasis">CREATE</span> et <span class="emphasis">GRANT</span>. Accessoirement, <span class="emphasis">DEFAULT CHARACTER SET</span> attribue un nom au jeu de caract&egrave;res par d&eacute;faut du sch&eacute;ma. Le chemin d'acc&egrave;s, <span class="emphasis">PATH</span>, peut aussi &ecirc;tre d&eacute;clar&eacute; pour tout objet du sch&eacute;ma qui r&eacute;side sur le syst&egrave;me de fichiers.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe Microsoft SQL Server et Oracle </span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE SCHEMA AUTHORIZATION owner_name  [ &lt;create_table_statement1&gt; [...n] ]  [ &lt;create_view_statement1&gt; [...n] ]  [ &lt;grant statement1&gt; [...n] ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Si une instruction quelconque comprise dans l'instruction <span class="emphasis">CREATE SCHEMA</span> &eacute;choue, l'instruction toute enti&egrave;re &eacute;choue avec elle. L'avantage de <span class="emphasis">CREATE SCHEMA</span> tient &agrave; ce que les objets qu'il englobe ne doivent pas n&eacute;cessairement &ecirc;tre organis&eacute;s selon un ordre de d&eacute;pendance particulier. Par exemple, il est normalement impossible d'&eacute;mettre une instruction <span class="emphasis">GRANT</span> pour une table qui n'existe pas encore. Toutefois, on peut commencer par placer toutes les instructions <span class="emphasis">GRANT</span> dans l'instruction <span class="emphasis">CREATE SCHEMA</span>, suivies des instructions <span class="emphasis">CREATE</span> auxquelles les premi&egrave;res sont attribu&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>De nombreuses impl&eacute;mentations ne reconnaissent pas explicitement la commande <span class="emphasis">CREATE SCHEMA</span>. Cependant, elles cr&eacute;ent implicitement un sch&eacute;ma quand un utilisateur cr&eacute;e des objets de base de donn&eacute;es. Oracle, quant &agrave; lui, cr&eacute;e un sch&eacute;ma chaque fois qu'un utilisateur est cr&eacute;&eacute;. La commande <span class="emphasis">CREATE SCHEMA</span> constitue simplement une m&eacute;thode rapide pour cr&eacute;er en une seule &eacute;tape l'ensemble des tables, vues et autres objets de base de donn&eacute;es, ainsi que leurs permissions en une seule &eacute;tape.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Oracle, <span class="emphasis">CREATE</span> <span class="emphasis">SCHEMA</span> ne cr&eacute;e pas un sch&eacute;ma &8212; seul <span class="emphasis">CREATE USER</span> a cette fonctionnalit&eacute;.  <span class="emphasis">CREATE SCHEMA</span> permet &agrave; un utilisateur d'accomplir plusieurs &eacute;tapes avec une instruction SQL unique. L'exemple ci-dessous, tir&eacute; d'Oracle, place les permissions avant les objets dans l'instruction <span class="emphasis">CREATE SCHEMA</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE SCHEMA AUTHORIZATION emily  GRANT SELECT, INSERT ON view_1 TO sarah  GRANT ALL ON table_1 TO sarah  CREATE VIEW view_1 AS   SELECT column_1, column_2   FROM table_1   ORDER BY column_2  CREATE TABLE table_1(column_1 INT, column_2 CHAR(20));</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CREATE TABLE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CREATE TABLE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">CREATE TABLE</span>  , comme son nom l'indique, sert &agrave; cr&eacute;er une table. Toutefois, la plupart des &eacute;diteurs incluent toute une s&eacute;rie d'autres fonctions avec <span class="emphasis">CREATE TABLE</span>, comme la d&eacute;signation de touches, l'int&eacute;grit&eacute; r&eacute;f&eacute;rentielle en cascade, ou la d&eacute;finition de contraintes et de valeurs par d&eacute;faut.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette commande d&eacute;finit le nom d'une table, les colonnes qui la constituent, et les propri&eacute;t&eacute;s des colonnes ou de la table. Habituellement, la conception et la cr&eacute;ation d'une table font l'objet d'une r&eacute;flexion approfondie dans le cadre d'une discipline appel&eacute;e <span class="emphasis">conception de bases de donn&eacute;es</span> . La discipline qui consiste &agrave; analyser les relations d'une table &agrave; ses donn&eacute;es et aux autres tables de la base de donn&eacute;es est appel&eacute;e <span class="emphasis">normalisation</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il est fortement recommand&eacute; aux programmeurs et aux d&eacute;veloppeurs de se livrer &agrave; une &eacute;tude approfondie des principes qui gouvernent la conception de bases de donn&eacute;es et la normalisation avant de se lancer dans une commande <span class="emphasis">CREATE TABLE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>En g&eacute;n&eacute;ral, le nom d'une table commence par un caract&egrave;re alphab&eacute;tique. La longueur permise varie selon les &eacute;diteurs;  Oracle n'autorise que 30 caract&egrave;res, mais il est possible d'en utiliser bien plus si n&eacute;cessaire. On peut inclure des chiffres dans le nom d'une table, mais il est pr&eacute;f&eacute;rable de ne pas utiliser d'autre symbole que le  trait de soulignement (_). Certains &eacute;diteurs permettent de nombreux autres symboles, mais il vaut mieux les &eacute;viter car ils tendent &agrave; engendrer la confusion dans les identifiants.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour la d&eacute;finition des caract&eacute;ristiques de colonne, tous les &eacute;diteurs reconnaissent les options <span class="emphasis">NULL</span>  et <span class="emphasis">NOT NULL</span> (une valeur <span class="emphasis">NULL</span> simple n'est pas requise dans SQL99). Lorsqu'une colonne est d&eacute;finie comme <span class="emphasis">NULL</span>, cette colonne peut contenir des valeurs nulles, quel que soit son type de donn&eacute;es. Les colonnes autorisant les valeurs nulles consomment un peu plus d'espace pour chaque enregistrement. Si la clause <span class="emphasis">NOT NULL</span> est sp&eacute;cifi&eacute;e, la colonne ne peut sous aucune circonstance contenir de valeurs nulles. Toute op&eacute;ration <span class="emphasis">INSERT</span> ou <span class="emphasis">UPDATE</span> sur une colonne <span class="emphasis">NOT NULL</span> qui tente soit d'introduire une valeur nulle, soit de changer une valeur existante en valeur nulle, &eacute;choue et est automatiquement annul&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Tous les &eacute;diteurs reconnaissent aussi la d&eacute;claration <span class="emphasis">PRIMARY KEY</span> au niveau de la colonne comme de la table. La <span class="emphasis">cl&eacute; primaire</span> est une d&eacute;signation particuli&egrave;re qui permet d'identifier chaque ligne d'une table de mani&egrave;re unique. Elle consiste en une colonne ou une combinaison de colonnes qui fournissent &agrave; chaque ligne de la table son identit&eacute; propre. Une table ne peut avoir qu'une seul cl&eacute; primaire. Toutes les valeurs de la cl&eacute; primaire doivent &ecirc;tre uniques, et aucune ne peut &ecirc;tre nulle. Il est alors possible de d&eacute;clarer des cl&eacute;s &eacute;trang&egrave;res, qui &eacute;tablissent une relation directe avec la cl&eacute; primaire d'une autre table. Ceci permet de cr&eacute;er des relations parent/enfant ou table master/table d&eacute;taill&eacute;e entre les tables. Une action en cascade peut augmenter cette action. Par exemple, un utilisateur peut souhaiter emp&ecirc;cher que l&acute;enregistrement d'un client soit effac&eacute; de la table <span class="emphasis">customer</span> s'il existe des enregistrements pour ce client dans la table <span class="emphasis">sales</span>. La syntaxe des cl&eacute;s &eacute;trang&egrave;res varie selon l'&eacute;diteur.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La plupart des &eacute;diteurs reconnaissent aussi l'attribution d'une valeur  par d&eacute;faut <span class="emphasis">DEFAULT</span> pour une colonne donn&eacute;e. Si un enregistrement est cr&eacute;&eacute; sans qu'aucune valeur soit fournie pour la colonne en question, sa valeur par d&eacute;faut est automatiquement ins&eacute;r&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La syntaxe de base pour l'instruction <span class="emphasis">CREATE TABLE</span> est montr&eacute;e ci-dessous; ceci est suffisant pour commencer &agrave; cr&eacute;er des tables et &agrave; les remplir de donn&eacute;es:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TABLE table_name  (  column_name datatype[(length)] [NULL | NOT NULL],...n  )</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Voici un exemple simple:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TABLE housing_construction  (project_number   INT NOT NULL,  project_date     DATETIME NOT NULL,  project_name     VARCHAR(50) NOT NULL,  construction_color  NCHAR(20) NULL,  construction_height DECIMAL(4,1) NULL,  construction_length DECIMAL(4,1) NULL,  construction_width  DECIMAL(4,1) NULL,  construction_volume INT NULL)GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Microsoft SQL Server, cette instruction d&eacute;finit une table appel&eacute;e <span class="emphasis">housing_construction</span> qui comprend huit colonnes. Chaque colonne est d&eacute;finie soit comme <span class="emphasis">NULL</span>,soit comme <span class="emphasis">NOT NULL</span>, avec le type de donn&eacute;es correspondant au type d'information qu'elle contient. A noter: la liste des d&eacute;finitions de colonnes appara&icirc;t toujours entre parenth&egrave;ses et une virgule termine chaque d&eacute;finition de colonne lorsqu'elle est suivie d'une autre d&eacute;finition.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [GLOBAL TEMPORARY | LOCAL TEMPORARY] TABLE table_name[ON COMMIT {PRESERVE ROWS | DELETE ROWS}(column_name datatype attributes [,...n] | [LIKE table_name] | [table_constraint][,...n] ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">CREATE TABLE</span> SQL99 cr&eacute;e des tables temporaires <span class="emphasis">TEMPORARY</span>  qui sont instanci&eacute;es quand la table est cr&eacute;&eacute;e et automatiquement &eacute;limin&eacute;es quand la session d'utilisateur en cours se termine. Une table temporaire peut &ecirc;tre <span class="emphasis">GLOBAL</span>, et donc accessible par tous les utilisateurs ayant des sessions en cours, ou <span class="emphasis">LOCAL</span>, et donc accessible uniquement par l'utilisateur qui l'a cr&eacute;&eacute;e. Il est &eacute;galement possible de pr&eacute;ciser une valeur <span class="emphasis">ON COMMIT</span> pour une table temporaire. <span class="emphasis">ON COMMIT PRESERVE ROWS</span> pr&eacute;serve toutes les modifications apport&eacute;es aux donn&eacute;es de la table temporaire lors de l'op&eacute;ration de validation <span class="emphasis">COMMIT</span>, tandis que <span class="emphasis">ON COMMIT DELETE ROWS</span> efface la table apr&egrave;s le <span class="emphasis">COMMIT</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'option <span class="emphasis">LIKE table_name</span> cr&eacute;e une nouvelle table avec les m&ecirc;mes d&eacute;finitions de colonnes et les m&ecirc;mes contraintes qu'une table d&eacute;j&agrave; existante. Lorsque <span class="emphasis">LIKE</span> est utilis&eacute;, il n'est pas n&eacute;cessaire de d&eacute;finir les contraintes de table ou de colonnes.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Parce que <span class="emphasis">CREATE TABLE</span> est une commande d'importance capitale, et parce que son impl&eacute;mentation varie consid&eacute;rablement d'un &eacute;diteur &agrave; l'autre, elle est d&eacute;crite s&eacute;par&eacute;ment et en d&eacute;tail pour chaque SGBD.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TABLE [<span class="replaceable">database_name</span>.[<span class="replaceable">owner</span>]. | <span class="replaceable">owner</span>.] <span class="replaceable">table_name</span>({column_name datatype [ [DEFAULT default_value]  | {IDENTITY [(seed,increment) [NOT FOR REPLICATION]]]  [ROWGIDCOL] ]  [NULL | NOT NULL]  | [{PRIMARY KEY | UNIQUE}    [CLUSTERED | NONCLUSTERED]    [WITH FILLFACTOR = int] [ON {filegroup | DEFAULT}] ]  | [[FOREIGN KEY]    REFERENCES reference_table[<span class="emphasis">(</span>reference_column[,...n])]    [ON DELETE {CASCADE | NO ACTION}]    [ON UPDATE {CASCADE | NO ACTION}]    [NOT FOR REPLICATION]  | [CHECK [NOT FOR REPLICATION] (expression)  | [COLLATE collation_name]|column_name AS computed_column_expression[,...n]|[table_constraint][,...n] )[ON {filegroup | DEFAULT} ][TEXTIMAGE_ON {filegroup | DEFAULT} ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>SQL Server offre quantit&eacute; d'options pour la d&eacute;finition d'une table, de ses colonnes, et de ses contraintes de table. Il permet entre autres d'attribuer un nom aux contraintes de colonnes en sp&eacute;cifiant <span class="emphasis">CONSTRAINT constraint_name</span>.. ., suivi du texte de la contrainte. Il est possible d'appliquer plusieurs contraintes &agrave; une m&ecirc;me colonne, &agrave; condition qu'elles ne soient pas mutuellement exclusives (comme c'est le cas par exemple pour <span class="emphasis">PRIMARY KEY</span> et <span class="emphasis">NULL</span> ).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>SQL Server permet aussi de cr&eacute;er une <span class="emphasis"></span>table temporaire stock&eacute;e dans la base de donn&eacute;es <span class="emphasis">tempdb</span> en pr&eacute;c&eacute;dant le nom de la table d'un   di&egrave;se (#) unique. La table temporaire locale peut &ecirc;tre utilis&eacute;e par la personne ou par le processus qui l'a cr&eacute;&eacute;e. Elle est automatiquement effac&eacute;e quand la personne ferme sa session ou quand le processus s'ach&egrave;ve. Une    table temporaire globale utilisable par toutes les personnes et tous les processus qui ont des sessions ouvertes peut &ecirc;tre &eacute;tablie en pr&eacute;c&eacute;dant le nom de la table de deux di&egrave;ses (##). La table temporaire globale est effac&eacute;e lorsque son processus s'ach&egrave;ve ou que son cr&eacute;ateur ferme sa session.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Comme SQL Server admet la r&eacute;plication int&eacute;gr&eacute;e, de nombreuses propri&eacute;t&eacute;s d'une colonne peuvent &ecirc;tre configur&eacute;es sur <span class="emphasis">NOT FOR REPLICATION</span>, ce qui signifie que les valeurs d'une colonne <span class="emphasis">IDENTITY</span> ou d'une cl&eacute; &eacute;trang&egrave;re (<span class="emphasis">FOREIGN KEY</span>) ne seront pas r&eacute;pliqu&eacute;es sur les serveurs abonn&eacute;s. Ceci est utile dans les situations o&ugrave; diff&eacute;rents serveurs utilisent les m&ecirc;mes structures de table, mais pas les m&ecirc;mes donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p> <span class="emphasis">ROWGUIDCOL</span> est &eacute;galement utile en cas de r&eacute;plication. Ceci d&eacute;signe une colonne comme identificateur global unique, ce qui permet d'assurer que deux valeurs ne peuvent en aucun cas &ecirc;tre r&eacute;p&eacute;t&eacute;es quel que soit le nombre de serveurs. Il ne peut y avoir qu'une seule colonne de ce type par table. Toutefois, les valeurs uniques ne sont pas automatiquement cr&eacute;&eacute;es. Elles doivent &ecirc;tre ins&eacute;r&eacute;es &agrave; l'aide de la fonction <span class="emphasis">NEWID</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La propri&eacute;t&eacute; <span class="emphasis">IDENTITY</span>, appliqu&eacute;e &agrave; une colonne de nombre entiers, est similaire &agrave; <span class="emphasis">AUTO_INCREMENT</span> dans MySQL: elle cr&eacute;e et remplit automatiquement la colonne d'un nombre qui s'accro&icirc;t de fa&ccedil;on monotone. Elle est cependant plus souple. Alors qu'<span class="emphasis">AUTO_INCREMENT</span> d&eacute;marre toujours &agrave; 1, <span class="emphasis">IDENTITY</span> commence &agrave; compter &agrave; partir de la valeur <span class="emphasis">seed</span> fix&eacute;e au d&eacute;part. Et alors qu'<span class="emphasis">AUTO_INCREMENT</span> augmente de 1 &agrave; chaque nouvel enregistrement, <span class="emphasis">IDENTITY</span> augmente de la valeur incr&eacute;mentale d&eacute;finie dans <span class="emphasis">increment</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans SQL Server, <span class="emphasis">DEFAULT</span> peut s'appliquer &agrave; n'importe quelle colonne, &agrave; l'exception de celles dont le type de donn&eacute;es est une r&eacute;f&eacute;rence temporelle ou qui sont dot&eacute;es d'une propri&eacute;t&eacute; <span class="emphasis">IDENTITY</span>. <span class="emphasis">DEFAULT</span> doit &ecirc;tre &agrave; la fois une valeur constante (par exemple, une cha&icirc;ne de caract&egrave;res, ou un nombre donn&eacute;) et une fonction syst&egrave;me (comme <span class="emphasis">GETDATE( )</span> ou <span class="emphasis">NULL</span>).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour chaque table, une cl&eacute; <span class="emphasis">PRIMARY KEY</span> appel&eacute;e nom par table, ainsi que plusieurs colonnes <span class="emphasis">UNIQUE</span> ou plusieurs cl&eacute;s <span class="emphasis">FOREIGN KEY</span> peuvent &eacute;galement &ecirc;tre sp&eacute;cifi&eacute;es. Elles peuvent &ecirc;tre clusteris&eacute;es ou non, et d&eacute;finies avec un facteur de remplissage de d&eacute;part. Reportez-vous &agrave; la section concernant <span class="emphasis">CREATE INDEX</span> pour plus de d&eacute;tails.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Lorsqu'une <span class="emphasis">FOREIGN KEY</span> est sp&eacute;cifi&eacute;e, la table et les colonnes charg&eacute;es de conserver l'int&eacute;grit&eacute; r&eacute;f&eacute;rentielles peuvent &ecirc;tre d&eacute;sign&eacute;es via la clause <span class="emphasis">REFERENCES</span>. Cette clause ne peut faire r&eacute;f&eacute;rence qu'&agrave; des colonnes qui ont &eacute;t&eacute; d&eacute;finies comme <span class="emphasis">PRIMARY KEY</span> ou index <span class="emphasis">UNIQUE</span> sur la table r&eacute;f&eacute;ren&ccedil;ante. Il est possible de d&eacute;finir une action r&eacute;f&eacute;rentielle qui doit s'ex&eacute;cuter sur la <span class="emphasis">reference_table</span> quand un enregistrement est effac&eacute; ou mis &agrave; jour. Si la clause <span class="emphasis">NO ACTION</span> est sp&eacute;cifi&eacute;e, alors la table r&eacute;f&eacute;renc&eacute;e ne fait l'objet d'aucune action quand un enregistrement est effac&eacute; ou mis &agrave; jour. Si la clause <span class="emphasis">CASCADE</span> est sp&eacute;cifi&eacute;e, alors l'op&eacute;ration d'effacement ou de mise &agrave; jour s'applique aussi &agrave; tout enregistrement de la table r&eacute;f&eacute;renc&eacute;e qui d&eacute;pend de la valeur de la cl&eacute; <span class="emphasis">FOREIGN KEY</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La contrainte <span class="emphasis">CHECK</span> permet de s'assurer qu'une valeur saisie dans la colonne sp&eacute;cifi&eacute;e de la table constitue une valeur possible selon l'expression <span class="emphasis">CHECK</span>. Cet exemple montre une table comportant plusieurs contraintes de colonne:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TABLE people  (people_id   CHAR(4)    CONSTRAINT pk_dist_id PRIMARY KEY CLUSTERED    CONSTRAINT ck_dist_id CHECK (dist_id LIKE '[A-Z][A-Z][A-Z][A-Z]'),   people_name  VARCHAR(40) NULL,   people_addr1 VARCHAR(40) NULL,   people_addr2 VARCHAR(40) NULL,   city     VARCHAR(20) NULL,   state     CHAR(2)   NULL    CONSTRAINT def_st DEFAULT ("CA")    CONSTRAINT chk_st REFERENCES states(state_ID),   zip      CHAR(5)   NULL    CONSTRAINT ck_dist_zip    CHECK(zip LIKE '[0-9][0-9][0-9][0-9][0-9]'),   phone     CHAR(12)  NULL,   sales_rep   empid    NOT NULL DEFAULT USER)GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La contrainte <span class="emphasis">CHECK</span> plac&eacute;e sur la colonne <span class="emphasis">people_id</span> permet de s'assurer qu'elle ne contiendra que des valeurs alphab&eacute;tiques, tandis que celle plac&eacute;e sur la colonne <span class="emphasis">zip</span> garantit des valeurs enti&egrave;rement num&eacute;riques. La contrainte <span class="emphasis">REFERENCES</span> sur la colonne <span class="emphasis">state</span> consulte la table <span class="emphasis">states</span>. La contrainte <span class="emphasis">REFERENCES</span> est pratiquement identique &agrave; la contrainte <span class="emphasis">CHECK</span>, hormis le fait qu'elle obtient sa liste de valeurs possibles parmi les valeurs stock&eacute;es dans une autre colonne. Cet exemple illustre bien la fa&ccedil;on dont on attribue des noms aux contraintes de colonne, via la syntaxe <span class="emphasis">CONSTRAINT constraint_name</span><span class="emphasis"></span><span class="emphasis"></span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La propri&eacute;t&eacute; de colonne <span class="emphasis">COLLATE</span> est &eacute;galement une nouveaut&eacute; dans SQL Server 2000. Elle permet aux programmeurs de modifier, colonne par colonne, l'ordre de tri et le jeu de caract&egrave;res utilis&eacute;s par la colonne. Comme il s'agit d'une technique complexe, reportez-vous &agrave; la documentation de l'&eacute;diteur pour plus de d&eacute;tails. La section consacr&eacute;e &agrave; <span class="emphasis">CREATE FUNCTION</span> contient un exemple de la syntaxe &agrave; employer.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>SQL Server permet &eacute;galement la cr&eacute;ation de tables dot&eacute;es de colonnes qui contiennent une valeur calcul&eacute;e. Ces colonnes ne contiennent pas r&eacute;ellement de donn&eacute;es. En fait, il s'agit de colonnes virtuelles qui contiennent une expression qui utilise d'autres colonnes d&eacute;j&agrave; pr&eacute;sentes dans la table. Par exemple, une colonne calcul&eacute;e peut avoir une expression du type <span class="emphasis">order_cost AS (price</span> <span class="emphasis">*</span> <span class="emphasis">qty)</span>. Le contenu d'une colonne calcul&eacute;e peut aussi consister en une constante, une fonction, une variable, une colonne non-calcul&eacute;e, ou n'importe lesquelles de ces possibilit&eacute;s combin&eacute;es entre elles avec des op&eacute;rateurs.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Toutes les contraintes de colonne d&eacute;crites ci-dessus peuvent &eacute;galement &ecirc;tre d&eacute;clar&eacute;es au niveau de la table. C'est &agrave; dire que les contraintes <span class="emphasis">PRIMARY KEY</span>, <span class="emphasis">FOREIGN KEY</span>, <span class="emphasis">CHECK</span>, ou autres peuvent &ecirc;tre d&eacute;clar&eacute;es lorsque toutes les colonnes ont &eacute;t&eacute; d&eacute;finies dans l'instruction <span class="emphasis">CREATE TABLE</span>. Ceci est tr&egrave;s utile pour les contraintes qui couvrent plus d'une colonne. Par exemple, quand une contrainte de colonne <span class="emphasis">UNIQUE</span> est d&eacute;clar&eacute;e, elle ne peut &ecirc;tre appliqu&eacute;e qu'&agrave; la colonne pour laquelle elle a &eacute;t&eacute; cr&eacute;&eacute;e. Si, en revanche, la contrainte est d&eacute;clar&eacute;e au niveau de la colonne, elle peut s'appliquer &agrave; plusieurs colonnes. Voici un exemple de contraintes de colonne et de table:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>-- Cr&eacute;ation d'une contrainte de colonneCREATE TABLE favorite_books  (isbn     CHAR(100)  PRIMARY KEY NONCLUSTERED,   book_name   VARCHAR(40) UNIQUE,   category   VARCHAR(40) NULL,   subcategory  VARCHAR(40) NULL,   pub_date   DATETIME   NOT NULL,   purchase_date DATETIME   NOT NULL)GO-- Cr&eacute;ation d'une contrainte de tableCREATE TABLE favorite_books  (isbn     CHAR(100)  NOT NULL,   book_name   VARCHAR(40) NOT NULL,   category   VARCHAR(40) NULL,   subcategory  VARCHAR(40) NULL,   pub_date   DATETIME   NOT NULL,   purchase_date DATETIME   NOT NULL,    CONSTRAINT pk_book_id  PRIMARY KEY NONCLUSTERED (isbn)      WITH FILLFACTOR=70,    CONSTRAINT unq_book   UNIQUE CLUSTERED (book_name,pub_date))GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Ces deux commandes donnent des r&eacute;sultats pratiquement identiques, la seule diff&eacute;rence &eacute;tant que la contrainte de table <span class="emphasis">UNIQUE</span> englobe deux colonnes, tandis que la contrainte de colonne <span class="emphasis">UNIQUE</span> ne concerne qu'une seule colonne.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Enfin, Microsoft SQL Server dispose de deux clauses distinctes qui permettent de contr&ocirc;ler le placement physique de la table (ou de la cl&eacute; primaire, ou des index uniques):  <span class="emphasis">[ON {filegroup | DEFAULT}]</span> et <span class="emphasis">[TEXTIMAGE_ON {filegroup | DEFAULT}]</span>. La clause <span class="emphasis">ON filegroup</span> stocke la table ou l'index dans le groupe de fichiers d&eacute;sign&eacute; &agrave; condition qu'il soit situ&eacute; dans la base de donn&eacute;es. Si <span class="emphasis">ON DEFAULT</span> est sp&eacute;cifi&eacute; ou si la clause <span class="emphasis">ON</span> n'est pas utilis&eacute;e, la table ou l'index sont stock&eacute;s dans le groupe de fichiers par d&eacute;faut de la base de donn&eacute;es. La clause <span class="emphasis">TEXTIMAGE</span> fonctionne &agrave; peu pr&egrave;s de la m&ecirc;me fa&ccedil;on, sauf qu'elle contr&ocirc;le le placement des colonnes de type <span class="emphasis">text</span>, <span class="emphasis">ntext</span>, et <span class="emphasis">image</span>. Ces colonnes sont normalement stock&eacute;es dans le groupe de fichiers par d&eacute;faut avec le reste des tables et des objets de base de donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans MySQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [TEMPORARY] TABLE [IF NOT EXISTS] table_name<span class="emphasis">(</span>column_name datatype [NULL | NOT NULL] [DEFAULT default_value]  [AUTO_INCREMENT]  [PRIMARY KEY] [reference_definition] |  [CHECK (expression) |  [INDEX [index_name] index_col_name1[(length)],...n)] |  [UNIQUE [INDEX] [index_name] (index_col_name1,...n)] |  [CONSTRAINT symbol] FOREIGN KEY index_name (index_col_name1,...n)   [REFERENCES table_name [(index_col_name,...)]   [MATCH FULL | MATCH PARTIAL]   [ON DELETE {RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT}]   [ON UPDATE {RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT}]){[TYPE = {ISAM | MYISAM | HEAP} |  AUTO_INCREMENT = int |  AVG_ROW_LENGTH = int |  CHECKSUM = {0 | 1} |  COMMENT = "string" |  DELAY_KEY_WRITE = {0 | 1} |  MAX_ROWS = int |  MIN_ROWS = int |  PACK_KEYS = {0 | 1} |  PASSWORD = "string" |  ROW_FORMAT= { default | dynamic | static | compressed }] }[[IGNORE | REPLACE] SELECT_statement]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>MySQL dispose de nombreuses options pour la cr&eacute;ation de tables. L'option <span class="emphasis">TEMPORARY</span> cr&eacute;e une table qui existe pendant la dur&eacute;e de la session au cours de laquelle elle a &eacute;t&eacute; cr&eacute;&eacute;e. Une fois que la connexion est ferm&eacute;e, la table temporaire est automatiquement effac&eacute;e. L'option <span class="emphasis">IF NOT EXISTS</span> emp&ecirc;che toute erreur possible au cas o&ugrave; la table existerait d&eacute;j&agrave;.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Quand une table est cr&eacute;&eacute;e dans MySQL, trois fichiers sont automatiquement cr&eacute;&eacute;s dans le syst&egrave;me d'exploitation: une d&eacute;finition de table portant l'extension <span class="emphasis">.frm</span>, un fichier de donn&eacute;es avec l'extension <span class="emphasis">.myd</span>, et un fichier index avec l'extension <span class="emphasis">.myi</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">AUTO_INCREMENT</span> d&eacute;finit une colonne de nombres entiers qui augmentent automatiquement de 1 (avec 1 pour valeur de d&eacute;part). MySQL ne permet qu'une seule colonne <span class="emphasis">AUTO_INCREMENT</span> par table. Quand la valeur maximale est effac&eacute;e, elle est r&eacute;utilis&eacute;e. Quand tous les enregistrements sont effac&eacute;s, les valeurs reviennent au point de d&eacute;part.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Une ou plusieurs colonnes <span class="emphasis">PRIMARY KEY</span> peuvent &ecirc;tre d&eacute;finies, &agrave; condition qu'elles soient aussi d&eacute;finies comme <span class="emphasis">NOT NULL</span>. Quand une caract&eacute;ristique <span class="emphasis">INDEX</span> est attribu&eacute;e &agrave; une colonne, il est possible d'y inclure un nom pour l'index (dans MySQL, <span class="emphasis">KEY</span> est synonyme d'<span class="emphasis">INDEX</span>). Si aucun nom n'est attribu&eacute;, MySQL en cr&eacute;e un compos&eacute; d'<span class="emphasis">index_column_name</span> suivi d'un suffixe num&eacute;rique ( _2, _3,... ) pour en garantir l'unicit&eacute;. Seules les tables de type MyISAM acceptent les index sur les colonnes <span class="emphasis">NULL</span> ou sur les colonnes de type <span class="emphasis">BLOB</span> ou <span class="emphasis">TEXT</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les clauses <span class="emphasis">FOREIGN KEY</span>, <span class="emphasis">CHECK</span> et <span class="emphasis">REFERENCES</span> sont inop&eacute;rantes. Elles n'ajoutent aucune fonctionnalit&eacute; &agrave; la table, et ne sont prises en charge que pour assurer la compatibilit&eacute; avec les autres bases de donn&eacute;es SQL.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les options de table <span class="emphasis">TYPE</span> d&eacute;terminent le mode de stockage physique des donn&eacute;es. <span class="emphasis">ISAM</span> est la d&eacute;finition de table d'origine.  <span class="emphasis">MyISAM</span> est une nouvelle structure de stockage binaire, plus portable. <span class="emphasis">HEAP</span> stocke la table dans la m&eacute;moire. Il existe d'autres options permettant d'optimiser les performances de la table:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ul><li><i> <span class="emphasis">AUTO_INCREMENT</span></i><br>&#160;						  D&eacute;finit la valeur incr&eacute;mentale automatique <span class="emphasis">auto_increment</span> pour la table (MyISAM uniquement).</li><li><i> <span class="emphasis">AVG_ROW_LENGTH</span></i><br>&#160;						  D&eacute;finit une longueur de ligne moyenne approximative pour les tables qui comprennent des enregistrements de taille variable. MySQL utilise <span class="emphasis">avg_row_length</span> * <span class="emphasis">max_rows</span> pour d&eacute;cider de la taille maximale d'une table.</li><li><i> <span class="emphasis">CHECKSUM</span></i><br>&#160;						  Configur&eacute; avec une valeur de 1, v&eacute;rifie par sommation toutes les lignes de la table (MyISAM uniquement). Ralentit le traitement, mais r&eacute;duit les risques de corruption.</li><li><i> <span class="emphasis">COMMENT</span></i><br>&#160;						  Permet d'introduire un commentaire comptant jusqu&acute;&agrave; 60 caract&egrave;res.</li><li><i> <span class="emphasis">DELAY_KEY_WRITE</span></i><br>&#160;						  Configur&eacute; avec une valeur de 1, retarde les mises &agrave; jour jusqu&acute;&agrave; la fermeture de la table (MyISAM uniquement).</li><li><i> <span class="emphasis">MAX_ROWS</span></i><br>&#160;						  D&eacute;finit un nombre maximum de lignes &agrave; stocker dans la table. Le maximum par d&eacute;faut est de 4 Go.</li><li><i> <span class="emphasis">MIN_ROWS</span></i><br>&#160;						  D&eacute;finit un nombre minimum de lignes &agrave; stocker dans la table.</li><li><i> <span class="emphasis">PACK_KEYS</span></i><br>&#160;						  Configur&eacute; avec une valeur de 1, compacte les index de la table, ce qui acc&eacute;l&egrave;re la lecture mais ralentit les mises &agrave; jour (MyISAM et ISAM uniquement). Par d&eacute;faut, les cha&icirc;nes sont seules &agrave; &ecirc;tre condens&eacute;es. Configur&eacute; avec une valeur de 1, les valeurs num&eacute;riques sont &eacute;galement condens&eacute;es.</li><li><i> <span class="emphasis">PASSWORD</span></i><br>&#160;						  Prot&egrave;ge le fichier <span class="emphasis">.frm</span> d'un mot de passe, mais pas la table.</li><li><i> <span class="emphasis">ROW_FORMAT</span></i><br>&#160;						  D&eacute;termine comment les lignes devront &ecirc;tre stock&eacute;es dans la table &agrave; l'avenir.</li></ul>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">SELECT</span>_<span class="emphasis">statement</span> cr&eacute;e une table dont les champs sont bas&eacute;s sur les &eacute;l&eacute;ments de l'instruction <span class="emphasis">SELECT</span>. Si ce n'est pas le cas, comme cela arrive dans certaines impl&eacute;mentations, alors la table peut &ecirc;tre peupl&eacute;e avec les r&eacute;sultats de l'instruction <span class="emphasis">SELECT</span>. Par exemple:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TABLE test_example (column_a INT NOT NULL AUTO_INCREMENT, PRIMARY KEY(column_a), INDEX(column_b))TYPE=HEAPSELECT column_b,column_c FROM samples;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Ceci cr&eacute;e une table heap avec trois colonnes: <span class="emphasis">column_a</span>, <span class="emphasis">column_b</span> et <span class="emphasis">column_c</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [GLOBAL TEMPORARY] TABLE [schema.]table_name( column_name datatype [DEFAULT] {column_constraint [...]} [,...n]| table_constraint [,...n] } )[ON COMMIT {DELETE | PRESERVE} ROWS]( physical_characteristics )( table_characteristics )</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Ce bloc de code para&icirc;t court et simple, mais c'est une impression trompeuse&#160;! L'impl&eacute;mentation de l'instruction <span class="emphasis">CREATE TABLE</span> dans Oracle est extr&ecirc;mement &eacute;labor&eacute;e, et pourrait m&ecirc;me &ecirc;tre qualifi&eacute;e de commande la plus complexe de tous les langages de programmation.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le code de la clause <span class="emphasis">CREATE TABLE</span> dans Oracle contient de nombreuses sous-clauses. Plut&ocirc;t que de les montrer toutes dans une seule commande, la commande est d&eacute;compos&eacute;e en sous-clauses qui &agrave; leur tour contiennent d'autres sous-clauses. La plupart des programmeurs SQL n'auront jamais l'occasion d'utiliser ces sous-clauses.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour donner une id&eacute;e des diff&eacute;rences les plus &eacute;videntes entre la version SQL99 et la version Oracle de <span class="emphasis">CREATE TABLE</span>, notons que les tables cr&eacute;&eacute;es avec <span class="emphasis">GLOBAL TEMPORARY</span> doivent &ecirc;tre les tables les plus simples. Les tables temporaires globales sont priv&eacute;es de la plupart des caract&eacute;ristiques sp&eacute;ciales qu'Oracle autorise pour les tables ordinaires, comme le partitionnement, l'indexation, ou la clusterisation. Une table temporaire globale est accessible &agrave; partir de toutes les sessions ouvertes, mais les donn&eacute;es qui y sont stock&eacute;es ne sont visibles que par la session qui les y a ins&eacute;r&eacute;es. La clause <span class="emphasis">ON COMMIT</span>, qui n'est autoris&eacute;e que lors de la cr&eacute;ation de tables temporaires, indique &agrave; Oracle soit de tronquer la table apr&egrave;s chaque validation (<span class="emphasis">DELETE ROWS</span>), soit d'attendre que la session s'ach&egrave;ve (<span class="emphasis">PRESERVE ROWS</span>). Par exemple:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE GLOBAL TEMPORARY TABLE shipping_schedule (ship_date DATE,  receipt_date DATE,  received_by VARCHAR2(30),  amt NUMBER)ON COMMIT PRESERVE ROWS;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">CREATE TABLE</span> montr&eacute;e ci-dessus cr&eacute;e une table temporaire globale, <span class="emphasis">shipping_schedule</span>, qui conserve les lignes ins&eacute;r&eacute;es sur plusieurs sessions.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les caract&eacute;ristiques physiques d'une table Oracle sont d&eacute;finies via les quelques blocs de code et leurs sous-blocs:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>-- physical_characteristics{[{[physical_attributes]| TABLESPACE tablespace_name| {LOGGING | NOLOGGING} }]| {ORGANIZATION {HEAP [{[physical_attributes]  | TABLESPACE tablespace_name  | {LOGGING | NOLOGGING} }]| INDEX indexed_table_clause)}| CLUSTER cluster_name (column [,...n]) }[special_storage_clause]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">physical_characteristics</span> contr&ocirc;le le mode de stockage physique des donn&eacute;es sur le sous-syst&egrave;me de disque.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">TABLESPACE</span> attribue &agrave; la table un tablespace sp&eacute;cifique. La clause <span class="emphasis">TABLESPACE</span> peut &ecirc;tre ignor&eacute;e, pla&ccedil;ant ainsi l'index sur le tablespace par d&eacute;faut. Le mot-cl&eacute; <span class="emphasis">DEFAULT</span> donne le m&ecirc;me r&eacute;sultat.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les clauses <span class="emphasis">LOGGING</span> et <span class="emphasis">NOLOGGING</span> d&eacute;terminent s'il faut inscrire une table, un objet de grande taille (LOB) ou une partition dans le fichier de reprise.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">ORGANIZATION HEAP</span> indique &agrave; Oracle que les lignes de la table peuvent &ecirc;tre rang&eacute;es dans n'importe quel ordre. Elle peut &ecirc;tre associ&eacute;e &agrave; une clause <span class="emphasis">segment_characteristic</span>. Les lignes de la table peuvent &eacute;galement &ecirc;tre rang&eacute;es selon un index sp&eacute;cifique avec <span class="emphasis">ORGANIZATION INDEX index_name</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">physical_attributes</span> (comme le montre le bloc de code ci-dessous) d&eacute;finit les caract&eacute;ristiques de stockage pour la table dans son entier ou, si la table est partitionn&eacute;e, pour une partition sp&eacute;cifique (voir d&eacute;tails plus loin):</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>-- physical_attributes[{PCTFREE int | PCTUSED int | INITRANS int | MAXTRANS int | storage_  clause}]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p> <span class="emphasis">PCTFREE</span> d&eacute;finit le pourcentage d'espace libre attribu&eacute; &agrave; chaque bloc de donn&eacute;es de la table. Par exemple, une valeur de 10 permet de r&eacute;server 10&#160;% de l'espace pour l'insertion de nouvelles lignes. <span class="emphasis">PCTUSED</span> d&eacute;finit le pourcentage d'espace minimum pour qu'un bloc soit autoris&eacute; &agrave; recevoir de nouvelles lignes. Par exemple, une valeur de 90 signifie que de nouvelles lignes sont ins&eacute;r&eacute;es dans le bloc de donn&eacute;es quand l'espace utilis&eacute; est inf&eacute;rieur &agrave; 90&#160;%. La somme de <span class="emphasis">PCTFREE</span> et <span class="emphasis">PCTUSED</span> ne peut pas d&eacute;passer 100. La clause <span class="emphasis">INITRANS</span> est rarement modifi&eacute;e;  elle d&eacute;finit l'allocation de 1 &agrave; 255 transactions initiales &agrave; un bloc de donn&eacute;es. <span class="emphasis">MAXTRANS</span> d&eacute;finit le nombre maximum de transactions simultan&eacute;es sur un bloc de donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p> <span class="emphasis">storage_clause</span> contr&ocirc;le un certain nombre d'attributs relatifs au stockage physique des donn&eacute;es:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>-- storage_clauseSTORAGE ( [ {INITIAL int [K | M]      | NEXT int [K | M]      | MINEXTENTS int      | MAXEXTENTS {int | UNLIMITED}      | PCTINCREASE int      | FREELISTS int      | FREELIST GROUPS int      | OPTIMAL [{int [K | M] | NULL}]      | BUFFER_POOL {KEEP | RECYCLE | DEFAULT} ] [...] )</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Lors de leur d&eacute;finition, les attributs de la clause de stockage doivent &ecirc;tre encadr&eacute;s de parenth&egrave;ses et s&eacute;par&eacute;s par des espaces (par exemple, <span class="emphasis">(INITIAL 32M NEXT8M)</span>). <span class="emphasis">INITIAL int [K | M]</span> pr&eacute;cise la taille du premier extent de la table en octets, kilooctets <span class="emphasis">(K)</span> ou megaoctets <span class="emphasis">(M). NEXT</span> <span class="emphasis">int [K | M]</span> indique combien d'espace suppl&eacute;mentaire allouer une fois que <span class="emphasis">INITIAL</span> est rempli.  <span class="emphasis">PCTINCREASE int</span> contr&ocirc;le le taux d'augmentation des objets apr&egrave;s la croissance initiale. Le premier extent est allou&eacute; selon les sp&eacute;cifications. Le second est de la taille pr&eacute;cis&eacute;e par <span class="emphasis">NEXT</span>. La taille du troisi&egrave;me correspond &agrave; <span class="emphasis">NEXT + (NEXT * PCTINCREASE).</span> Si <span class="emphasis">PCTINCREASE</span> comporte une valeur de 0, c'est la taille d&eacute;finie par <span class="emphasis">NEXT</span> qui est utilis&eacute;e. Sinon, chaque nouvel extent d'un espace de stockage est plus grand que le pr&eacute;c&eacute;dent de la valeur d&eacute;finie par <span class="emphasis">PCTINCREASE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">MINEXTENTS int</span> demande &agrave; Oracle de cr&eacute;er un nombre minimum d'extents. Par d&eacute;faut, Oracle n'en cr&eacute;e qu'1 seul, mais peut en cr&eacute;er plus lorsque l'objet est initialis&eacute;.  <span class="emphasis">MAXEXTENTS int</span> d&eacute;termine le nombre maximum d'extents autoris&eacute;. Ce nombre peut &ecirc;tre <span class="emphasis">UNLIMITED</span> (mais il convient d'utiliser l'option UNLIMITED avec prudence: dans certaines situations, elle peut endommager la base de donn&eacute;es). <span class="emphasis">FREELISTS int</span> &eacute;tablit le nombre de listes libres pour chaque groupe, 1 &eacute;tant la valeur par d&eacute;faut. <span class="emphasis">FREELIST GROUPS int</span> d&eacute;termine le nombre de groupes de listes libres, 1 &eacute;tant la valeur par d&eacute;faut. Par exemple:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TABLE book_sales (qty NUMBER,  period_end_date DATE,  period_nbr NUMBER)TABLESPACE salesSTORAGE (INITIAL 8M NEXT 8M MINEXTENTS 1 MAXEXTENTS 8);</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La table <span class="emphasis">books_sales</span> est d&eacute;finie sur le tablespace <span class="emphasis">sales</span> comme n&eacute;cessitant 8 Mo d'espace initial, et programm&eacute;e pour augmenter d'au moins 8 Mo lorsque le premier extent sera plein. La table n'a pas moins d'1 extent mais pas plus de 8. Sa taille maximum est donc de 64 Mo.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">ORGANIZATION HEAP</span> permet &agrave; Oracle de placer physiquement les lignes de la table dans n'importe quel ordre. En option, elle peut &ecirc;tre associ&eacute;e &agrave; une clause <span class="emphasis">segment_characteristic_clause</span>. Ou encore, les lignes de la table peuvent &ecirc;tre ordonn&eacute;es physiquement selon un <span class="emphasis">INDEX</span> nomm&eacute;.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">CLUSTER</span> ajoute la table &agrave; un cluster existant, bas&eacute; sur une cl&eacute; clusteris&eacute;e. Reportez-vous &agrave; la section concernant la commande <span class="emphasis">CREATE CLUSTER</span> d'Oracle. Toutes les tables du cluster doivent comporter des colonnes qui correspondent aux colonnes de la cl&eacute; clusteris&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">special_storage_clause</span> d&eacute;taille trois styles de stockage des donn&eacute;es possibles dans une table Oracle: LOB (objets de grande taille, par ex. fichiers images), varrays et tables imbriqu&eacute;es:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>{LOB { (LOB_item [,n]) STORE AS {ENABLE | DISABLE} STORAGE IN ROW   | (LOB_item) STORE AS      {LOB_segment_name ({ENABLE | DISABLE} STORAGE IN ROW)      | LOB_segment_name      | ({ENABLE | DISABLE} STORAGE IN ROW)} | VARRAY varray_item STORE AS | NESTED TABLE nested_item STORE AS storage_table   [(physical_characteristics)]   [RETURN AS {LOCATOR | VALUE}] }</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">LOB</span> d&eacute;finit les attributs de stockage d'un segment de donn&eacute;es LOB. L'article LOB est le nom de la (ou des) colonne(s) LOB d&eacute;clar&eacute;es dans la table. Les objets LOB de moins de 4000 octets peuvent &ecirc;tres stock&eacute;s dans la ligne m&ecirc;me via la clause <span class="emphasis">ENABLE STORAGE IN ROW</span>. Quelle que soit leur taille, ils peuvent &eacute;galement &ecirc;tre stock&eacute;s en dehors de la ligne avec la clause <span class="emphasis">DISABLE STORAGE IN ROW</span>. Reportez-vous &agrave; la documentation Oracle pour plus d'informations sur le stockage des LOB avec <span class="emphasis">LOB_storage_clause</span>. Par exemple:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TABLE large_objects (pretty_picture BLOB,  interesting_text CLOB)STORAGE (INITIAL 256M NEXT 256M)LOG (pretty_picture, interesting_text)  STORE AS (TABLESPACE large_object_segment   STORAGE (INITIAL 512M NEXT 512M)   NOCACHE LOGGING);</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La table <span class="emphasis">large_objects</span> sert &agrave; stocker des images et du texte. Les caract&eacute;ristiques de stockage, tout comme les caract&eacute;ristiques de tenue du journal et de cache, sont &eacute;galement d&eacute;taill&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Un varray est un objet sp&eacute;cifique &agrave; Oracle. Oracle permet des param&egrave;tres de stockage diff&eacute;rents pour les LOB stock&eacute;s dans un varray, avec une syntaxe pour ainsi dire identique &agrave; celle de la clause LOB. Reportez-vous &agrave; la documentation de l'&eacute;diteur pour plus d'informations sur les varrays.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet de d&eacute;clarer une clause <span class="emphasis">NESTED TABLE</span> selon laquelle une table est stock&eacute;e virtuellement dans une colonne d'une autre table. La clause <span class="emphasis">STORE AS</span> permet de cr&eacute;er un nom de table proxy pour la table imbriqu&eacute;e, mais celle-ci doit d'abord &ecirc;tre cr&eacute;&eacute;e comme un type de donn&eacute;es utilisateur. Cette approche peut &ecirc;tre utile pour les tableaux de valeurs incomplets, mais elle n'est pas recommand&eacute;e au quotidien. Par exemple:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TYPE prop_nested_tbl AS TABLE OF props_nt;CREATE TABLE proposal_types  (proposal_category VARCHAR2(50),  proposals     PROPS_NT)NESTED TABLE props_nt STORE AS props_nt_table;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet de d&eacute;finir toutes sortes de caract&eacute;ristiques pour une table donn&eacute;e. En voici quelques unes:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>-- table_characteristics{ PARTITION characteristics }[CACHE | NOCACHE] [MONITORING | NOMONITORING][{NOPARALLEL | PARALLEL [int] }][{ENABLE | DISABLE} [VALIDATE | NOVALIDATE] {UNIQUE (column [,...n] ) | PRIMARY KEY | CONSTRAINT constraint_name}[index_clause][EXCEPTION INTO [schema.]table_name][CASCADE] ][AS select_statement]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle utilise la clause <span class="emphasis">PARTITION</span> pour am&eacute;liorer les performances en d&eacute;ployant la table sur plusieurs partitions. La syntaxe d&eacute;crivant toutes les permutations possibles lors de la partition d'une table est trop longue pour &ecirc;tre int&eacute;gralement reprise ici. D'autre part, elle est rarement utilis&eacute;e par les programmeur SQL d&eacute;butants. Reportez-vous &agrave; la documentation d'Oracle pour plus d'informations sur le partitionnement des tables.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">CACHE</span> tamponne une table pour permettre une lecture rapide, tandis que <span class="emphasis">NOCACHE</span> annule la mise en m&eacute;moire tampon. Les tables dot&eacute;es d'index permettent d'utiliser l'option <span class="emphasis">CACHE</span>. <span class="emphasis">MONITORING</span> recueille les statistiques d'une table pour am&eacute;liorer les performances. <span class="emphasis">NOMONITORING</span> annule cette fonction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour l'instruction <span class="emphasis">CREATE TABLE</span>, la clause <span class="emphasis">INDEX</span> est r&eacute;serv&eacute;e aux cl&eacute;s primaires et aux index uniques cr&eacute;&eacute;s avec la table. Reportez-vous &agrave; la documentation Oracle pour une explication d&eacute;taill&eacute;e des options de manipulation des index qu'offre la commande <span class="emphasis">CREATE TABLE</span>. Dans la plupart des cas, il est pr&eacute;f&eacute;rable d'utiliser la commande <span class="emphasis">CREATE INDEX</span>. A noter: Oracle indexe automatiquement les tables dot&eacute;es d'une contrainte de cl&eacute; primaire. Il n'est pas n&eacute;cessaire &agrave; l'utilisateur de cr&eacute;er un index dans cette situation.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">PARALLEL</span> permet d'acc&eacute;l&eacute;rer la cr&eacute;ation d'une table en la faisant traiter en parall&egrave;le par des processeurs distincts. Elle permet &eacute;galement d'utiliser le parall&eacute;lisme pour effectuer des requ&ecirc;tes et d'autres op&eacute;rations de manipulation des donn&eacute;es sur la table une fois celle-ci cr&eacute;&eacute;e. Il est possible de d&eacute;finir une valeur (qui doit &ecirc;tre un nombre entier) pour pr&eacute;ciser le nombre exact de threads parall&egrave;les &agrave; utiliser dans l'op&eacute;ration de cr&eacute;ation, ainsi que les op&eacute;rations futures sur la table. Comme Oracle calcule le nombre optimal de threads &agrave; utiliser pour une op&eacute;ration en parall&egrave;le donn&eacute;e, cette s&eacute;lection est optionnelle.  <span class="emphasis">NOPARALLEL</span>, qui constitue la configuration par d&eacute;faut, signifie que la table sera cr&eacute;&eacute;e en s&eacute;rie et n'autorise pas les requ&ecirc;tes et op&eacute;rations de manipulation des donn&eacute;es en parall&egrave;le pour l'avenir.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les clauses <span class="emphasis">ENABLE</span> et <span class="emphasis">DISABLE</span> sont utilis&eacute;es pour activer ou d&eacute;sactiver les contraintes d'une table. La clause <span class="emphasis">DISABLE</span> peut d&eacute;sactiver n'importe quelle contrainte d'int&eacute;grit&eacute; ou n'importe quel trigger actif. A l'inverse, <span class="emphasis">ENABLE</span> peut activer n'importe quelle contrainte d'int&eacute;grit&eacute; ou n'importe quel trigger d&eacute;sactiv&eacute;. La syntaxe de la clause est la suivante:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DISABLE | ENABLE {{UNIQUE(column[,...n] |  PRIMARY KEY |  CONSTRAINT constraint_name}   [CASCADE]}   [EXCEPTIONS INTO [owner.]table_name]   [USING INDEX [INITRANS int][MAXTRANS int]     [TABLESPACE tablespace_name][storage_characteristics]     [PCTFREE int] |</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le mot-cl&eacute; <span class="emphasis">CASCADE</span>, qui ne peut &ecirc;tre utilis&eacute; qu'avec <span class="emphasis">DISABLE</span>, ne sert pas &agrave; d&eacute;sactiver une contrainte ou un trigger en cascade. En fait, son r&ocirc;le est d'&eacute;tendre la d&eacute;sactivation ou l'activation &agrave; toutes les contraintes d'int&eacute;grit&eacute; qui d&eacute;pendent de la contrainte nomm&eacute;e dans la clause. La clause <span class="emphasis">EXCEPTIONS INTO</span>, qui ne peut &ecirc;tre utilis&eacute;e qu'avec <span class="emphasis">ENABLE</span>, indique &agrave; Oracle de stocker les informations concernant toute violation d'une contrainte d'int&eacute;grit&eacute; dans une table des exceptions existante. La clause <span class="emphasis">USING INDEX</span>, qui ne peut &eacute;galement &ecirc;tre utilis&eacute;e qu'avec <span class="emphasis">ENABLE</span>, fournit un m&eacute;canisme permettant de sp&eacute;cifier certaines caract&eacute;ristiques de stockage pour l'index d&eacute;sign&eacute;, en particulier des cl&eacute;s primaires et uniques. Par d&eacute;faut, toutes les contraintes sont activ&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">AS SELECT_statement</span> peuple la nouvelle table d&acute;enregistrements provenant d'une instruction <span class="emphasis">SELECT</span> valide. Contrairement &agrave; l'impl&eacute;mentation de <span class="emphasis">CREATE... AS SELECT</span> dans PostgreSQL, les colonnes de l'instruction <span class="emphasis">CREATE TABLE</span> doivent correspondre &agrave; celles de l'instruction <span class="emphasis">SELECT</span>. L'enregistrement au journal de <span class="emphasis">CREATE... AS SELECT</span> peut &ecirc;tre annul&eacute; avec le mot-cl&eacute; <span class="emphasis">NOLOGGING</span>. Par d&eacute;faut, l'op&eacute;ration est inscrite dans le fichier de reprise.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>En outre, Oracle prend en charge un certain nombre de fonctions orient&eacute;es objet qui d&eacute;passent le cadre de cet ouvrage.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [TEMPORARY | TEMP] TABLE <span class="replaceable">table</span><span class="emphasis">(</span>column_name datatype [NULL | NOT NULL] [DEFAULT value]<span class="emphasis"> </span>|<span class="emphasis"></span>[UNIQUE]<span class="emphasis"> </span>| [PRIMARY KEY (column[,...n])]  | [CHECK (expression) ]  | REFERENCES reference_table (reference_column)    [MATCH {FULL | PARTIAL | default}]    [ON DELETE {CASCADE | NO ACTION | RESTRICT | SET NULL | SET      DEFAULT}]    [ON UPDATE {CASCADE | NO ACTION | RESTRICT | SET NULL | SET      DEFAULT}]    [[NOT] DEFERRABLE] [INITIALLY {DEFERRED | IMMEDIATE}] } [,...n]|[table_constraint][,...n][INHERITS (inherited_table [,...n])]| [ON COMMIT {DELETE | PRESERVE} ROWS]| AS <span class="replaceable">SELECT</span>_statement</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Avec une syntaxe similaire &agrave; celle de MySQL, PostgreSQL permet la cr&eacute;ation d'une table temporaire <span class="emphasis">TEMPORARY</span>. Les tables temporaires n'existent que pour la dur&eacute;e de la session pendant laquelle elles ont &eacute;t&eacute; cr&eacute;&eacute;es, et s'effacent automatiquement quand la session est close.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les contraintes comme <span class="emphasis">UNIQUE</span>, <span class="emphasis">PRIMARY KEY</span> et <span class="emphasis">CHECK</span> sont essentiellement les m&ecirc;mes que dans Microsoft SQL Server. Toutefois, PostgreSQL a l'unique capacit&eacute; de cr&eacute;er des contraintes de colonnes sur plusieurs colonnes. N&eacute;anmoins, comme PostgreSQL prend aussi en charge les contraintes de table standard, il est recommand&eacute; d'employer l'approche d&eacute;crite par la norme ANSI.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La contrainte <span class="emphasis">REFERENCES</span> fonctionne un peu comme une contrainte <span class="emphasis">CHECK</span>, sauf qu'elle compare une valeur aux valeurs d'une autre colonne, dans une autre table. Elle peut aussi &ecirc;tre incluse dans une d&eacute;claration <span class="emphasis">FOREIGN KEY</span>. Les options de correspondance <span class="emphasis">MATCH</span> sont <span class="emphasis">FULL</span> (compl&egrave;te), <span class="emphasis">PARTIAL,</span> (partielle) ou l'option par d&eacute;faut (o&ugrave; <span class="emphasis">MATCH</span> n'a pas d'autre mot-cl&eacute;). La correspondance compl&egrave;te contraint toutes les colonnes d'une cl&eacute; &eacute;trang&egrave;re &agrave; contenir soit une valeur nulle, soit une valeur admissible. Par d&eacute;faut, les valeurs nulles peuvent &ecirc;tre m&eacute;lang&eacute;es aux valeurs non nulles. La syntaxe de la correspondance partielle est valide, mais l'option n'est pas prise en charge.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">REFERENCES</span> permet aussi de d&eacute;clarer plusieurs comportements diff&eacute;rents pour l'int&eacute;grit&eacute; r&eacute;f&eacute;rentielle <span class="emphasis">ON DELETE</span> ou <span class="emphasis">ON UPDATE</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ul><li><i> <span class="emphasis">NO ACTION</span></i><br>&#160;						  Produit une erreur lorsque la cl&eacute; &eacute;trang&egrave;re est enfreinte (option par d&eacute;faut).</li><li><i> <span class="emphasis">RESTRICT</span></i><br>&#160;						  Un synonyme de <span class="emphasis">NO ACTION</span>.</li><li><i> <span class="emphasis">CASCADE</span></i><br>&#160;						  Copie la valeur de la colonne r&eacute;f&eacute;renc&eacute;e dans la colonne r&eacute;f&eacute;ren&ccedil;ante.</li><li><i> <span class="emphasis">SET NULL</span></i><br>&#160;						  Configure la valeur de la colonne r&eacute;f&eacute;ren&ccedil;ante sur NULL.</li><li><i> <span class="emphasis">SET DEFAULT</span></i><br>&#160;						  Configure la colonne r&eacute;f&eacute;ren&ccedil;ante sur sa valeur par d&eacute;faut d&eacute;clar&eacute;e, ou sur null s'il n'y a pas de valeur par d&eacute;faut.</li></ul>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'option <span class="emphasis">DEFERRABLE</span> de la clause <span class="emphasis">REFERENCES</span> indique &agrave; PostgreSQL de diff&eacute;rer toutes les contraintes jusqu&acute;&agrave; la fin d'une transaction. Par d&eacute;faut, le comportement de la clause <span class="emphasis">REFERENCES</span> est <span class="emphasis">NOT DEFERRABLE</span>. La clause <span class="emphasis">INITIALLY</span> est similaire &agrave; la clause <span class="emphasis">DEFERRABLE</span>. <span class="emphasis">INITIALLY DEFERRED</span> v&eacute;rifie les contraintes apr&egrave;s chaque transaction; <span class="emphasis">INITIALLY IMMEDIATE</span>les v&eacute;rifie apr&egrave;s chaque instruction (configuration par d&eacute;faut).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>A noter: comme dans Microsoft SQL Server, les contraintes de colonnes peuvent toutes &ecirc;tre d&eacute;clar&eacute;es comme contraintes de table. La contrainte <span class="emphasis">FOREIGN KEY</span> ne peut &ecirc;tre d&eacute;clar&eacute;e que comme contrainte de table et non comme contrainte de colonne. Toutes les options de la clause <span class="emphasis">REFERENCES</span> sont prises en charge sous l'&eacute;gide de la clause <span class="emphasis">FOREIGN KEYS</span>. Voici la syntaxe:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>[FOREIGN KEY (column[,...n]) REFERENCES...]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">INHERITS inherited_table</span> d&eacute;signe une ou plusieurs tables o&ugrave; cette table h&eacute;rite de toutes ses colonnes. La nouvelle table h&eacute;rite aussi des fonctions rattach&eacute;es aux tables situ&eacute;es plus haut dans la hi&eacute;rarchie. Si une certaine colonne h&eacute;rit&eacute;e appara&icirc;t plus d'une fois, l'instruction &eacute;choue.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Si une table temporaire ou table temporaire globale est cr&eacute;&eacute;e dans PostgreSQL, la clause <span class="emphasis">ON COMMIT</span> peut &ecirc;tre ajout&eacute;e &agrave; la commande. Cette clause contr&ocirc;le le comportement de la table temporaire apr&egrave;s que les enregistrements aient &eacute;t&eacute; valid&eacute;s dans la table. <span class="emphasis">ON COMMIT DELETE ROWS</span> efface toutes les lignes de la table temporaire apr&egrave;s chaque validation. C'est le comportement par d&eacute;faut. <span class="emphasis">ON COMMIT PRESERVE ROWS</span> sauvegarde les lignes de la table temporaire apr&egrave;s la validation de la transaction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">AS SELECT_statement</span> permet &agrave; un programmeur de cr&eacute;er et de peupler une table avec des donn&eacute;es provenant d'une instruction <span class="emphasis">SELECT</span> valide. Il n'est pas n&eacute;cessaire de d&eacute;finir les colonnes, types de donn&eacute;es ou contraintes, puisqu'ils sont tous h&eacute;rit&eacute;s de la requ&ecirc;te. La fonctionnalit&eacute; de cette clause est similaire &agrave; celle de <span class="emphasis">SELECT... INTO</span>, mais sa syntaxe semble plus lisible.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le code ci-dessous ajoute une cl&eacute; &eacute;trang&egrave;re &agrave; la table de l'exemple:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>-- Cr&eacute;ation d'une contrainte de colonneCREATE TABLE favorite_books  (isbn     CHAR(100)  PRIMARY KEY NONCLUSTERED,  book_name   VARCHAR(40) UNIQUE,  category   VARCHAR(40) NULL,  subcategory  VARCHAR(40) NULL,  pub_date   DATETIME   NOT NULL,  purchase_date DATETIME   NOT NULL,   CONSTRAINT fk_categories FOREIGN KEY (category)     REFERENCES category(cat_name));</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La cl&eacute; &eacute;trang&egrave;re sur la colonne <span class="emphasis">categories</span> la rattache &agrave; la table <span class="emphasis">cat_name</span> au sein de la table <span class="emphasis">category</span>. Cette syntaxe est admise par les SGDB de tous les &eacute;diteurs mentionn&eacute;s dans cet ouvrage. De m&ecirc;me, la cl&eacute; &eacute;trang&egrave;re aurait pu &ecirc;tre d&eacute;clar&eacute;e comme une cl&eacute; &agrave; plusieurs colonnes et inclure les colonnes <span class="emphasis">category</span> et <span class="emphasis">subcategory</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>...CONSTRAINT fk_categories FOREIGN KEY (category, subcategory)     REFERENCES category(cat_name, subcat_name));</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Voici deux exemples complets suppl&eacute;mentaires, tir&eacute;s de la base de donn&eacute;es <span class="emphasis">pubs</span> (<span class="emphasis">jobs</span> et <span class="emphasis">employee</span>):</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>-- Pour une base de donn&eacute;es Microsoft SQL ServerCREATE TABLE jobs  (job_id SMALLINT IDENTITY(1,1) PRIMARY KEY CLUSTERED,  job_desc VARCHAR(50) NOT NULL DEFAULT 'New Position',  min_lvl TINYINT NOT NULL CHECK (min_lvl &gt;= 10),  max_lvl TINYINT NOT NULL CHECK (max_lvl &lt;= 250))-- Pour une base de donn&eacute;es MySQLCREATE TABLE employee  (emp_id INT AUTO_INCREMENT CONSTRAINT PK_emp_id PRIMARY KEY,  fname VARCHAR(20) NOT NULL,  minit CHAR(1) NULL,  lname VARCHAR(30) NOT NULL,  job_id SMALLINT NOT NULL DEFAULT 1   REFERENCES jobs(job_id),  job_lvl TINYINT DEFAULT 10,  pub_id CHAR(4) NOT NULL DEFAULT ('9952')   REFERENCES publishers(pub_id),  hire_date DATETIME NOT NULL DEFAULT (CURRENT_DATE( ));CREATE TABLE publishers  (pub_id char(4) NOT NULL   CONSTRAINT UPKCL_pubind PRIMARY KEY CLUSTERED   CHECK (pub_id IN ('1389', '0736', '0877', '1622', '1756')   OR pub_id LIKE '99[0-9][0-9]'),  pub_name varchar(40) NULL,  city varchar(20) NULL,  state char(2) NULL,  country varchar(30) NULL DEFAULT('USA'))</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'exemple qui suit est une instruction <span class="emphasis">CREATE TABLE</span> Oracle dot&eacute;e de nombreuses propri&eacute;t&eacute;s de stockage:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TABLE classical_music_cds  (music_id    INT,  composition   VARCHAR2(50),  composer     VARCHAR2(50),  performer    VARCHAR2(50),  performance_date DATE DEFAULT SYSDATE,  duration     INT,  cd_name     VARCHAR2(100),CONSTRAINT pk_class_cds PRIMARY KEY (music_id)  USING INDEX TABLESPACE index_ts  STORAGE (INITIAL 100K NEXT 20K),CONSTRAINT uq_class_cds UNIQUE (composition, performer, performance_date)  USING INDEX TABLESPACE index_ts  STORAGE (INITIAL 100K NEXT 20K))TABLESPACE tabledata_ts;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CREATE TRIGGER">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CREATE TRIGGER</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p> <span class="emphasis"></span>  Les triggers constituent une cat&eacute;gorie sp&eacute;ciale de proc&eacute;dures stock&eacute;es qui se d&eacute;clenchent automatiquement (d'o&ugrave; le nom "trigger": g&acirc;chette ou d&eacute;clencheur, en fran&ccedil;ais) quand une instruction de modification des donn&eacute;es est ex&eacute;cut&eacute;e. Les triggers sont associ&eacute;s &agrave; une instruction de modification des donn&eacute;es sp&eacute;cifique (<span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span> ou <span class="emphasis">DELETE</span>) sur une table sp&eacute;cifique.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TRIGGER trigger_name{BEFORE | AFTER} {[DELETE] | [INSERT] | [UPDATE] [OF column [,...n]}ON table_name[REFERENCING {OLD [ROW] [AS] old_name | NEW [ROW] [AS] new_name OLD TABLE [AS] old_name | NEW TABLE [AS] new_name}][FOR EACH { ROW | STATEMENT }][WHEN (conditions)]code block</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Par d&eacute;faut, les triggers ne se d&eacute;clenchent qu'une seule fois <span class="emphasis">au niveau de l'instruction</span>. En d'autres termes, une instruction <span class="emphasis">INSERT</span> peut ins&eacute;rer 500 lignes dans une table, mais un trigger d'insertion sur la m&ecirc;me table ne se d&eacute;clenche qu'une fois. Certains &eacute;diteurs permettent de d&eacute;clencher un trigger pour chaque ligne touch&eacute;e par la manipulation des donn&eacute;es. Ainsi, une instruction qui ins&egrave;re 500 lignes dans une table dot&eacute;e d'un trigger d'insertion au niveau de la ligne se d&eacute;clenche 500 fois, une par ligne ins&eacute;r&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>En plus d'&ecirc;tre associ&eacute; &agrave; une instruction de modification des donn&eacute;es sp&eacute;cifique (<span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span> ou <span class="emphasis">DELETE</span>) sur une table donn&eacute;e, le d&eacute;clenchement d'un trigger est &eacute;galement associ&eacute; &agrave; un <span class="emphasis">moment</span> sp&eacute;cifique. En g&eacute;n&eacute;ral, les triggers peuvent se d&eacute;clencher soit avant (<span class="emphasis">BEFORE</span>), soit apr&egrave;s (<span class="emphasis">AFTER</span>), soit, si l'&eacute;diteur l'autorise, &agrave; la place (<span class="emphasis">INSTEAD OF</span>) d'une instruction de modification des donn&eacute;es. Les triggers qui se d&eacute;clenchent avant ou &agrave; la place de l'instruction ne voient pas les changements qu'elle provoque, tandis que ceux qui se d&eacute;clenchent apr&egrave;s peuvent voir ces changements et agir en cons&eacute;quence.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TRIGGER trigger_nameON {table_name | view_name}[WITH ENCRYPTION]{FOR | AFTER | INSTEAD OF} {[DELETE] [,] [INSERT] [,] [UPDATE]}[WITH APPEND][NOT FOR REPLICATION]AS { T-SQL_block | { IF UPDATE(column) [{AND | OR} UPDATE(column)] [...n]  |  IF (COLUMNS_UPDATED( ) {bitwise_operator} updated_bitmask)  { comparison_operator} column_bitmask [...n] }  T-SQL_block [...n]  }</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server introduit un certain nombre de fonctionnalit&eacute;s int&eacute;ressantes dans son instruction <span class="emphasis">CREATE TRIGGER</span>. Tout d'abord, SQL Server permet d'associer plusieurs triggers &agrave; une m&ecirc;me op&eacute;ration de manipulation des donn&eacute;es sur une table ou une <span class="emphasis">vue</span>. Ainsi, il est possible d'assigner trois triggers <span class="emphasis">UPDATE</span> &agrave; une m&ecirc;me table.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">WITH ENCRYPTION</span> chiffre le texte du trigger &agrave; l'emplacement o&ugrave; il est stock&eacute; dans la table syst&egrave;me <span class="emphasis">syscomments</span>. La clause <span class="emphasis">WITH APPEND</span> ajoute un nouveau trigger d'un type d&eacute;j&agrave; existant &agrave; une table ou une vue. Cette clause est ajout&eacute;e pour permettre la compatibilit&eacute; r&eacute;troactive avec des versions plus anciennes de ce produit, et ne peut &ecirc;tre utilis&eacute;e qu'avec les triggers <span class="emphasis">FOR</span>. La clause <span class="emphasis">NOT FOR REPLICATION</span> d&eacute;sactive le trigger pour les op&eacute;rations de manipulation des donn&eacute;es invoqu&eacute;es via les options de r&eacute;plication int&eacute;gr&eacute;es de SQL Server.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les clauses <span class="emphasis">FOR</span>, <span class="emphasis">AFTER</span> et <span class="emphasis">INSTEAD OF</span> indiquent &agrave; SQL Server quand d&eacute;clencher le trigger. Les mots-cl&eacute; <span class="emphasis">FOR</span> et <span class="emphasis">AFTER</span> sont synonymes et servent les m&ecirc;mes fonctions. Leur r&ocirc;le est de pr&eacute;ciser que le trigger ne doit se d&eacute;clencher qu'apr&egrave;s l'ex&eacute;cution compl&egrave;te et r&eacute;ussie de l'instruction de modification des donn&eacute;es &agrave; laquelle ils sont rattach&eacute;s (ainsi que de toute action en cascade ou v&eacute;rification de contrainte potentielle). Une table donn&eacute;e peut accepter de nombreux triggers <span class="emphasis">AFTER</span>. Bien que l'ordre de d&eacute;clenchement ne soit pas d&eacute;fini, il est possible d'identifier le premier et le dernier via la proc&eacute;dure syst&egrave;me stock&eacute;e <span class="emphasis">sp_settriggerorder</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il est impossible de d&eacute;finir des triggers <span class="emphasis">AFTER</span> sur les vues.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">INSTEAD OF</span> fonctionne de la m&ecirc;me mani&egrave;re que le trigger <span class="emphasis">BEFORE</span> d'Oracle. Elle indique que le trigger doit se d&eacute;clencher avant (et donc &agrave; la place de) l'instruction de modification des donn&eacute;es &agrave; laquelle il est rattach&eacute;. Bien qu'une m&ecirc;me instruction <span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span> ou <span class="emphasis">DELETE</span> sur une table donn&eacute;e accepte plusieurs triggers <span class="emphasis">AFTER</span>, elle ne peut recevoir qu'un seul trigger <span class="emphasis">INSTEAD OF</span>. Ce type de trigger peut &ecirc;tre utilis&eacute; sur les vues, mais seulement si elles ne sont pas dot&eacute;es d'une clause <span class="emphasis">WITH CHECK OPTION</span>. Les triggers <span class="emphasis">INSTEAD OF DELETE</span> ne peuvent &ecirc;tre utilis&eacute;s quand l'effacement est assorti d'une action en cascade.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les clauses <span class="emphasis">DELETE</span>, <span class="emphasis">INSERT</span> et <span class="emphasis">UPDATE</span> d&eacute;signent l'instruction de modification des donn&eacute;es qui d&eacute;clenche le trigger. Dans une d&eacute;finition de trigger SQL Server, elles peuvent &ecirc;tre associ&eacute;es de toutes les fa&ccedil;ons possibles. Il suffit de les s&eacute;parer d'une virgule. Le m&ecirc;me code se d&eacute;clenche alors pour chaque instruction dans la d&eacute;finition combin&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">AS T-SQL_block</span> contient le code proc&eacute;dural d&eacute;clench&eacute; par le trigger chaque fois que la manipulation des donn&eacute;es a lieu. Elle devrait &ecirc;tre incluse dans les clauses <span class="emphasis">BEGIN</span> et <span class="emphasis">END</span> de Transact-SQL. Elle contient habituellement les commandes de contr&ocirc;le de flux et v&eacute;rifie le type et le nombre de donn&eacute;es modifi&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Quand un trigger est d&eacute;clench&eacute;, SQL Server instancie deux pseudo-tables: <span class="emphasis">deleted</span> et <span class="emphasis">inserted</span>. Ces tables pr&eacute;sentent la m&ecirc;me structure que la table sur laquelle les triggers sont d&eacute;finis, &agrave; la diff&eacute;rence que l'une rec&egrave;le les donn&eacute;es telles qu'elles &eacute;taient avant le d&eacute;clenchement de l'instruction (<span class="emphasis">deleted</span>) et l'autre, les nouvelles valeurs de la table apr&egrave;s son ex&eacute;cution (<span class="emphasis">inserted</span>).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Seuls les triggers <span class="emphasis">INSTEAD OF</span> peuvent acc&eacute;der &agrave; des colonnes <span class="emphasis">text</span>, <span class="emphasis">ntext</span> ou <span class="emphasis">image</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">AS IF UPDATE(column)</span>  v&eacute;rifie l'existence d'actions de type <span class="emphasis">INSERT</span> ou <span class="emphasis">UPDATE</span> sur une ou plusieurs colonnes donn&eacute;es. Il est possible de sp&eacute;cifier plusieurs colonnes en ajoutant des clauses <span class="emphasis">UPDATE(column)</span> apr&egrave;s la premi&egrave;re. Faire suivre la clause d'un bloc <span class="emphasis">BEGIN... END</span> Transact-SQL pour permettre le d&eacute;clenchement de plusieurs op&eacute;rations Transact-SQL lorsque la condition existe. D'un point de vue fonctionnel, cette clause est &eacute;quivalente &agrave; l'op&eacute;ration <span class="emphasis">IF... THEN... ELSE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">AS IF (COLUMNS_UPDATE( ))</span> est similaire &agrave; <span class="emphasis">AS IF UPDATE( )</span> en ce qu'elle ne se d&eacute;clenche que lorsqu'une op&eacute;ration <span class="emphasis">INSERT</span> ou <span class="emphasis">UPDATE</span> touche la colonne d&eacute;sign&eacute;e. Elle renvoie une cha&icirc;ne binaire <span class="emphasis">varbinary</span> qui indique les colonnes ins&eacute;r&eacute;es ou mises &agrave; jour et permet des op&eacute;rations sur les bits pour comparer les valeurs des colonnes de diverses mani&egrave;res. Les op&eacute;rateurs de comparaison sont le signe &eacute;gal (=), pour v&eacute;rifier si toutes les colonnes mentionn&eacute;es dans le masque binaire mis &agrave; jour ont bien &eacute;t&eacute; modifi&eacute;es, et le signe &laquo;&#160; plus grand que&#160;&raquo; (&gt;), pour v&eacute;rifier si une ou plusieurs des colonnes ont &eacute;t&eacute; modifi&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les triggers sont souvent utilis&eacute;s pour contr&ocirc;ler l'int&eacute;grit&eacute; r&eacute;f&eacute;rentielle. Toutefois, il est pr&eacute;f&eacute;rable de d&eacute;clarer les cl&eacute;s primaires et &eacute;trang&egrave;res via une instruction <span class="emphasis">CREATE TABLE</span> ou <span class="emphasis">ALTER TABLE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>SQL Server <span class="emphasis">ne permet pas</span> d'inclure les instructions suivantes dans le bloc Transact-SQL d'un trigger:  <span class="emphasis">ALTER</span>, <span class="emphasis">CREATE</span>, <span class="emphasis">DROP</span>, <span class="emphasis">DENY</span>, <span class="emphasis">GRANT</span>, <span class="emphasis">REVOKE</span>, <span class="emphasis">LOAD</span>, <span class="emphasis">RESTORE</span>, <span class="emphasis">RECONFIGURE</span> ou <span class="emphasis">TRUNCATE</span>. En outre, les instructions <span class="emphasis">DISK</span> et les commandes <span class="emphasis">UPDATE STATISTICS</span> ne sont pas non plus autoris&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>SQL Server permet aussi aux triggers de se d&eacute;clencher de mani&egrave;re r&eacute;cursive via la configuration <span class="emphasis">recursive triggers</span> de la proc&eacute;dure syst&egrave;me stock&eacute;e <span class="emphasis">sp_dboption</span>. Les triggers r&eacute;cursifs s'auto-d&eacute;clenchent par leurs propres actions. Par exemple, si un trigger <span class="emphasis">INSERT</span> rattach&eacute; &agrave; la table <span class="emphasis">T1</span> proc&egrave;de &agrave; une op&eacute;ration <span class="emphasis">INSERT</span> sur la table <span class="emphasis">T1</span>, il peut ex&eacute;cuter une op&eacute;ration r&eacute;cursive. Les triggers r&eacute;cursifs pr&eacute;sentent un risque, et cette fonctionnalit&eacute; est donc d&eacute;sactiv&eacute;e par d&eacute;faut.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>De la m&ecirc;me fa&ccedil;on, SQL Server permet les <span class="emphasis">triggers imbriqu&eacute;s triggers</span> jusqu&acute;&agrave; 32 niveaux. Si l'un quelconque des triggers imbriqu&eacute;s proc&egrave;de &agrave; un <span class="emphasis">ROLLBACK</span>, les triggers suivants ne s'ex&eacute;cuteront pas. On parle de triggers imbriqu&eacute;s lorsque, par exemple, un trigger rattach&eacute; &agrave; la table <span class="emphasis">T1</span> d&eacute;clenche une op&eacute;ration sur la table <span class="emphasis">T2</span>, elle-m&ecirc;me dot&eacute;e d'un trigger qui d&eacute;clenche une op&eacute;ration sur la table <span class="emphasis">T3</span>. Si une boucle sans fin est lanc&eacute;e, les triggers s'annulent automatiquement. Les triggers imbriqu&eacute;s sont activ&eacute;s via la configuration "nested triggers" de la proc&eacute;dure syst&egrave;me stock&eacute;e <span class="emphasis">sp_configure</span>. Si les triggers imbriqu&eacute;s sont d&eacute;sactiv&eacute;s, les triggers r&eacute;cursifs le sont &eacute;galement, m&ecirc;me si <span class="emphasis">sp_dboption</span> comporte la configuration &laquo;&#160; recursive triggers&#160;&raquo;.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les instructions <span class="emphasis">CREATE</span> de SQL Server autorisent la <span class="emphasis">r&eacute;solution de noms diff&eacute;r&eacute;e</span> , ce qui signifie que la commande est trait&eacute;e m&ecirc;me si elle se r&eacute;f&egrave;re &agrave; un objet qui n'existe pas encore dans la base de donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [OR REPLACE] TRIGGER [owner.]trigger_name{BEFORE | AFTER | INSTEAD OF}{[DELETE] [OR] [INSERT] [OR] [UPDATE [OF column [,...n] ]] [...n]}ON {table_name | view_name}[REFERENCING {OLD [AS] old_name | NEW [AS] new_name}][FOR EACH { ROW | STATEMENT }][WHEN (conditions)]PL/SQL block</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Comme c'est souvent le cas avec l'instruction <span class="emphasis">CREATE TRIGGER</span>, la commande sp&eacute;cifie la modification des donn&eacute;es qui d&eacute;clenche le bloc de code PL/SQL (<span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span> ou <span class="emphasis">DELETE</span>) et le moment de son d&eacute;clenchement &8212; avant (<span class="emphasis">BEFORE</span>), apr&egrave;s (<span class="emphasis">AFTER</span>) ou &agrave; la place de (<span class="emphasis">INSTEAD OF</span>) l'op&eacute;ration. Pour les op&eacute;rations <span class="emphasis">UPDATE</span>, un <span class="emphasis">UPDATE OF</span> d'une ou plusieurs colonnes peut &ecirc;tre sp&eacute;cifi&eacute; pour indiquer que le trigger de mise &agrave; jour ne devrait se d&eacute;clencher que si l'une de ces colonnes est modifi&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Oracle, les triggers <span class="emphasis">INSTEAD OF</span> ne peuvent s'ex&eacute;cuter que sur les vues, et non sur les tables.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet aussi le d&eacute;clenchement de triggers associ&eacute;s &agrave; certains &eacute;v&egrave;nements de la base de donn&eacute;es comme <span class="emphasis">DROP TABLE</span> ou <span class="emphasis">SHUTDOWN</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">REFERENCING</span> attribue un nom aux pseudo-tables qui contiennent l'ancienne (<span class="emphasis">OLD</span>) et la nouvelle (<span class="emphasis">NEW</span>) version de la table (dans SQL Server, les pseudo-tables sont automatiquement nomm&eacute;es <span class="emphasis">inserted</span> et <span class="emphasis">deleted</span>). Dans Oracle, les noms par d&eacute;faut de ces pseudo-tables sont <span class="emphasis">OLD</span> et <span class="emphasis">NEW</span>. Elles comparent les valeurs des enregistrements avant la manipulation des donn&eacute;es (dans la pseudo-table <span class="emphasis">OLD</span>) aux valeurs r&eacute;sultant de l'op&eacute;ration (dans la pseudo-table <span class="emphasis">NEW</span>). Elles ex&eacute;cutent aussi des op&eacute;rations conditionnelles sur le <span class="emphasis">PL/SQL_block</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Lorsqu'il est fait r&eacute;f&eacute;rence &agrave; une valeur provenant des tables <span class="emphasis">OLD</span>  et <span class="emphasis">NEW</span>, cette valeur doit &ecirc;tre pr&eacute;c&eacute;d&eacute;e des deux points (:), sauf dans la clause WHEN du trigger, o&ugrave; les deux points ne sont pas utilis&eacute;s.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">FOR EACH ROW</span> indique au trigger d'intervenir sur chaque ligne (il se d&eacute;clenche une fois pour chaque ligne affect&eacute;e par l'op&eacute;ration), plut&ocirc;t que d'op&eacute;rer comme un trigger d'instruction implicite (qui ne se d&eacute;clenche qu'une fois pour toute la transaction). La clause <span class="emphasis">WHEN</span> d&eacute;finit une condition SQL qui limite l'ex&eacute;cution du trigger aux seules situations o&ugrave; la condition est remplie. La clause <span class="emphasis">WHEN</span> permet aussi de comparer les tables <span class="emphasis">OLD</span> et <span class="emphasis">NEW</span> sans avoir &agrave; cr&eacute;er un bloc PL/SQL.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il est possible de combiner diff&eacute;rents types de triggers dans une m&ecirc;me commande trigger &agrave; condition qu'ils soient de m&ecirc;me niveau (ligne ou instruction) et qu'ils portent sur la m&ecirc;me table. Quand plusieurs triggers sont ainsi combin&eacute;s dans une m&ecirc;me instruction, les clauses <span class="emphasis">IF INSERTING THEN</span>, <span class="emphasis">IF UPDATING THEN</span> et <span class="emphasis">IF DELETING THEN</span> peuvent &ecirc;tre utilis&eacute;es dans le bloc PL/SQL pour scinder la logique du code en segments distincts. Une clause <span class="emphasis">ELSE</span> peut aussi trouver sa place dans une telle structure.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TRIGGER trigger_name{ BEFORE | AFTER }{ {[DELETE] [OR | ,] [INSERT] [OR | ,] [UPDATE]} [OR...] }ON table_nameFOR EACH { ROW | STATEMENT }EXECUTE PROCEDURE function_name (parameters)</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'impl&eacute;mentation de <span class="emphasis">CREATE TRIGGER</span> dans PostgreSQL fonctionne de fa&ccedil;on similaire &agrave; celle des autres &eacute;diteurs. Un trigger peut se d&eacute;clencher avant (<span class="emphasis">BEFORE</span>) que la modification des donn&eacute;es de l&acute;enregistrement soit entam&eacute;e et que les contraintes soient d&eacute;clench&eacute;es. Ou il peut se d&eacute;clencher apr&egrave;s (<span class="emphasis">AFTER</span>) la manipulation des donn&eacute;es (et apr&egrave;s que les contraintes aient &eacute;t&eacute; v&eacute;rifi&eacute;es), auquel cas il peut prendre en compte toutes les op&eacute;rations de la transaction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Plut&ocirc;t que de traiter un bloc de code proc&eacute;dural (comme le font Oracle et SQL Server), PostgreSQL ex&eacute;cute une fonction via la clause <span class="emphasis">EXECUTE PROCEDURE</span> cr&eacute;&eacute;e avec l'instruction <span class="emphasis">CREATE FUNCTION</span>. En outre, les autres &eacute;diteurs traitent implicitement toutes les lignes concern&eacute;es par la transaction. PostgreSQL ex&eacute;cute le trigger soit sur chaque ligne avec la clause <span class="emphasis">FOR EACH ROW</span>, soit une seule fois pour toute la transaction avec la clause <span class="emphasis">FOR EACH INSTRUCTION</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'exemple ci-dessous montre un trigger <span class="emphasis">BEFORE</span> dans PostgreSQL qui v&eacute;rifie que le code de distributeur sp&eacute;cifi&eacute; pour chaque ligne correspond bien &agrave; un code de la table <span class="emphasis">distributors</span> avant d'ins&eacute;rer ou de mettre &agrave; jour une ligne dans la table <span class="emphasis">sales</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TRIGGER if_dist_existsBEFORE INSERT OR UPDATE ON salesFOR EACH ROWEXECUTE PROCEDURE check_primary_key ('did', 'distributors', 'did');</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les triggers <span class="emphasis">BEFORE</span> modifient les valeurs d'une table affect&eacute;es par une op&eacute;ration de modification des donn&eacute;es puisque le traitement des enrgistrements concern&eacute;s se produit avant qu'ils soient modifi&eacute;s dans la table. Comme ils ne peuvent pas se d&eacute;clencher avant que la ligne ait &eacute;t&eacute; modifi&eacute;e dans la table, les triggers <span class="emphasis">AFTER</span> sont souvent utilis&eacute;s pour auditer les processus.  <span class="emphasis">INSTEAD OF</span> supprime compl&egrave;tement la modification des donn&eacute;es et y substitue un code fournit par l'utilisateur pour la transaction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Voici un trigger <span class="emphasis">BEFORE</span> dans Oracle qui utilise les pseudo-tables <span class="emphasis">OLD</span> et <span class="emphasis">NEW</span> pour comparer les valeurs (SQL Server utilise les pseudo-tables <span class="emphasis">DELETED</span> et <span class="emphasis">INSERTED</span> de la m&ecirc;me fa&ccedil;on). Ce trigger cr&eacute;e un enregistrement d'audit avant de modifier l&acute;enregistrement des salaires d'un employ&eacute;:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TRIGGER if_emp_changesBEFORE DELETE OR UPDATE ON employeeFOR EACH ROWWHEN (new.emp_salary &lt;&gt; old.emp_salary)BEGIN INSERT INTO employee_audit VALUES ('old',:old.emp_id,:old.emp_salary,:old.emp_ssn);END;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'exemple ci-dessous produit un trigger d'insertion et de mise &agrave; jour dans Oracle qui utilise les clauses <span class="emphasis">IF INSERTED THEN</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TRIGGER if_emp_changesBEFORE DELETE OR UPDATE ON employeeFOR EACH ROWBEGIN IF DELETING THEN  INSERT INTO employee_audit  VALUES ('DELETED',:old.emp_id,:old.emp_salary,:old.emp_ssn); ELSE  INSERT INTO employee_audit  VALUES ('UPDATED',:old.emp_id,:new.emp_salary,:old.emp_ssn); END IF;END;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cet exemple tir&eacute; de SQL Server ajoute une nouvelle table intitul&eacute;e <span class="emphasis">contractor</span> &agrave; la base de donn&eacute;es. Tous les enregistrements de la table <span class="emphasis">employee</span> qui indiquent que l'employ&eacute; est sous contrat temporaire ont &eacute;t&eacute; d&eacute;plac&eacute;s vers la table <span class="emphasis">contractor</span>. Maintenant, tous les nouveaux employ&eacute;s ins&eacute;r&eacute;s dans la table <span class="emphasis">employee</span> vont &ecirc;tre d&eacute;plac&eacute;s vers la table <span class="emphasis">contractor</span> via un trigger <span class="emphasis">INSTEAD OF</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE TRIGGER if_emp_is_contractorINSTEAD OF INSERT ON employeeBEGIN INSERT INTO contractor SELECT * FROM inserted WHERE status = 'CON' INSERT INTO employee SELECT * FROM inserted WHERE status = 'FTE'ENDGO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="CREATE VIEW">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">CREATE VIEW</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>Cette instructioncr&eacute;e une <span class="emphasis">vue</span>, ou <span class="emphasis">table virtuelle</span>. Une vue agit exactement comme une table, mais elle est en fait d&eacute;finie comme une requ&ecirc;te. Presque n'importe quelle instruction <span class="emphasis">SELECT</span> valide peut d&eacute;finir le contenu d'une vue, except&eacute; la clause <span class="emphasis">ORDER BY</span>, qui est en g&eacute;n&eacute;ral interdite.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Quand une vue est r&eacute;f&eacute;renc&eacute;e dans une instruction, le jeu de r&eacute;sultats provenant de la requ&ecirc;te devient le contenu de la vue pour la dur&eacute;e de l'instruction. Dans certains cas, les vues peuvent &ecirc;tre mises &agrave; jour. Les changements de la vue sont alors r&eacute;percut&eacute;s sur les donn&eacute;es sous-jacentes des tables de base.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les vues peuvent m&ecirc;me &ecirc;tre cr&eacute;&eacute;es &agrave; partir d'autre vues, mais cette pratique n'est pas recommand&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE VIEW view_name [(column list)]AS(SELECT_statement[WITH [CASCADED | LOCAL] CHECK OPTION] )</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les vues ont en g&eacute;n&eacute;ral le m&ecirc;me degr&eacute; d'efficacit&eacute; que les requ&ecirc;tes sur lesquelles elles sont bas&eacute;es. C'est pourquoi il est important de bien s'assurer que l'instruction <span class="emphasis">SELECT</span> dont elles proviennent est rapide et bien &eacute;crite.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il est aussi possible de d&eacute;finir une <span class="emphasis">liste de colonnes</span> apr&egrave;s le nom de la vue. La liste facultative de colonnes contient des alias qui servent de nom pour chaque &eacute;l&eacute;ment du jeu de r&eacute;sultats de l'instruction <span class="emphasis">SELECT</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">WITH CHECK OPTION</span> n'est utilis&eacute;e <span class="emphasis">que</span> pour les vues qui permettent de modifier la table de base. Elle permet de s'assurer que seules les donn&eacute;es que la vue puisse ins&eacute;rer, mettre &agrave; jour ou effacer sont celles auxquelles elle a acc&egrave;s en lecture. Par exemple, si une vue des <span class="emphasis">employees</span> ne montre que les employ&eacute;s &agrave; plein temps et non les employ&eacute;s pay&eacute;s &agrave; l&acute;heure, il est impossible d'ins&eacute;rer, de mettre &agrave; jour ou d'effacer des employ&eacute;s pay&eacute;s &agrave; l&acute;heure &agrave; partir de cette vue.  Les options <span class="emphasis">CASCADE</span> et <span class="emphasis">LOCAL</span> de la clause <span class="emphasis">CHECK OPTION</span> sont utilis&eacute;es pour les vues imbriqu&eacute;es. L'option <span class="emphasis">CASCADE</span> proc&egrave;de &agrave; la v&eacute;rification pour la vue en cours et toutes les vues &agrave; partir desquelles elle est cr&eacute;&eacute;e. L'option <span class="emphasis">LOCAL</span> ne v&eacute;rifie que la vue en cours, m&ecirc;me si elle est cr&eacute;&eacute;e &agrave; partir d'autres vues.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les vues ANSI SQL99 peuvent mettre &agrave; jour les tables de base &agrave; partir desquelles elles sont cr&eacute;&eacute;es si elles satisfont aux conditions suivantes:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ol><li>L'instruction <span class="emphasis">SELECT</span> dont provient la vue est bas&eacute;e sur une table.</li><li>La vue ne comporte pas d'op&eacute;rateurs <span class="emphasis">UNION</span>, <span class="emphasis">MINUS</span> ou <span class="emphasis">INTERSECT</span>.</li><li>L'instruction <span class="emphasis">SELECT</span> dont elle provient ne contient pas de clauses <span class="emphasis">GROUP BY</span> ou <span class="emphasis">HAVING</span>.</li><li>L'instruction <span class="emphasis">SELECT</span> dont elle provient ne contient aucune r&eacute;f&eacute;rence &agrave; des pseudo-colonnes comme <span class="emphasis">ROWNUM</span> ou <span class="emphasis">ROWGUIDCOL</span>.</li><li>L'instruction <span class="emphasis">SELECT</span> dont elle provient ne contient aucune fonction de groupe.</li><li>L'instruction <span class="emphasis">SELECT</span> dont elle provient ne contient pas la clause <span class="emphasis">DISTINCT</span>.</li></ol>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [owner_name.]VIEW view_name [(column [,...n])][WITH {ENCRYPTION | SCHEMABINDING | VIEW_METADATA} [,...n]]ASselect_statement[WITH CHECK OPTION]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server ajoute deux nouvelles options &agrave; la norme SQL99: <span class="emphasis">ENCRYPTION</span> et <span class="emphasis">SCHEMABINDING</span>. L'option <span class="emphasis">ENCRYPTION</span> chiffre le texte de la vue dans la table <span class="emphasis">syscomments</span>. L'option <span class="emphasis">SCHEMABINDING</span> lie la vue &agrave; un sch&eacute;ma sp&eacute;cifique, ce qui oblige tous les objets de la vue &agrave; &ecirc;tre r&eacute;f&eacute;renc&eacute;s par leur nom complet (nom du propri&eacute;taire et nom de l'objet). Les vues cr&eacute;&eacute;es avec <span class="emphasis">SCHEMABINDING</span> (et les tables auxquelles elles font r&eacute;f&eacute;rence) doivent &ecirc;tre d&eacute;gag&eacute;es du sch&eacute;ma (avec <span class="emphasis">ALTER VIEW</span>) avant de pouvoir &ecirc;tre effac&eacute;es ou modifi&eacute;es.  <span class="emphasis">VIEW_METADATA</span> indique que SQL Server renvoie des m&eacute;tadonn&eacute;es sur la vue aux demandes des API DBLIB et OLEDB (au lieu de la table de base). Les vues cr&eacute;&eacute;es ou alt&eacute;r&eacute;es avec <span class="emphasis">VIEW_METADATA</span> permettent la mise &agrave; jour de leurs colonnes par des triggers <span class="emphasis">INSERT</span> et <span class="emphasis">UPDATE INSTEAD OF</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>SQL Server permet d'indexer les vues (voir <span class="emphasis">CREATE INDEX</span>). Cr&eacute;er un index unique clusteris&eacute; sur une vue revient &agrave; faire stocker par SQL Server une copie physique de la vue sur la base de donn&eacute;es. Les modifications apport&eacute;es &agrave; la table de base sont automatiquement mises &agrave; jour dans la vue index&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les vues index&eacute;es ne devraient &ecirc;tre cr&eacute;&eacute;es &agrave; partir de tables de base qu'avec la clause <span class="emphasis">SCHEMABINDING</span>. Il s'agit d'une technique complexe qu'il vaut mieux r&eacute;server aux experts. Reportez-vous &agrave; la documentation de l'&eacute;diteur pour plus d'information.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE [OR REPLACE] [FORCE | NO FORCE] VIEW [owner_name.]view_name [(column [,...n])]ASSELECT_statement[WITH [READ ONLY | CHECK OPTION [CONSTRAINT constraint_name] ] ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">OR REPLACE</span> demande &agrave; Oracle de remplacer toute vue existante portant le m&ecirc;me nom par la nouvelle vue. La clause <span class="emphasis">FORCE</span> cr&eacute;e une vue sans se soucier de savoir si les tables de base existent ou si l'utilisateur dispose de privil&egrave;ges lui permettant d'y acc&eacute;der. La clause <span class="emphasis">NO FORCE</span> ne cr&eacute;e la vue que si les tables de base et les privil&egrave;ges appropri&eacute;s sont en place.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet d'utiliser <span class="emphasis">CHECK</span><span class="emphasis">OPTION</span>, y compris la possibilit&eacute; nommer la contrainte avec la clause <span class="emphasis">CONSTRAINT</span>. <span class="emphasis">CHECK</span> <span class="emphasis">OPTION</span> peut &ecirc;tre utilis&eacute;e pour les vues imbriqu&eacute;es, mais seulement si elle est appliqu&eacute;e sur la vue de niveau sup&eacute;rieur. Si la contrainte n'est pas nomm&eacute;e, Oracle lui attribue le nom <span class="emphasis">SYS_C</span><span class="emphasis">n</span>, o&ugrave; <span class="emphasis">n</span> est un nombre entier.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet de manipuler les donn&eacute;es dans les vues, &agrave; condition que les sp&eacute;cifications de la norme SQL99 soient respect&eacute;es, et que la sp&eacute;cification suppl&eacute;mentaire ne contienne aucune expression. La clause <span class="emphasis">WITH READ ONLY</span> assure que la vue n'est utilis&eacute;e que pour r&eacute;cup&eacute;rer des donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE VIEW view_name AS SELECT_statement</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">CREATE VIEW</span> dans PostgreSQL ne prend pas en charge certaines des fonctions les plus complexes offertes par les autres &eacute;diteurs, mais elle permet de cr&eacute;er des vues &agrave; partir de tables et d'autres objets de classes d&eacute;finies. En g&eacute;n&eacute;ral, les vues PostgreSQL sont cr&eacute;&eacute;es &agrave; partir d'autres tables plut&ocirc;t que d'autres vues. Elle ne sont pas utilis&eacute;es pour proc&eacute;der &agrave; la modification des donn&eacute;es contenues dans les tables de base sous-jacentes.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La vue la plus simple est bas&eacute;e sur l'int&eacute;gralit&eacute; du contenu d'une seule table:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE VIEW employeesASSELECT *FROM employee_tbl;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cet exemple montre une vue intitul&eacute;e <span class="emphasis">california_authors</span> qui ne permet que les modifications appliqu&eacute;es aux auteurs vivant en Californie:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE VIEW california_authorsASSELECT au_lname, au_fname, city, stateFROM authorsWHERE state = 'CA'WITH CHECK OPTIONGO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="DECLARE CURSOR">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">DECLARE CURSOR</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">DECLARE CURSOR</span>permet la r&eacute;cup&eacute;ration et la manipulation des enregistrements d'une table, ligne &agrave; la fois. Ceci permet d'adopter un mode de traitement ligne par ligne plut&ocirc;t que le traitement par jeu traditionnellement offert dans SQL. Pour utiliser correctement cette proc&eacute;dure, il faut:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ol><li>D&eacute;clarer le curseur (<span class="emphasis">DECLARE</span>).<ul>
								</ul>
							</li><li>Ouvrir le curseur (<span class="emphasis">OPEN</span>).<ul>
								</ul>
							</li><li> extraire les lignes du curseur (<span class="emphasis">FETCH</span>).<ul>
								</ul>
							</li><li>Quand l'op&eacute;ration est termin&eacute;e, fermer le curseur (<span class="emphasis">CLOSE</span>)<ul>
								</ul>
							</li></ol>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>MySQL ne prend pas en charge les curseurs serveur tels qu'ils sont d&eacute;finis dans la norme ANSI, mais propose de nombreuses extensions de programmation en C qui fournissent les m&ecirc;mes fonctionnalit&eacute;s.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">DECLARE CURSOR</span> fonctionne par la d&eacute;finition d'une instruction <span class="emphasis">SELECT</span>. Chaque ligne renvoy&eacute;e par l'instruction <span class="emphasis">SELECT</span> peut &ecirc;tre r&eacute;cup&eacute;r&eacute;e et manipul&eacute;e individuellement. La commande <span class="emphasis">DECLARE CURSOR</span> d&eacute;finit &eacute;galement les caract&eacute;ristiques d'un curseur serveur. Ces caract&eacute;ristiques peuvent inclure le d&eacute;filement du curseur et l'instruction <span class="emphasis">SELECT</span> utilis&eacute;e pour r&eacute;cup&eacute;rer un jeu de r&eacute;sultats.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server permet d'identifier l'option <span class="emphasis">INSENSITIVE</span>  et l'option <span class="emphasis">SCROLL</span>. Le mot-cl&eacute; <span class="emphasis">INSENSITIVE</span> indique que le curseur doit cr&eacute;er une copie temporaire du jeu de r&eacute;sultats qu'il utilise. Toutes les requ&ecirc;tes qui lui sont adress&eacute;es re&ccedil;oivent leur r&eacute;ponse &agrave; partir de la table temporaire et non de la table de base. Le curseur ne permet pas d'effectuer de modifications. Les extractions ult&eacute;rieures du curseur ne refl&egrave;tent aucun des changements qu'il effectue. Le mot-cl&eacute; <span class="emphasis">SCROLL</span> active toutes les options <span class="emphasis">FETCH</span> du curseur (<span class="emphasis">FIRST</span>, <span class="emphasis">LAST</span>, <span class="emphasis">PRIOR</span>, <span class="emphasis">NEXT</span>, <span class="emphasis">RELATIVE</span> et <span class="emphasis">ABSOLUTE</span>). Reportez-vous &agrave; la commande <span class="emphasis">FETCH</span> pour plus de d&eacute;tails. Si <span class="emphasis">SCROLL</span> n'est pas d&eacute;clar&eacute;, la seule option <span class="emphasis">FETCH</span> disponible est <span class="emphasis">NEXT</span>. Un curseur en lecture seule peut aussi &ecirc;tre d&eacute;clar&eacute; avec la clause <span class="emphasis">FOR READ ONLY</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Oracle, les variables ne sont autoris&eacute;es dans la clause <span class="emphasis">WHERE</span> de l'instruction <span class="emphasis">SELECT</span> que si elles ont d'abord &eacute;t&eacute; d&eacute;clar&eacute;es comme variables. Les valeurs des param&egrave;tres ne sont pas d&eacute;finies au <span class="emphasis">DECLARE</span>, mais &agrave; la commande <span class="emphasis">OPEN</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L'impl&eacute;mentation de PostgreSQL est en tous points similaire &agrave; celle de Microsoft SQL Server, sauf qu'elle permet une option <span class="emphasis">BINARY</span>. <span class="emphasis">BINARY</span> oblige le curseur &agrave; r&eacute;cup&eacute;rer les donn&eacute;es au format binaire plut&ocirc;t qu'au format texte.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe dans Microsoft SQL Server </span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DECLARE cursor_name [INSENSITIVE] [SCROLL] CURSORFOR select_statement[FOR {READ ONLY | UPDATE [OF column_name [,...n]]}]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title"> Syntaxe dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DECLARE CURSOR cursor_name [parameter1 datatype1 [,...parameterN datatypeN]IS select_statement[FOR UPDATE [OF column_name [,...n]]}]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DECLARE cursor_name [BINARY] [INSENSITIVE] [SCROLL] CURSORFOR select_statement[FOR {READ ONLY | UPDATE [OF column_name [,...n]]}]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server prend en charge le format standard d&eacute;crit plus haut, mais offre aussi une extension plus &eacute;labor&eacute;e. La syntaxe pour cette derni&egrave;re est:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DECLARE cursor_name CURSOR[LOCAL | GLOBAL] [FORWARD_ONLY | SCROLL][STATIC | KEYSET | DYNAMIC | FAST_FORWARD][READ_ONLY | SCROLL_LOCKS | OPTIMISTIC][TYPE_WARNING]FOR select_statement[FOR UPDATE [OF column_name [,...n]]]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette syntaxe fonctionne de la m&ecirc;me fa&ccedil;on que la d&eacute;claration de curseur de la norme ANSI, mais elle offre de nombreuses fonctionnalit&eacute;s nouvelles. Premi&egrave;rement, l'&eacute;tendue du curseur peut &ecirc;tre soit <span class="emphasis">LOCAL</span>, soit <span class="emphasis">GLOBAL</span>. Si <span class="emphasis">LOCAL</span> est s&eacute;lectionn&eacute;, le curseur n'est disponible que dans le cadre du lot, de la proc&eacute;dure stock&eacute;e ou du trigger Transact-SQL au cours duquel il a &eacute;t&eacute; d&eacute;clar&eacute;. Si <span class="emphasis">GLOBAL</span> est s&eacute;lectionn&eacute;, le curseur est disponible comme les commandes <span class="emphasis">OPEN</span> et <span class="emphasis">FETCH</span> pour toute la connexion.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Ne pas confondre la notation Transact-SQL avec la d&eacute;claration de curseur de la norme ANSI sous Microsoft SQL Server.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les options suivantes d&eacute;terminent le mode de recherche du curseur dans le jeu d&acute;enregistrements. <span class="emphasis">FORWARD_ONLY</span>, contrairement &agrave; <span class="emphasis">SCROLL</span>, implique que le curseur ne peut d&eacute;filer que du premier au dernier enregistrement. Cette option ne peut pas &ecirc;tre utilis&eacute;e en conjonction avec <span class="emphasis">STATIC</span>, <span class="emphasis">KEYSET</span> ou <span class="emphasis">DYNAMIC</span>. Il agit comme un curseur <span class="emphasis">DYNAMIC</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p> <span class="emphasis">STATIC</span> fonctionne de mani&egrave;re similaire au mot-cl&eacute; <span class="emphasis">INSENSITIVE</span>. <span class="emphasis">KEYSET</span> rappelle <span class="emphasis">STATIC</span> et <span class="emphasis">INSENSITIVE</span>, mais permet d'effectuer des modifications sur le jeu de r&eacute;sultats. Il n'est pas conscient des enregistrements ins&eacute;r&eacute;s par d'autres utilisateurs apr&egrave;s l'ouverture du curseur, mais les enregistrements effac&eacute;s produisent une variable <span class="emphasis">@@FETCH_STATUS</span> de -2. Les nouvelles valeurs deviennent visibles lorsque les mises &agrave; jour sont ex&eacute;cut&eacute;es en sp&eacute;cifiant <span class="emphasis">WHERE CURRENT OF</span>. <span class="emphasis">DYNAMIC</span> refl&egrave;te tous les changements subis par les donn&eacute;es du jeu de r&eacute;sultats pendant la session sur le curseur. Le jeu de r&eacute;sultats peut changer pendant n'importe quel <span class="emphasis">FETCH</span>. <span class="emphasis">FETCH ABSOLUTE</span> n'est pas pris en charge par les curseurs <span class="emphasis">DYNAMIC</span>.  <span class="emphasis">FAST_FORWARD</span> est un raccourci pour <span class="emphasis">FORWARD_ONLY</span>, <span class="emphasis">READ_ONLY</span>, mais il offre aussi des fonctionnalit&eacute;s suppl&eacute;mentaires.  <span class="emphasis">FAST_FORWARD</span> et <span class="emphasis">SCROLL</span>, <span class="emphasis">FOR_UPDATE</span>, <span class="emphasis">SCROLL_LOCKS</span>, <span class="emphasis">OPTIMISTIC</span> et <span class="emphasis">FORWARD_ONLY</span> sont mutuellement exclusifs.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Deux autres options sont &eacute;galement permises pour <span class="emphasis">READ_ONLY</span>:  <span class="emphasis">SCROLL_LOCKS</span> et <span class="emphasis">OPTIMISTIC</span>. <span class="emphasis">SCROLL_LOCKS</span> impose un verrou au niveau des enregistrements chaque fois qu'un nouvel enregistrement est extrait. Ceci permet d'assurer que les mises &agrave; jour et les effacements ex&eacute;cut&eacute;s via le curseur sont effectifs.  <span class="emphasis">OPTIMISTIC</span> implique que les mises &agrave; jour et les effacements positionn&eacute;s ex&eacute;cut&eacute;s via le curseur &eacute;chouent si la ligne est modifi&eacute;e par un autre utilisateur.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Enfin, l'option <span class="emphasis">TYPE_WARNING</span> demande &agrave; SQL Server d'envoyer un message d'avertissement au client si le curseur passe d'un type &agrave; un autre (par exemple, de <span class="emphasis">KEYSET</span> &agrave; <span class="emphasis">DYNAMIC)</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans ce simple exemple tir&eacute; de Microsoft SQL Server, un curseur de la table <span class="emphasis">publishers</span> est d&eacute;clar&eacute; et ouvert. Le curseur prend le premier enregistrement de <span class="emphasis">publisher</span> qui correspond &agrave; l'instruction <span class="emphasis">SELECT</span> et l'ins&egrave;re dans une autre table, puis passe &agrave; l&acute;enregistrement suivant, puis au suivant et ainsi de suite, jusqu&acute;&agrave; ce que tous les enregistrements aient &eacute;t&eacute; trait&eacute;s. Alors, le curseur est ferm&eacute; et lib&eacute;r&eacute; (<span class="emphasis">deallocate</span> ne s'utilise que dans Microsoft SQL Server):</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DECLARE @publisher_name VARCHAR(20)DECLARE pub_cursor CURSORFOR SELECT pub_name FROM publishers  WHERE country &lt;&gt; 'USA'OPEN pub_cursorFETCH NEXT FROM pub_cursor INTO @publisher_nameWHILE @@FETCH_STATUS = 0BEGIN  INSERT INTO foreign_publishers VALUES(@publisher_name)ENDCLOSE pub_cursorDEALLOCATE pub_cursor</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans cet exemple tir&eacute; d'Oracle, le curseur est d&eacute;clar&eacute; avec d'autres variables dans le bloc de d&eacute;claration, puis le reste du curseur est trait&eacute;:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DECLARE  new_price NUMBER(10,2);  CURSOR title_price_cursor IS   SELECT title, price   FROM titles   WHERE price IS NOT NULL;  title_price_val title_price_cursor%ROWTYPE;BEGIN  OPEN title_price_cursor;  FETCH title_price_cursor INTO title_price_val;  new_price:= "title_price_val.price" * 1.25  INSERT INTO new_title_price VALUES (title_price_val.title, new_price)  CLOSE title_price_cursor;END;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Comme cet exemple utilise beaucoup de PL/SQL, une grande partie du code d&eacute;passe le cadre de cet ouvrage. Cependant, le bloc <span class="emphasis">DECLARE</span> montre clairement que le curseur est d&eacute;clar&eacute;. Dans le bloc d'ex&eacute;cution PL/SQL, le curseur est initialis&eacute; avec la commande <span class="emphasis">OPEN</span>, les valeurs sont r&eacute;cup&eacute;r&eacute;es avec la commande <span class="emphasis">FETCH</span>, et enfin, le curseur est lib&eacute;r&eacute; avec la commande <span class="emphasis">CLOSE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="DELETE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">DELETE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L'instruction <span class="emphasis">DELETE</span> efface les enregistrements d'une ou de plusieurs tables d&eacute;sign&eacute;es. L'op&eacute;ration est inscrite au journal, ce qui signifie qu'elle peut &ecirc;tre annul&eacute;e avec une commande <span class="emphasis">ROLLBACK</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>On &eacute;met rarement une instruction <span class="emphasis">DELETE</span> sans une clause <span class="emphasis">WHERE</span>, parce que cela aurait pour effet d'effacer <span class="emphasis">toutes</span> les lignes de la table concern&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DELETE [FROM] [owner.]table_name [WHERE clause]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>S'il s'av&egrave;re n&eacute;cessaire d'effacer toutes les lignes d'une table, il est pr&eacute;f&eacute;rable d'utiliser l'instruction <span class="emphasis">TRUNCATE TABLE</span>. Dans les bases de donn&eacute;es qui reconnaissent cette commande, c'est souvent une m&eacute;thode plus rapide pour retirer physiquement toutes les lignes. <span class="emphasis">TRUNCATE TABLE</span> est plus rapide que <span class="emphasis">DELETE</span> parce que <span class="emphasis">TRUNCATE</span> n'est pas inscrit au journal, ce qui rend l'annulation impossible. Le simple fait de supprimer l'inscription au journal permet de gagner un temps consid&eacute;rable lors de l'effacement d'un grand nombre d&acute;enregistrements.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DELETE [FROM] [owner.] {table_name | view_name}[WITH (query_hint[,...n]][FROM table_source[,...n]][WHERE clause | [CURRENT OF [GLOBAL] cursor_name]][OPTION (query_hint[,...n])]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server permet d'effacer des enregistrements aussi bien des tables que des vues correspondant &agrave; une table unique. Certaines r&egrave;gles permettent d'effacer les enregistrements d'une vue multitable, mais elles sont assez complexes, et d&eacute;passent le cadre de cet ouvrage. A deux endroits dans la commande, apr&egrave;s le premier <span class="emphasis">FROM</span> et &agrave; la fin de l'instruction, il est possible d'outrepasser le comportement par d&eacute;faut de l'optimiseur de SQL Server, mais cette man&oacute;uvre devrait &ecirc;tre r&eacute;serv&eacute;e aux experts. Ces conseils ne figurent pas dans la norme ANSI, mais on les trouve dans la documentation de la plupart des &eacute;diteurs.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>En outre, SQL Server permet une seconde clause <span class="emphasis">FROM</span>. Ce second <span class="emphasis">FROM</span> permet l'utilisation de l'instruction <span class="emphasis">JOIN</span> et facilite l'effacement de lignes dans le premier <span class="emphasis">FROM</span> (en se basant sur les lignes correspondantes d'une table d&eacute;clar&eacute;e dans le second <span class="emphasis">FROM</span>).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">WHERE CURRENT OF</span> est utilis&eacute;e pour positionner les effacements via un curseur. De concert avec le curseur, cette forme de <span class="emphasis">DELETE</span> n'efface que la ligne ouverte dans le curseur.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans MySQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DELETE [LOW_PRIORITY] FROM table_name [WHERE clause] [LIMIT rows]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>MySQL est optimis&eacute; pour une plus grande vitesse. Dans cette optique, il permet de pr&eacute;ciser <span class="emphasis">LOW PRIORITY</span>, ce qui retarde l'ex&eacute;cution de <span class="emphasis">DELETE</span> jusqu&acute;&agrave; ce que la table ne soit plus consult&eacute;e par d'autres clients. MySQL peut aussi limiter arbitrairement le nombre d&acute;enregistrements qu'il efface avant de rendre le contr&ocirc;le au client, via la clause <span class="emphasis">LIMIT nbr_of_rows</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DELETE FROM [schema.]{table_name | view_name | snapshot_name}  {PARTITION (partition_name) | SUBPARTITION (subpartition_name)} |[WHERE clause][subquery WITH {READ ONLY | CHECK OPTION [CONSTRAINT constraint_name]} ][RETURNING expression[,...] INTO variable[,...]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet d'effacer des lignes des tables et des vues simples, ainsi que des tables et des vues partitionn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p> <span class="emphasis">PARTITION</span> et <span class="emphasis">SUBPARTITION</span> indiquent le nom de la partition ou de la sous-partition &agrave; effacer au sein de la table.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">WITH</span> est utilis&eacute;e en conjonction avec une sous-requ&ecirc;te. Elle limite les actions de l'instruction <span class="emphasis">DELETE</span>. L'option <span class="emphasis">WITH READ ONLY</span> pr&eacute;cise que les sous-requ&ecirc;tes utilis&eacute;es dans la commande ne peuvent pas &ecirc;tre mises &agrave; jour. <span class="emphasis">WITH CHECK OPTION</span> demande &agrave; Oracle d'effacer (<span class="emphasis">DELETE</span>) toute ligne ne figurant pas dans la sous-requ&ecirc;te.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">RETURNING</span> extrait les lignes affect&eacute;es par la commande. Quand elle est utilis&eacute;e pour effacer une seule ligne, les valeurs de la ligne sont stock&eacute;es dans des variables PL/SQL et des variables attach&eacute;es. Quand elle est utilis&eacute;e pour effacer plusieurs lignes, les valeurs des lignes sont stock&eacute;es dans des tableaux attach&eacute;s. Le mot-cl&eacute; <span class="emphasis">INTO</span> signifie que les valeurs effac&eacute;es doivent &ecirc;tre stock&eacute;es dans la liste de variables.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DELETE FROM [ONLY] <span class="replaceable">table</span>[WHERE {clause | CURRENT OF cursor_name}]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL utilise la commande <span class="emphasis">DELETE</span> pour effacer des lignes et des sous-classes d&eacute;finies de la table. Pour n'effacer de lignes que de la table d&eacute;sign&eacute;e, il faut utiliser la clause <span class="emphasis">ONLY</span>. La clause <span class="emphasis">WHERE CURRENT OF</span> demande &agrave; PostgreSQL de n'effacer que la ligne actuellement ouverte du curseur en cours.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour effacer tous les enregistrements de la table <span class="emphasis">titles</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DELETE titles</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour effacer tous les enregistrements dont le nom de famille commence par &laquo;&#160; Mc&#160;&raquo; de la table <span class="emphasis">authors</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DELETE FROM authorsWHERE au_lname LIKE 'Mc%'</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour effacer tous les titres dot&eacute;s d'un code d'identification obsol&egrave;te:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DELETE titles WHERE title_id &gt;= 40</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour effacer tous les titres qui ne se vendent pas:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DELETE titles WHERE ytd_sales IS NULL</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour effacer tous les enregistrements d'une table sur la base des r&eacute;sultats d'une sous-requ&ecirc;te sur une autre table (dans le cas pr&eacute;sent, tous les enregistrements de la table <span class="emphasis">titleauthor</span> qui correspondent &agrave; des enregistrements portant sur le sujet &laquo;&#160; ordinateurs&#160;&raquo; dans la table <span class="emphasis">titles</span> sont effac&eacute;s):</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DELETE FROM titleauthorWHERE title_id IN (SELECT title_id FROM titles WHERE title LIKE '%computers%')</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="DISCONNECT">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">DISCONNECT</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">DISCONNECT</span> met fin &agrave; une connexion au SGBD.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des limites</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DISCONNECT {CURRENT | ALL | connection_name}</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette commande permet de mettre fin &agrave; une ou plusieurs connexions cr&eacute;&eacute;es entre le processus SQL en cours et le serveur de base de donn&eacute;es. La clause <span class="emphasis">CURRENT</span> ferme la connexion utilisateur active. La clause <span class="emphasis">ALL</span> ferme toutes les connexions ouvertes pour l&acute;utilisateur actuel. Vous pouvez aussi fermer uniquement une connexion sp&eacute;cifique.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server prend uniquement en charge <span class="emphasis">DISCONNECT</span> dans Embedded-SQL (ESQL), mais pas dans son outil de requ&ecirc;te ponctuel, SQL Query Analyzer. Il prend en charge la syntaxe SQL99 compl&egrave;te. Lorsque vous quittez Microsoft SQL Server dans un programme ESQL, vous devez veiller &agrave; utiliser la commande <span class="emphasis">DISCONNECT ALL</span> pour assurer une d&eacute;connexion correcte du serveur de base de donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DISC[ONNECT]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Contrairement &agrave; SQL Server, Oracle autorise <span class="emphasis">uniquement</span> l&acute;emploi de la commande <span class="emphasis">DISCONNECT</span> dans son outil de requ&ecirc;te ponctuel, SQL*Plus. Dans ce cas, la commande met fin &agrave; la session en cours avec le serveur de base de donn&eacute;es; cependant, elle permet la poursuite des op&eacute;rations dans SQL*Plus. Par exemple, un programmeur peut continuer &agrave; modifier la m&eacute;moire tampon, &agrave; enregistrer des fichiers d&acute;ex&eacute;cution, et ainsi de suite. Une nouvelle connexion est toutefois n&eacute;cessaire pour pouvoir utiliser les commandes SQL. Les commandes <span class="emphasis">EXIT</span> ou <span class="emphasis">QUIT</span> sont n&eacute;cessaires pour quitter SQL*Plus et revenir au syst&egrave;me de fichiers.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle prend &eacute;galement en charge cette fonctionnalit&eacute; avec la commande <span class="emphasis">ALTER SYSTEM DISCONNECT SESSION</span>. Il s&acute;agit cependant d&acute;une commande sp&eacute;ciale que seul l&acute;administrateur de base de donn&eacute;es peut employer pour imposer la d&eacute;connexion d&acute;une session (souvent ext&eacute;rieure) &agrave; la base de donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL ne prend pas explicitement en charge la commande DISCONNECT. Cependant, les interfaces de programmation prennent toujours en charge une op&eacute;ration de d&eacute;connexion; par exemple, SPI_FINISH dans la Server Programming Interface ou PG_CONNECT dans l'outil de programmation PL/tcl.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour mettre fin &agrave; la connexion en cours &agrave; un serveur Oracle:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DISCONNECT;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server prend uniquement en charge la commande <span class="emphasis">DISCONNECT</span> dans les programmes ESQL:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>EXEC SQL DISCONNECT new_york;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="DROP DATABASE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">DROP DATABASE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p><span class="emphasis">DROP DATABASE</span> annule toutes les op&eacute;rations ex&eacute;cut&eacute;es au moyen de la commande <span class="emphasis">CREATE DATABASE</span> . Cette instruction &eacute;limine tous les objets de la base de donn&eacute;es et lib&egrave;re l&acute;espace qu&acute;ils occupaient. La plupart des &eacute;diteurs ne permettent pas l&acute;ex&eacute;cution de cette commande lorsque des utilisateurs (le propri&eacute;taire, notamment) effectuent des op&eacute;rations sur la base de donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Non prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP DATABASE database_name</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>A l&acute;instar de <span class="emphasis">CREATE DATABASE</span>, la commande <span class="emphasis">DROP DATABASE</span> est uniquement prise en charge par ANSI SQL en tant qu&acute;extension (mais non en tant que commande de base). SQL99 utilise de pr&eacute;f&eacute;rence les commandes relatives &agrave; <span class="emphasis">SCHEMA</span> et <span class="emphasis">DOMAIN</span> pour couvrir les domaines correspondant en gros &agrave; ce que les impl&eacute;mentations assimilent g&eacute;n&eacute;ralement &agrave; des questions de &laquo;&#160;base de donn&eacute;es&#160;&#160;».</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Vous ne devez jamais supprimer les bases de donn&eacute;es syst&egrave;me cr&eacute;&eacute;es par l&acute;&eacute;diteur. A moins d&acute;&ecirc;tre ex&eacute;cut&eacute; par le propri&eacute;taire de la base de donn&eacute;es ou l&acute;administrateur syst&egrave;me, l&acute;&eacute;limination d&acute;une base de donn&eacute;es exige des permissions explicites.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP DATABASE database_name [,...n]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>SQL Server permet d&acute;&eacute;liminer plusieurs bases de donn&eacute;es en m&ecirc;me temps; il vous suffit de s&eacute;parer leur nom par une virgule. Seuls un utilisateur de la base de donn&eacute;es master, un utilisateur poss&eacute;dant les privil&egrave;ges de l&acute;administrateur syst&egrave;me ou le propri&eacute;taire de la base de donn&eacute;es peuvent &eacute;liminer une base de donn&eacute;es. L&acute;&eacute;limination est uniquement possible avec les bases de donn&eacute;es de type <span class="emphasis">ONLINE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans MySQL et PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans MySQL et PostgreSQL, cette commande supprime int&eacute;gralement la base de donn&eacute;es et tous les fichiers associ&eacute;s. La base de donn&eacute;es envoie un message indiquant le nombre de fichiers qui ont &eacute;t&eacute; supprim&eacute;s. Il est impossible de supprimer une base de donn&eacute;es ouverte et en cours d&acute;utilisation dans le cadre de l&acute;impl&eacute;mentation PostgreSQL.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle ne prend pas en charge la commande <span class="emphasis">DROP DATABASE</span>. La suppression d&acute;une base de donn&eacute;es exige l&acute;&eacute;mission de la commande <span class="emphasis">CREATE DATABASE database_name</span> (sans aucun param&egrave;tre), dans laquelle database_name correspond au nom de la base de donn&eacute;es que vous voulez supprimer.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="DROP FUNCTION">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">DROP FUNCTION </td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>Cette commande &eacute;limine de la base de donn&eacute;es active une fonction d&eacute;finie par l&acute;utilisateur.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP FUNCTION function_name {RESTRICT | CASCADE}</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette commande permet de supprimer d&eacute;finitivement une fonction. La clause <span class="emphasis">RESTRICT</span> entra&icirc;ne toujours l&acute;&eacute;chec de la commande si d&acute;autres objets de la base de donn&eacute;es (une vue, par exemple), d&eacute;pendent de la fonction en question. En revanche, l&acute;option <span class="emphasis">CASCADE</span> &eacute;limine la fonction, les droits reposant sur cette fonction et les objets de base de donn&eacute;es connexes&#160;!</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP FUNCTION [owner_name.]function_name [,...n]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Comme avec les autres commandes <span class="emphasis">DROP</span> de SQL Server, il est possible d&acute;&eacute;liminer plusieurs objets de base de donn&eacute;es du m&ecirc;me type en s&eacute;parant leur nom par une virgule.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans MySQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette commande ne supprime pas le fichier qui contient la fonction. En revanche, elle supprime la r&eacute;f&eacute;rence &agrave; cette fonction de la table syst&egrave;me; l&acute;instruction <span class="emphasis">CREATE FUNCTION</span> permet de restaurer cette r&eacute;f&eacute;rence.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP FUNCTION [owner_name.]function_name</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Comme avec les autres commandes <span class="emphasis">DROP</span> d&acute;Oracle, il est possible de sp&eacute;cifier le nom du propri&eacute;taire de la fonction. Sinon, Oracle consid&egrave;re que la suppression porte uniquement sur le contexte utilisateur courant, ainsi que sur les fonctions que cet utilisateur poss&egrave;de. En outre, les utilisateurs qui disposent du privil&egrave;ge syst&egrave;me <span class="emphasis">DROP ANY FUNCTION</span> peuvent supprimer n&acute;importe quelle fonction, &agrave; tout emplacement.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP FUNCTION name ( [ type [,...n] ] )</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL permet de supprimer les fonctions d&eacute;clar&eacute;es dans n&acute;importe quel langage de programmation. <span class="emphasis">Type</span> repr&eacute;sente l&acute;argument d&acute;entr&eacute;e de la fonction &agrave; supprimer. Il faut sp&eacute;cifier le type, puisque seule la fonction poss&eacute;dant le nom et les types de param&egrave;tres indiqu&eacute;s sera supprim&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="DROP INDEX">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">DROP INDEX</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">DROP INDEX</span> supprime un ou plusieurs index dans la base de donn&eacute;es active. Lorsqu&acute;un index est &eacute;limin&eacute;, l&acute;espace qu&acute;il occupait est imm&eacute;diatement r&eacute;cup&eacute;r&eacute;. Cependant, <span class="emphasis">DROP INDEX</span> ne supprime pas les contraintes <span class="emphasis">PRIMARY KEY</span> ou <span class="emphasis">UNIQUE</span>, pour lesquelles il faut utiliser la commande <span class="emphasis">ALTER TABLE . . . DROP</span>. Reportez-vous &agrave; la commande <span class="emphasis">CREATE TABLE</span> pour de plus amples informations sur les contraintes uniques et les contraintes de cl&eacute; primaire.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP INDEX table_name.index_name</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL respecte la norme SQL99, avec certaines variations.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP INDEX {table_name | view_name}.index_name [,...n]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server permet d&acute;&eacute;liminer les index cr&eacute;&eacute;s aussi bien dans les tables que dans les vues. Lorsqu&acute;un index clusteris&eacute; est &eacute;limin&eacute; dans une table qui contient &eacute;galement des index non clusteris&eacute;s, ces derniers sont recr&eacute;&eacute;s et ils re&ccedil;oivent de nouveaux pointeurs.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans MySQL </span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP INDEX table_name.index_name [,...n]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les anciennes versions de MySQL incluent uniquement cette commande pour des raisons de compatibilit&eacute;; en revanche, les nouvelles versions permettent de supprimer l&acute;index sp&eacute;cifi&eacute;. D'un point de vue fonctionnel, cette instruction est &eacute;quivalente &agrave; l&acute;instruction <span class="emphasis">ALTER TABLE . . . DROP INDEX</span> de MySQL.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>MySQL permet de supprimer plusieurs index; il suffit pour ce faire de s&eacute;parer par une virgule les noms de table et d&acute;index.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP INDEX [owner_name.]index_name</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet d&acute;&eacute;liminer directement les index en fonction de leur nom (il est inutile d&acute;indiquer le nom de la table). Oracle permet &eacute;galement de d&acute;&eacute;liminer l&acute;index sur la base du nom du propri&eacute;taire.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="DROP PROCEDURE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">DROP PROCEDURE </td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p> Cette commande permet de supprimer une proc&eacute;dure stock&eacute;e dans la base de donn&eacute;es utilisateur active.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP PROCEDURE procedure_name {RESTRICT | CASCADE}</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette commande est pratiquement similaire &agrave; <span class="emphasis">DROP FUNCTION</span>, sauf qu&acute;elle s&acute;applique aux proc&eacute;dures stock&eacute;es, et non aux fonctions.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP PROCEDURE [owner_name.]procedure_name [,...n]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server permet de supprimer plusieurs proc&eacute;dures stock&eacute;es en m&ecirc;me temps; il suffit pour ce faire de s&eacute;parer leur nom par une virgule. Il est impossible d&acute;&eacute;liminer des proc&eacute;dures individuelles; seul le groupe entier de proc&eacute;dures stock&eacute;es peut &ecirc;tre supprim&eacute;.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP PROCEDURE [owner_name.]procedure_name</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet &eacute;galement d&acute;&eacute;liminer n&acute;importe quelle proc&eacute;dure sur la base du nom de son propri&eacute;taire. Les utilisateurs qui disposent du privil&egrave;ge syst&egrave;me <span class="emphasis">DROP ANY PROCEDURE</span> peuvent &eacute;liminer les proc&eacute;dures que les autres utilisateurs poss&egrave;dent.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="DROP ROLE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">DROP ROLE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>Cette commande permet de supprimer un ensemble nomm&eacute; de privil&egrave;ges utilisateur dans la base de donn&eacute;es utilisateur active.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Non prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP ROLE role_name</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">DROP ROLE</span> supprime le r&ocirc;le sp&eacute;cifi&eacute;. Seuls les utilisateurs disposant du privil&egrave;ge <span class="emphasis">WITH ADMIN OPTION</span> peuvent supprimer des r&ocirc;les.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP ROLE [owner_name.]role_name;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;ex&eacute;cution de la commande <span class="emphasis">DROP ROLE</span> supprime le r&ocirc;le dans la base de donn&eacute;es utilisateur active. Les utilisateurs ou les r&ocirc;les auxquels ce r&ocirc;le sp&eacute;cifique &eacute;tait pr&eacute;c&eacute;demment attribu&eacute; ne pourront plus l&acute;employer.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="DROP TABLE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">DROP TABLE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>Cette commande permet de supprimer une d&eacute;finition de table, ainsi que tous les index, donn&eacute;es, triggers, contraintes et sp&eacute;cifications de permissions connexes. Les vues ou proc&eacute;dures stock&eacute;es qui font r&eacute;f&eacute;rence &agrave; la table &eacute;limin&eacute;e rencontreront des probl&egrave;mes, sauf si elles sont explicitement modifi&eacute;es ou &eacute;limin&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour certains &eacute;diteurs, il faut d&acute;abord supprimer d&acute;autres caract&eacute;ristiques sp&eacute;cifiques de la table pour pouvoir &eacute;liminer celle-ci. Dans Microsoft SQL Server, par exemple, il faut supprimer la table dans les sch&eacute;mas de r&eacute;plication et les r&eacute;f&eacute;rences <span class="emphasis">FOREIGN KEY</span> avant de pouvoir &eacute;liminer la table &agrave; proprement parler.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP TABLE table_name RESTRICT | CASCADE</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans la syntaxe SQL99, <span class="emphasis">RESTRICT</span> ne permet pas au SGBD d&acute;ex&eacute;cuter la commande si des vues ou des contraintes font r&eacute;f&eacute;rence &agrave; la table &agrave; &eacute;liminer. La clause <span class="emphasis">CASCADE</span> permet de supprimer tous les objets r&eacute;f&eacute;ren&ccedil;ants avec la table.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP TABLE [database_name.][owner_name.]table_name [,...n]GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server permet d&acute;&eacute;liminer plusieurs tables en m&ecirc;me temps; il suffit de ce faire de s&eacute;parer leur nom par une virgule. Il permet &eacute;galement de supprimer des tables dans les bases de donn&eacute;es, en dehors de leur contexte actuel; il convient pour ce faire sp&eacute;cifier le nom de la base de donn&eacute;es (cette op&eacute;ration suppose que l&acute;utilisateur dispose des permissions appropri&eacute;es). Les contraintes ou les triggers associ&eacute;s &agrave; la table sont &eacute;limin&eacute;s avec cette derni&egrave;re. Les valeurs par d&eacute;faut et les r&egrave;gles explicitement d&eacute;clar&eacute;es perdent leurs liaisons lorsque leur table sous-jacente est &eacute;limin&eacute;e. Les vues et les proc&eacute;dures stock&eacute;es qui font r&eacute;f&eacute;rence &agrave; la table &eacute;limin&eacute;e renvoient une erreur lorsque la table reste introuvable pendant leur ex&eacute;cution.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans MySQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP TABLE [IF EXISTS] table_name;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>MySQL supprime d&eacute;finitivement l&acute;int&eacute;gralit&eacute; de la table et tous les fichiers associ&eacute;s &agrave; l&acute;ex&eacute;cution de cette commande. L&acute;ajout de la syntaxe <span class="emphasis">IF EXISTS</span> permet de pr&eacute;venir le renvoi d&acute;un message d&acute;erreur susceptible de s&acute;afficher lorsque l&acute;utilisateur essaie de supprimer une table qui n&acute;existe peut-&ecirc;tre pas.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP TABLE [owner_name.]table_name [CASCADE CONSTRAINTS];</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Oracle, l&acute;&eacute;limination d&acute;une table lib&egrave;re l&acute;espace qu&acute;elle occupait et valide les modifications en attentedans la base de donn&eacute;es. Lorsqu&acute;une table est &eacute;limin&eacute;e, l&acute;espace qu&acute;elle occupait est imm&eacute;diatement r&eacute;cup&eacute;r&eacute;. Les index et les droits associ&eacute;s &agrave; cette table sont perdus. Les objets cr&eacute;&eacute;s &agrave; partir de la table (vues, proc&eacute;dures stock&eacute;es et synonymes, notamment), sont marqu&eacute;s comme non valides et ils cessent de fonctionner.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>N&acute;oubliez pas que, dans Oracle, l&acute;ex&eacute;cution d&acute;une commande <span class="emphasis">ALTER</span>, <span class="emphasis">CREATE</span> ou <span class="emphasis">DROP</span> entra&icirc;ne la validation des autres transactions en attente.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">CASCADE CONSTRAINTS</span> supprime toutes les contraintes d&acute;int&eacute;grit&eacute; renvoyant aux cl&eacute;s de la table &eacute;limin&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP TABLE table_name;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL prend uniquement en charge la commande <span class="emphasis">DROP TABLE</span> de base.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="DROP TRIGGER">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">DROP TRIGGER</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">DROP TRIGGER</span> supprime un trigger associ&eacute; &agrave; une table de la base de donn&eacute;es active.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP TRIGGER trigger_name</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">DROP TRIGGER</span> supprime un trigger de la base de donn&eacute;es active. MySQL ne prend pas cette commande en charge.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP TRIGGER [owner_name.]trigger_name [,...n]GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server permet d&acute;&eacute;liminer plusieurs triggers en m&ecirc;me temps; il suffit pour ce faire de s&eacute;parer leur nom par une virgule.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP TRIGGER [owner_name.]trigger_name;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle &eacute;limine le trigger sp&eacute;cifi&eacute; et valide les modifications en attente dans la base de donn&eacute;es lors de l&acute;ex&eacute;cution de cette commande.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP TRIGGER trigger_name ON table_name;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL exige que la table contenant le trigger soit nomm&eacute;e. Il &eacute;limine alors toutes les r&eacute;f&eacute;rences &agrave; un trigger existant lors de l&acute;ex&eacute;cution de cette commande.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="DROP VIEW">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">DROP VIEW</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>Cettesupprime d&eacute;finitivement une vue de la base de donn&eacute;es active.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP VIEW view_name RESTRICT | CASCADE</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans la syntaxe SQL99, <span class="emphasis">RESTRICT</span> indique au SGBD d&acute;interdire l&acute;&eacute;limination si des vues ou des affirmations font r&eacute;f&eacute;rence &agrave; la table &agrave; supprimer. La clause <span class="emphasis">CASCADE</span> permet d&acute;&eacute;liminer tous les objets r&eacute;f&eacute;ren&ccedil;ants avec la vue.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette commande n&acute;est pas prise en charge par MySQL pour le moment.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP VIEW [owner_name.]view_name [,...n]GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server permet de supprimer plusieurs vues en m&ecirc;me temps; il suffit pour ce faire de s&eacute;parer leur nom par une virgule. Les vues doivent appartenir &agrave; la m&ecirc;me base de donn&eacute;es. Les informations concernant cette vue sont supprim&eacute;es de toutes les tables syst&egrave;me.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP VIEW [owner_name.]view_name;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>A l&acute;instar des autres commandes <span class="emphasis">DROP</span> d&acute;Oracle, cette commande permet de sp&eacute;cifier le nom du propri&eacute;taire avec le nom de la vue. Les utilisateurs qui disposent du privil&egrave;ge syst&egrave;me <span class="emphasis">DROP ANY VIEW</span> peuvent &eacute;liminer les vues que les autres utilisateurs poss&egrave;dent.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DROP VIEW view_name;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans PostgreSQL, la commande <span class="emphasis">DROP VIEW</span> &eacute;limine une vue existante de la base de donn&eacute;es active. Seul le propri&eacute;taire de la vue peut l&acute;&eacute;liminer. La commande <span class="emphasis">DROP TABLE</span> de PostgreSQL  permet &eacute;galement d&acute;&eacute;liminer des vues.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="FETCH">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">FETCH</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">FETCH</span> est l&acute;une des quatre commandes applicables aux processus de curseur. <span class="emphasis">FETCH</span> r&eacute;cup&egrave;re une ligne sp&eacute;cifique d&acute;un curseur serveur.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">FETCH</span> r&eacute;cup&egrave;re un enregistrement &agrave; partir du <span class="emphasis">cursor_name</span> (cr&eacute;&eacute; par l&acute;instruction <span class="emphasis">DECLARE CURSOR</span>), sur la base du mot-cl&eacute; <span class="emphasis">NEXT</span>, <span class="emphasis">PRIOR</span>, <span class="emphasis">FIRST</span>, <span class="emphasis">LAST</span>, <span class="emphasis">ABSOLUTE</span> ou <span class="emphasis">RELATIVE</span>. Les valeurs r&eacute;cup&eacute;r&eacute;es par l&acute;instruction <span class="emphasis">FETCH</span> peuvent &ecirc;tre stock&eacute;es dans des variables. Les op&eacute;rations <span class="emphasis">FETCH</span> sont les suivantes:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ul><li><i><span class="emphasis">NEXT </span></i><br>&#160;						  Indique au curseur de revenir &agrave; l&acute;enregistrement qui suit directement la ligne active, et incr&eacute;mente cette derni&egrave;re sur la ligne renvoy&eacute;e. <span class="emphasis">FETCH NEXT</span> est le comportement par d&eacute;faut de <span class="emphasis">FETCH</span>: cette instruction r&eacute;cup&egrave;re le premier enregistrement s&acute;il est ex&eacute;cut&eacute; en tant que premi&egrave;re extraction pour un curseur. (PostgreSQL utilise le mot-cl&eacute; <span class="emphasis">FORWARD</span> ou la cha&icirc;ne <span class="emphasis">FETCH RELATIVE NEXT.</span>)</li><li><i><span class="emphasis">PRIOR </span></i><br>&#160;						  Indique au curseur de revenir &agrave; l&acute;enregistrement qui pr&eacute;c&egrave;de directement la ligne active, et d&eacute;cr&eacute;mente cette derni&egrave;re sur la ligne renvoy&eacute;e. <span class="emphasis">FETCH PRIOR</span> ne r&eacute;cup&egrave;re pas d&acute;enregistrement si ce dernier est ex&eacute;cut&eacute; en tant que premi&egrave;re extraction pour un curseur. (PostgreSQL utilise le mot-cl&eacute; <span class="emphasis">BACKWARD</span> ou la cha&icirc;ne <span class="emphasis">FETCH RELATIVE PRIOR</span>.)</li><li><i><span class="emphasis">FIRST </span></i><br>&#160;						  Indique au curseur de revenir &agrave; son premier enregistrement pour en faire la ligne active. (Cette op&eacute;ration n&acute;est pas prise en charge par PostgreSQL.)</li><li><i><span class="emphasis">LAST</span></i><br>&#160;						  Indique au curseur de revenir &agrave; son dernier enregistrement pour en faire la ligne active. (Cette op&eacute;ration n&acute;est pas prise en charge par PostgreSQL.)</li><li><i><span class="emphasis">ABSOLUTE</span> { n } </i><br>&#160;						  Indique au curseur de renvoyer le ne enregistrement du jeu d&acute;enregistrements du curseur, &agrave; partir du d&eacute;but (si n est positif) ou de la fin (si n est n&eacute;gatif); l&acute;enregistrement renvoy&eacute; deviendra ainsi le nouvel enregistrement du curseur. Si n est &eacute;gal &agrave; 0, aucune ligne n&acute;est renvoy&eacute;e. (Cette op&eacute;ration n&acute;est pas prise en charge par PostgreSQL.)</li><li><i><span class="emphasis">RELATIVE</span> { n } </i><br>&#160;						  Indique au curseur de renvoyer les n lignes de l&acute;enregistrement qui suivent (si n est positif) ou pr&eacute;c&egrave;dent (si n est n&eacute;gatif) l&acute;enregistrement; l&acute;enregistrement renvoy&eacute; deviendra ainsi le nouvel enregistrement du curseur. Si n est &eacute;gal &agrave; 0, la ligne active est renvoy&eacute;e. (Cette op&eacute;ration est prise en charge conform&eacute;ment &agrave; la description de PostgreSQL, sauf si n est &eacute;gal &agrave; 0.)</li></ul>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le mot-cl&eacute; <span class="emphasis">INTO</span> permet de placer dans une variable locale les donn&eacute;es provenant de chacune des colonnes de la commande <span class="emphasis">FETCH</span>. Chaque colonne de la commande <span class="emphasis">FETCH</span> est associ&eacute;e &agrave; une variable de type de donn&eacute;es correspondant dans la clause <span class="emphasis">INTO</span>. (<span class="emphasis">INTO</span> n&acute;est pas prise en charge par PostgreSQL.)</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les curseurs PostgreSQL sont uniquement utilis&eacute;s dans les transactions explicitement d&eacute;clar&eacute;es, au moyen de <span class="emphasis">BEGIN</span>, <span class="emphasis">COMMIT</span> ou <span class="emphasis">ROLLBACK</span>. PostgreSQL permet de r&eacute;cup&eacute;rer un nombre sp&eacute;cifique ou la totalit&eacute; des enregistrements; il suffit pour ce faire d&acute;indiquer le nombre voulu ou le mot-cl&eacute; <span class="emphasis">ALL</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>FETCH cursor_name{INTO variable_name1 [,...n] ]| BULK COLLECT INTO [collection_name [,...n] }</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les curseurs Oracle sont des curseurs en avant seulement. Ils doivent soit ins&eacute;rer les valeurs r&eacute;cup&eacute;r&eacute;es dans les variables correspondantes, soit, au moyen de la clause <span class="emphasis">BULK COLLECT</span>, appliquer une liaison globale &agrave; la sortie avant de la renvoyer &agrave; l&acute;analyseur PL/SQL. La commande <span class="emphasis">FETCH</span> est souvent associ&eacute;e &agrave; une boucle <span class="emphasis">FOR</span> PL/SQL pour traiter l&acute;ensemble des lignes du curseur.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>FETCH [ FORWARD | BACKWARD | RELATIVE [ { [ # | ALL | NEXT | PRIOR ] } ]  ][ count ]FROM <span class="replaceable">cursor_name</span></pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les curseurs PostgreSQL sont uniquement utilis&eacute;s dans les transactions explicitement d&eacute;clar&eacute;es, au moyen de <span class="emphasis">BEGIN</span>, <span class="emphasis">COMMIT</span> ou <span class="emphasis">ROLLBACK</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le curseur peut avoir un d&eacute;filement de type <span class="emphasis">FORWARD</span>, <span class="emphasis">BACKWARD</span> ou <span class="emphasis">RELATIVE</span>. La clause <span class="emphasis">RELATIVE</span> peut inclure tout ou partie des enregistrements &agrave; r&eacute;cup&eacute;rer; cette indication est signal&eacute;e par un nombre ou par le mot-cl&eacute; <span class="emphasis">ALL</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;exemple Oracle qui suit r&eacute;cup&egrave;re plusieurs &eacute;l&eacute;ments de <span class="emphasis">employee_new_hires_cursor</span> (reportez-vous &agrave; l&acute;exemple sous <span class="emphasis">DECLARE CURSOR</span>) dans plusieurs variables locales:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>FETCH FROM employee_new_hires_cursorINTO: emp_id,:fname,:lname,:job_id</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La commande PostgreSQL qui suit r&eacute;cup&egrave;re cinq enregistrements de la table <span class="emphasis">employee</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>FETCH FORWARD 5 IN employee_new_hires_cursor;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="GRANT">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">GRANT</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>Dans SQL99, l&acute;instruction <span class="emphasis">GRANT</span>  permet aux utilisateurs et aux r&ocirc;les d&acute;acc&eacute;der aux objets de base de donn&eacute;es et de les utiliser. De plus, les &eacute;diteurs de base de donn&eacute;es utilisent g&eacute;n&eacute;ralement l&acute;instruction <span class="emphasis">GRANT</span> pour permettre aux utilisateurs et aux r&ocirc;les de cr&eacute;er des objets et d&acute;ex&eacute;cuter des proc&eacute;dures stock&eacute;es, des fonctions, et ainsi de suite.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>GRANT { ALL [PRIVILEGES] }| SELECT| INSERT [ (column_name [,...n]) ]| DELETE| UPDATE [ (column_name [,...n]) ]| REFERENCES [ (column_name [,...n]) ]| USAGE }[,...n]ON { [TABLE] table_name| DOMAIN domain_name| COLLATION collation_name| CHARACTER SET character_set_name| TRANSLATION translation_name }TO {grantee_name |  PUBLIC}[WITH GRANT OPTION]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Avec l&acute;instruction <span class="emphasis">GRANT</span>, les utilisateurs peuvent se voir attribuer un ou plusieurs privil&egrave;ges d&acute;acc&egrave;s <span class="emphasis"> &8212; SELECT</span>, <span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span>, <span class="emphasis">DELETE</span>, <span class="emphasis">REFERENCES</span> ou <span class="emphasis">USAGE</span> &8212; par une autorit&eacute; comp&eacute;tente. Chacun de ces privil&egrave;ges permet &agrave; l&acute;utilisateur d&acute;ex&eacute;cuter la commande sp&eacute;cifi&eacute;e, tandis que <span class="emphasis">REFERENCES</span> et <span class="emphasis">USAGE</span> accordent d&acute;autres privil&egrave;ges. Pour sp&eacute;cifier plusieurs privil&egrave;ges d&acute;acc&egrave;s,il suffit de s&eacute;parer chacun d&acute;eux par une virgule; <span class="emphasis">ALL</span> permet d&acute;acc&eacute;der &agrave; tous les privil&egrave;ges. Le mot-cl&eacute; <span class="emphasis">PRIVILEGES</span> est optionnel.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le privil&egrave;ge <span class="emphasis">USAGE</span> s&acute;applique &agrave; tout objet de base de donn&eacute;es, &agrave; l&acute;exception des tables, tandis que les autres privil&egrave;ges s&acute;appliquent uniquement aux tables. Le privil&egrave;ge <span class="emphasis">USAGE</span> permet aux utilisateurs de cr&eacute;er des objets sur la base de la d&eacute;finition d&acute;un autre objet; il est ainsi possible, par exemple, de cr&eacute;er une collation sur la base d&acute;une translation. Le privil&egrave;ge <span class="emphasis">REFERENCES</span> permet d&acute;utiliser une table incluse dans une contrainte ou une cl&eacute; &eacute;trang&egrave;re.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les privil&egrave;ges <span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span>, et <span class="emphasis">REFERENCES</span> peuvent &ecirc;tre attribu&eacute;s aux colonnes sp&eacute;cifiques d&acute;une table. Si aucune colonne n&acute;est sp&eacute;cifi&eacute;e, ils s&acute;appliqueront par d&eacute;faut &agrave; toutes les colonnes.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">ON</span> d&eacute;clare la table ou l&acute;objet de base de donn&eacute;es sp&eacute;cifique au niveau duquel les privil&egrave;ges de l&acute;utilisateur vont s&acute;appliquer.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">TO</span> indique l&acute;utilisateur ou le r&ocirc;le exact qui va recevoir une autorisation sp&eacute;cifique. Les privil&egrave;ges peuvent aussi &ecirc;tre accord&eacute;s &agrave; <span class="emphasis">PUBLIC</span>; autrement dit, les utilisateurs (y compris ceux qui seront cr&eacute;&eacute;s par la suite) disposeront tous du privil&egrave;ge sp&eacute;cifi&eacute;. Une autorisation peut &ecirc;tre accord&eacute;e aux autres utilisateurs qui emploient <span class="emphasis">WITH GRANT OPTION</span>. Cette clause indique alors &agrave; la base de donn&eacute;es que les utilisateurs qui ont re&ccedil;u un privil&egrave;ge d&acute;acc&egrave;s peuvent &agrave; leur tour accorder le m&ecirc;me privil&egrave;ge d&acute;acc&egrave;s &agrave; d&acute;autres utilisateurs.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Suivant l&acute;impl&eacute;mentation de base de donn&eacute;es sp&eacute;cifique, les vues peuvent ou non disposer de privil&egrave;ges d&acute;acc&egrave;s ind&eacute;pendants &agrave; partir de leurs tables de base.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>GRANT { ALL [PRIVILEGES] }| SELECT| INSERT| DELETE| UPDATE| REFERENCES| EXECUTE| CREATE {DATABASE | DEFAULT | FUNCTION | PROCEDURE | RULE | TABLE | VIEW}| BACKUP {DATABASE | LOG} } [,...n]ON { {table_name | view_name} [(column [,...n])]| stored_procedure_name| extended_stored_procedure_name| user_defined_function_name| [(column [,...n] ON {table_name | view_name} }TO {grantee_name | PUBLIC} [,...n][WITH GRANT OPTION][AS {group | role}]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server permet d&acute;accorder les privil&egrave;ges d&acute;acc&egrave;s <span class="emphasis">SELECT</span>, <span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span>, <span class="emphasis">DELETE</span> et <span class="emphasis">REFERENCES</span> &agrave; une table. Une liste de colonnes peut &ecirc;tre identifi&eacute;e pour les seules permissions d&acute;acc&egrave;s <span class="emphasis">SELECT</span> et <span class="emphasis">UPDATE</span>. Par d&eacute;faut, les colonnes re&ccedil;oivent toutes les privil&egrave;ges d&acute;acc&egrave;s <span class="emphasis">SELECT</span> et <span class="emphasis">UPDATE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Seule la permission <span class="emphasis">EXECUTE</span> peut &ecirc;tre accord&eacute;e pour les proc&eacute;dures stock&eacute;es, les proc&eacute;dures stock&eacute;es &eacute;tendues et les fonctions d&eacute;finies par l&acute;utilisateur; un utilisateur doit disposer du privil&egrave;ge <span class="emphasis">REFERENCES</span> pour cr&eacute;er une contrainte <span class="emphasis">FOREIGN KEY</span>. Cette permission est &eacute;galement n&eacute;cessaire pour cr&eacute;er une fonction ou une vue d&eacute;pendant d&acute;un objet dot&eacute; de <span class="emphasis">SCHEMABINDING</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">AS</span><span class="emphasis"></span> accorde des privil&egrave;ges, comme s&acute;il s&acute;agissait d&acute;un autre contexte de groupe ou de r&ocirc;le. Puisque ni les groupes ni les r&ocirc;les ne peuvent ex&eacute;cuter la commande <span class="emphasis">GRANT</span>, cette m&eacute;thode permet d&acute;accorder ais&eacute;ment des privil&egrave;ges &agrave; un utilisateur qui n&acute;appartient pas au groupe ou au r&ocirc;le. Les privil&egrave;ges peuvent uniquement &ecirc;tre accord&eacute;s au contexte de la base de donn&eacute;es active.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>D&acute;abord, <span class="emphasis">CREATE DATABASE</span> et <span class="emphasis">CREATE TABLE</span> permettent d&acute;accorder des permissions aux utilisateurs Emily et Sarah. Ensuite, diverses permissions sont accord&eacute;es au groupe editors, sur la table <span class="emphasis">titles</span>. Les &eacute;diteurs peuvent alors accorder ces m&ecirc;mes permission &agrave; d&acute;autres utilisateurs:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>GRANT CREATE DATABASE, CREATE TABLE TO emily, sarahGOGRANT SELECT, INSERT, UPDATE, DELETE ON titlesTO editorsWITH GRANT OPTIONGO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans MySQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>GRANT { ALL PRIVILEGES| SELECT| INSERT [ (column_name [,...n]) ]| DELETE| UPDATE [ (column_name [,...n]) ]| REFERENCES [ (column_name [,...n]) ]| USAGE| ALTER| CREATE| DROP| FILE| INDEX| PROCESS| RELOAD| SHUTDOWN }[,...n]ON {table_name | * | *.* | database_name.*}TO grantee_name [IDENTIFIED BY 'password'] [,...n][WITH GRANT OPTION]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>MySQL propose des privil&egrave;ges d&acute;acc&egrave;s suppl&eacute;mentaires, qui concernent principalement la manipulation des objets dans une base de donn&eacute;es. Comme pour les autres privil&egrave;ges, l&acute;attribution d&acute;un privil&egrave;ge d&acute;acc&egrave;s (par exemple, <span class="emphasis">ALTER</span>, <span class="emphasis">CREATE</span>, <span class="emphasis">INDEX</span> ou <span class="emphasis">RELOAD</span>) permet &agrave; l&acute;utilisateur d&acute;ex&eacute;cuter la commande correspondante. Bien que le privil&egrave;ge <span class="emphasis">REFERENCES</span> soit pris en charge, il n&acute;a aucune fonctionnalit&eacute;. La commande <span class="emphasis">USAGE</span> <span class="emphasis">d&eacute;sactive</span> les privil&egrave;ges accord&eacute;s &agrave; un utilisateur.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les privil&egrave;ges d&acute;acc&egrave;s suivants s&acute;appliquent aux tables: <span class="emphasis">SELECT</span>, <span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span>, <span class="emphasis">DELETE</span>, <span class="emphasis">CREATE</span>, <span class="emphasis">DROP</span>, <span class="emphasis">GRANT</span>, <span class="emphasis">INDEX</span> et <span class="emphasis">ALTER</span>. Les privil&egrave;ges <span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span> et <span class="emphasis">SELECT</span> peuvent s&acute;appliquer au niveau des colonnes.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;impl&eacute;mentation par MySQL de la clause <span class="emphasis">ON</span> offre des options int&eacute;ressantes. Il est possible de d&eacute;finir des privil&egrave;ges globaux, applicables &agrave; toutes les bases de donn&eacute;es stock&eacute;es sur le serveur, en sp&eacute;cifiant <span class="emphasis">ON *.*</span>. Pour d&eacute;finir des privil&egrave;ges au niveau de la base de donn&eacute;es, il convient de sp&eacute;cifier <span class="emphasis">ON database_name.*</span> ou <span class="emphasis">ON *</span> dans la base de donn&eacute;es active. La longueur du nom des h&ocirc;tes, des tables et des colonnes est limit&eacute;e &agrave; 60&#160;caract&egrave;res.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>MySQL permet d&acute;accorder des droits &agrave; un utilisateur sp&eacute;cifique sur un h&ocirc;te sp&eacute;cifique si le <span class="emphasis">grantee_name</span> respecte le format <span class="emphasis">USER@HOST</span>. L&acute;inclusion de caract&egrave;res g&eacute;n&eacute;riques dans un <span class="emphasis">grantee_name</span> permet d&acute;accorder le privil&egrave;ge d&acute;acc&egrave;s &agrave; plusieurs utilisateurs en m&ecirc;me temps. La longueur du <span class="emphasis">grantee_name</span> ne doit pas d&eacute;passer 16&#160;caract&egrave;res. Lorsque l&acute;utilisateur est sp&eacute;cifi&eacute;, l&acute;inclusion de la clause <span class="emphasis">IDENTIFIED BY</span> permet de garantir la protection par mot de passe.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;exemple suivant accorde des permissions &agrave; deux utilisateurs dot&eacute;s de mots de passe:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>GRANT SELECT ON employee TO Dylan IDENTIFIED BY 'porsche',  kelly IDENTIFIED BY 'mercedes',  emily IDENTIFIED BY 'saab';</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>GRANT { ALL [PRIVILEGES] }{| GRANT ANY PRIVILEGE }{| SELECT | INSERT  | DELETE | UPDATE | REFERENCES }{| CREATE [ANY] {CLUSTER | CONTEXT | DATABASE| DATABASE LINK | DIMENSION   | DIRECTORY | INDEXTYPE | INDEX | LIBRARY | OPERATOR | OUTLINE   | PROCEDURE | PROFILE | ROLE | ROLLBACK SEGMENT | SEQUENCE | SESSION   | SNAPSHOT | SYNONYM | TABLE | TABLESPACE | TRIGGER | TYPE |   | USER | [MATERIALIZED] VIEW}| DROP [ANY] {...as CREATE...}| ALTER [ANYh] {...as CREATE...}| AUDIT SYSTEM| EXECUTE [ANY] {INDEXTYPE | OPERATOR | PROCEDURE | TYPE| BACKUP [ANY] {TABLE | DATABASE | LOG} } [,...n] }ON { [schema_name.]{table_name | view_name} [ (column [,...n]) ]| stored_procedure_name| extended_stored_procedure_name| user_defined_function_name| DIRECTORY directory_name| JAVA {SOURCE | RESOURCE} [schema_name.]object_name }TO {{grantee_name | role_name} [,...n] | PUBLIC}[WITH ADMIN OPTION];</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il saute aux yeux qu&acute;Oracle propose une commande <span class="emphasis">GRANT</span> exhaustive. En fait, la syntaxe indiqu&eacute;e ne couvre pas la totalit&eacute; des permutations de l&acute;instruction. GRANT propose deux classes g&eacute;n&eacute;rales de privil&egrave;ges: les privil&egrave;ges objets (par exemple, le privil&egrave;ge permettant d&acute;effectuer des s&eacute;lections [<span class="emphasis">SELECT</span>] ou des suppressions [<span class="emphasis">DELETE</span>] dans une table sp&eacute;cifique) et les privil&egrave;ges syst&egrave;me (par exemple, <span class="emphasis">CREATE CLUSTER</span> ou <span class="emphasis">DROP ANY TABLE</span>).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle ne permet pas de combiner les privil&egrave;ges objets et syst&egrave;me dans une m&ecirc;me commande <span class="emphasis">GRANT</span>. Il est possible d&acute;accorder plusieurs privil&egrave;ges objets ou syst&egrave;me &agrave; un m&ecirc;me utilisateur ou r&ocirc;le dans une commande <span class="emphasis">GRANT</span>, mais une commande <span class="emphasis">GRANT</span> ne permet pas d&acute;accorder &agrave; la fois des privil&egrave;ges objets et des privil&egrave;ges syst&egrave;me.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Une commande <span class="emphasis">GRANT</span> autorise la quasi-totalit&eacute; des fonctions Oracle prises en charge. Il est possible d&acute;accorder des privil&egrave;ges non seulement pour des objets de base de donn&eacute;es (tables et vues, par exemple) et des commandes syst&egrave;me (<span class="emphasis">CREATE ANY TABLE</span>, par exemple), mais aussi pour des objets de sch&eacute;ma (<span class="emphasis">DIRECTORY</span>, <span class="emphasis">JAVA SOURCE,</span> et <span class="emphasis">RESOURCE</span>, entre autres).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;option <span class="emphasis">ANY</span> permet d&acute;ex&eacute;cuter une instruction donn&eacute;e sur des objets d&acute;un type sp&eacute;cifique appartenant &agrave; tout utilisateur du sch&eacute;ma. Vous trouverez une liste plus compl&egrave;te des privil&egrave;ges syst&egrave;me Oracle dans le Tableau 3.2.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Cat&eacute;gorie de privil&egrave;ge</th><th>Privil&egrave;ge syst&egrave;me</th><th>Description</th></tr>
								<tr><td>CLUSTER</td><td>CREATE CLUSTER</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er un cluster dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE ANY CLUSTER</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er un cluster dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>ALTER ANY CLUSTER</td><td>Accorde le privil&egrave;ge permettant de modifier des clusters dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY CLUSTER</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des clusters dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr><td>CONTEXT</td><td>CREATE ANY CONTEXT</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er un espace de nom de contexte.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY CONTEXT</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer n&acute;importe quel espace de nom de contexte.</td>
								</tr>
								<tr><td>DATABASE</td><td>ALTER DATABASE</td><td>Accorde le privil&egrave;ge permettant de modifier la base de donn&eacute;es.</td>
								</tr>
								<tr>
									<td /><td>ALTER SYSTEM</td><td>Envoie des instructions <span class="emphasis">ALTER SYSTEM</span>.</td>
								</tr>
								<tr>
									<td /><td>AUDIT SYSTEM</td><td>Envoie les instructions <span class="emphasis">AUDIT</span> <span class="emphasis">sql_statements</span>.</td>
								</tr>
								<tr><td>DATABASE LINKS</td><td>CREATE DATABASE LINK</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des liaisons de base de donn&eacute;es priv&eacute;es dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE PUBLICDATABASE LINK</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;erdes liaisons de base de donn&eacute;es publiques.</td>
								</tr>
								<tr>
									<td /><td>DROP PUBLICDATABASE LINK</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminerdes liaisons de base de donn&eacute;es publiques.</td>
								</tr>
								<tr><td>DIMENSIONS</td><td>CREATE DIMENSION</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des dimensions dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE ANYDIMENSION</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des dimensions dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>ALTER ANYDIMENSION</td><td>Accorde le privil&egrave;ge permettant de modifier des dimensions dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>DROP ANYDIMENSION</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des dimensions dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr><td>DIRECTORIES</td><td>CREATE ANYDIRECTORY</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des objets de base de donn&eacute;es de r&eacute;pertoire.</td>
								</tr>
								<tr>
									<td /><td>DROP ANYDIRECTORY</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminerdes objets de base de donn&eacute;es de r&eacute;pertoire..</td>
								</tr>
								<tr><td>INDEXTYPES</td><td>CREATE INDEXTYPE</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er un type d&acute;index dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE ANYINDEXTYPE</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er un type d&acute;index dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>ALTER ANYINDEXTYPE</td><td>Modifie les types d&acute;index dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>DROP ANYINDEXTYPE</td><td>Accorde le privil&egrave;ge permettant de supprimer un type d&acute;index dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>EXECUTE ANYINDEXTYPE</td><td>Fait r&eacute;f&eacute;rence &agrave; un type d&acute;index dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr><td>INDEXES</td><td>CREATE ANY INDEX</td><td>Accorde le privil&egrave;ge permettant de supprimer un index de domaine ou un index de table dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>ALTER ANY INDEX</td><td>Accorde le privil&egrave;ge permettant de modifier des index dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY INDEX</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des index dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>QUERY REWRITE</td><td>Permet d&acute;effectuer une r&eacute;&eacute;criture sur la base d&acute;une vue mat&eacute;rialis&eacute;e, ou cr&eacute;e un index fonctionnel, lorsque cette vue mat&eacute;rialis&eacute;e ou cet index fait r&eacute;f&eacute;rence &agrave; des tables et des vues dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>GLOBAL QUERY REWRITE</td><td>Permet d&acute;effectuer une r&eacute;&eacute;criture sur la base d&acute;une vue mat&eacute;rialis&eacute;e, ou cr&eacute;e un index fonctionnel, lorsque cette vue mat&eacute;rialis&eacute;e ou cet index fait r&eacute;f&eacute;rence &agrave; des tables et des vues dans un sch&eacute;ma quelconque.</td>
								</tr>
								<tr><td>LIBRARIES</td><td>CREATE LIBRARY</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des biblioth&egrave;ques de proc&eacute;dures/fonctions externes dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE ANY LIBRARY</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des biblioth&egrave;ques de proc&eacute;dures/fonctions externes dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>DROP LIBRARY</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des biblioth&egrave;ques de proc&eacute;dures/fonctions externes dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY LIBRARY</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des biblioth&egrave;ques de proc&eacute;dures/fonctions externes dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr><td>MATERIALIZED VIEWS (identique &agrave; SNAPSHOTS)</td><td>CREATE MATERIALIZED VIEW</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er une vue mat&eacute;rialis&eacute;e dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE ANY MATERIALIZED VIEW</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des vues mat&eacute;rialis&eacute;es dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>ALTER ANY MATERIALIZED VIEW</td><td>Accorde le privil&egrave;ge permettant de modifier des vues mat&eacute;rialis&eacute;es dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY MATERIALIZED VIEW</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des vues mat&eacute;rialis&eacute;es dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>GLOBAL QUERY REWRITE</td><td>Permet d&acute;effectuer une r&eacute;&eacute;criture sur la base d&acute;une vue mat&eacute;rialis&eacute;e, ou cr&eacute;e un index fonctionnel, lorsque cette vue mat&eacute;rialis&eacute;e ou cet index fait r&eacute;f&eacute;rence &agrave; des tables ou des vues dans un sch&eacute;ma quelconque.</td>
								</tr>
								<tr>
									<td /><td>QUERY REWRITE</td><td>Permet d&acute;effectuer une r&eacute;&eacute;criture sur la base d&acute;une vue mat&eacute;rialis&eacute;e, ou cr&eacute;e un index fonctionnel, lorsque cette vue mat&eacute;rialis&eacute;e ou cet index fait r&eacute;f&eacute;rence &agrave; des tables ou des vues dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr><td>OPERATORS</td><td>CREATE OPERATOR</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er un op&eacute;rateur et ses liaisons dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE ANYOPERATOR</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er un op&eacute;rateur et ses liaisons dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY OPERATOR</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer un op&eacute;rateur dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>EXECUTE ANYOPERATOR</td><td>Fait r&eacute;f&eacute;rence &agrave; un op&eacute;rateur dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr><td>OUTLINES</td><td>CREATE ANY OUTLINE</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des contours compatibles avec tout sch&eacute;ma utilisant les contours.</td>
								</tr>
								<tr>
									<td /><td>ALTER ANY OUTLINE</td><td>Modifie les contours.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY OUTLINE</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer les contours.</td>
								</tr>
								<tr><td>PROCEDURES</td><td>CREATE PROCEDURE</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des proc&eacute;dures stock&eacute;es, des fonctions et des cha&icirc;nes dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE ANYPROCEDURE</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des proc&eacute;dures stock&eacute;es, des fonctions et des cha&icirc;nes dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>ALTER ANYPROCEDURE</td><td>Accorde le privil&egrave;ge permettant de modifier des proc&eacute;dures stock&eacute;es, des fonctions et des cha&icirc;nes dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>DROP ANYPROCEDURE</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des proc&eacute;dures stock&eacute;es, des fonctions et des cha&icirc;nes dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>EXECUTE ANYPROCEDURE</td><td>Ex&eacute;cute les proc&eacute;dures ou les fonctions (autonomes ou en cha&icirc;nes).</td>
								</tr>
								<tr><td>PROFILES</td><td>CREATE PROFILE</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des profils.</td>
								</tr>
								<tr>
									<td /><td>ALTER PROFILE</td><td>Accorde le privil&egrave;ge permettant de modifier des profils.</td>
								</tr>
								<tr>
									<td /><td>DROP PROFILE</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des profils.</td>
								</tr>
								<tr><td>ROLES</td><td>CREATE ROLE</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des r&ocirc;les.</td>
								</tr>
								<tr>
									<td /><td>ALTER ANY ROLE</td><td>Accorde le privil&egrave;ge permettant de modifier n&acute;importe quel r&ocirc;le dans la base de donn&eacute;es.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY ROLE</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des r&ocirc;les.</td>
								</tr>
								<tr>
									<td /><td>GRANT ANY ROLE</td><td>Accorde n&acute;importe quel r&ocirc;le dans la base de donn&eacute;es.</td>
								</tr>
								<tr><td>ROLLBACK SEGMENTS</td><td>CREATE ROLLBACK SEGMENT</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des rollback segments.</td>
								</tr>
								<tr>
									<td /><td>ALTER ROLLBACK SEGMENT</td><td>Accorde le privil&egrave;ge permettant de modifier des rollback segments.</td>
								</tr>
								<tr>
									<td /><td>DROP ROLLBACK SEGMENT</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des rollback segments.</td>
								</tr>
								<tr><td>SEQUENCES</td><td>CREATE SEQUENCE</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des s&eacute;quences dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE ANY SEQUENCE</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des s&eacute;quences dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>ALTER ANY SEQUENCE</td><td>Accorde le privil&egrave;ge permettant de modifier n&acute;importe quelle s&eacute;quence dans la base de donn&eacute;es.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY SEQUENCE</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des s&eacute;quences dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>SELECT ANY SEQUENCE</td><td>Fait r&eacute;f&eacute;rence &agrave; des s&eacute;quences dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr><td>SESSIONS</td><td>CREATE SESSION</td><td>Etablit une connexion &agrave; la base de donn&eacute;es.</td>
								</tr>
								<tr>
									<td /><td>ALTER RESOURCE COST</td><td>Etablit les co&ucirc;ts pour les ressources de session.</td>
								</tr>
								<tr>
									<td /><td>ALTER SESSION</td><td>Envoie des instructions <span class="emphasis">ALTER SESSION</span>.</td>
								</tr>
								<tr>
									<td /><td>RESTRICTED SESSION</td><td>Ouvre une session une fois que l&acute;occurrence a &eacute;t&eacute; lanc&eacute;e au moyen de l&acute;instruction <span class="emphasis">STARTUP RESTRICT</span> de SQL*Plus.</td>
								</tr>
								<tr><td>SNAPSHOTS (identique &agrave; MATERIALIZED VIEWS)</td><td>CREATE SNAPSHOT</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des instantan&eacute;s dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE ANYSNAPSHOT</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des instantan&eacute;s dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>ALTER ANY SNAPSHOT</td><td>Accorde le privil&egrave;ge permettant de modifier n&acute;importe quel instantan&eacute; dans la base de donn&eacute;es.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY SNAPSHOT</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des instantan&eacute;s dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>GLOBAL QUERY REWRITE</td><td>Permet d&acute;effectuer une r&eacute;&eacute;criture sur la base d&acute;un instantan&eacute;, ou cr&eacute;e un index fonctionnel, lorsque cet instantan&eacute; ou cet index fait r&eacute;f&eacute;rence &agrave; des tables et des vues dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>QUERY REWRITE</td><td>Permet d&acute;effectuer une r&eacute;&eacute;criture sur la base d&acute;un instantan&eacute;, ou cr&eacute;e un index fonctionnel, lorsque cet instantan&eacute; ou cet index fait r&eacute;f&eacute;rence &agrave; des tables et des vues dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr><td>SYNONYMS</td><td>CREATE SYNONYM</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des synonymes dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE ANY SYNONYM</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des synonymes dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>CREATE PUBLIC SYNONYM</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des synonymes publics.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY SYNONYM</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des synonymes priv&eacute;s dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>DROP PUBLIC SYNONYM</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des synonymes publics.</td>
								</tr>
								<tr><td>TABLES</td><td>CREATE ANY TABLE</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des tables dans n&acute;importe quel sch&eacute;ma. Le propri&eacute;taire du sch&eacute;ma qui contient la table doit avoir d&eacute;fini un quota d&acute;espace pour la table dans l&acute;espace de travail.</td>
								</tr>
								<tr>
									<td /><td>ALTER ANY TABLE</td><td>Accorde le privil&egrave;ge permettant de modifier n&acute;importe quelle table ou vue dans le sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>BACKUP ANY TABLE</td><td>Emploie l&acute;utilitaire Export pour ex&eacute;cuter une exportation incr&eacute;mentielle des objets &agrave; partir du sch&eacute;ma d&acute;autres utilisateurs.</td>
								</tr>
								<tr>
									<td /><td>DELETE ANY TABLE</td><td>Supprime des lignes dans les tables, les partitions de tables ou les vues de n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY TABLE</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer ou de tronquer des tables ou des partitions de table dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>INSERT ANY TABLE</td><td>Ins&egrave;re des lignes dans les tables ou les vues de n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>LOCK ANY TABLE</td><td>Verrouille les tables ou les vues de n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>UPDATE ANY TABLE</td><td>Met &agrave; jour les lignes dans les tables ou les vues de n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>SELECT ANY TABLE</td><td>Interroge les tables, les vues ou les instantan&eacute;s de n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr><td>TABLESPACES</td><td>CREATE TABLESPACE</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des espaces de table.</td>
								</tr>
								<tr>
									<td /><td>ALTER TABLESPACE</td><td>Accorde le privil&egrave;ge permettant de modifier des espaces de table.</td>
								</tr>
								<tr>
									<td /><td>DROP TABLESPACE</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des espaces de table.</td>
								</tr>
								<tr>
									<td /><td>MANAGE TABLESPACE</td><td>Met les espaces de table hors ligne et en ligne, puis lance et arr&ecirc;te leurs sauvegardes.</td>
								</tr>
								<tr>
									<td /><td>UNLIMITED TABLESPACE</td><td>Utilise une quantit&eacute; illimit&eacute;e d&acute;un espace de table. Ce privil&egrave;ge outrepasse tous les quotas sp&eacute;cifiquement d&eacute;finis. Si vous r&eacute;voquez ce privil&egrave;ge pour un utilisateur, les objets de son sch&eacute;ma propre sont conserv&eacute;s, mais toute nouvelle allocation de l&acute;espace de table est refus&eacute;e, sauf si les quotas de table d&acute;espace sp&eacute;cifique l&acute;autorisent. Vous ne pouvez pas accorder ce privil&egrave;ge syst&egrave;me aux r&ocirc;les.</td>
								</tr>
								<tr><td>TRIGGERS</td><td>CREATE TRIGGER</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er un trigger de base de donn&eacute;es dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE ANY TRIGGER</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des triggers de base de donn&eacute;es dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>ALTER ANY TRIGGER</td><td>Active, d&eacute;sactive ou compile les triggers de base de donn&eacute;es dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY TRIGGER</td><td>Accorde le privil&egrave;ge permettant de supprimer des triggers de base de donn&eacute;es dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>ADMINISTER DATABASE TRIGGER</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er un trigger sur <span class="emphasis">DATABASE</span>. (Vous devez &eacute;galement disposer du privil&egrave;ge <span class="emphasis">CREATE TRIGGER</span> ou <span class="emphasis">CREATE ANY TRIGGER</span>.)</td>
								</tr>
								<tr><td>TYPES</td><td>CREATE TYPE</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des types d&acute;objet et des corps de types d&acute;objets dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE ANY TYPE</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des types d&acute;objet et des corps de types d&acute;objet dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>ALTER ANY TYPE</td><td>Accorde le privil&egrave;ge permettant de modifier des types d&acute;objet dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY TYPE</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des types d&acute;objet et des corps de types d&acute;objet dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>EXECUTE ANY TYPE</td><td>Utilise et r&eacute;f&eacute;rence les types d&acute;objet et de collection dans n&acute;importe quel sch&eacute;ma, et appelle les m&eacute;thodes d&acute;un type d&acute;objet dans n&acute;importe quel sch&eacute;ma <span class="emphasis">si vous accordez le privil&egrave;ge &agrave; un utilisateur sp&eacute;cifique</span>. Si vous accordez le privil&egrave;ge <span class="emphasis">EXECUTE ANY TYPE</span> &agrave; un r&ocirc;le, les utilisateurs disposant du r&ocirc;le activ&eacute; ne pourront pas appeler les m&eacute;thodes d&acute;un type d&acute;objet dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr><td>USERS</td><td>CREATE USER</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des utilisateurs. Ce privil&egrave;ge permet &eacute;galement au cr&eacute;ateur d&acute;effectuer les op&eacute;rations suivantes:
										<ol><li>Assigner des quotas &agrave; <span class="emphasis">n&acute;importe quel</span><span class="emphasis"></span>espace de table</li><li>D&eacute;finir des espaces de table par d&eacute;faut et temporaires</li><li>Assigner un profil dans le cadre d&acute;une instruction <span class="emphasis">CREATE USER</span></li></ol>
									</td>
								</tr>
								<tr>
									<td /><td>ALTER USER</td><td>Accorde le privil&egrave;ge permettant de modifier n&acute;importe quel utilisateur. Ce privil&egrave;ge autorise le b&eacute;n&eacute;ficiaire &agrave; effectuer les op&eacute;rations suivantes:
										<ol><li>Modifier le mot de passe ou la m&eacute;thode d&acute;authentification d&acute;un autre utilisateur</li><li>Assigner des quotas &agrave; <span class="emphasis">n&acute;importe quel</span><span class="emphasis"></span>espace de table</li><li>D&eacute;finir des espaces de table par d&eacute;faut et temporaires</li><li>Assigner un profil et des r&ocirc;les par d&eacute;faut</li></ol>
									</td>
								</tr>
								<tr>
									<td /><td>BECOME USER</td><td>Devient un autre utilisateur (cette op&eacute;ration est n&eacute;cessaire si l&acute;utilisateur effectue une importation de base de donn&eacute;es compl&egrave;te).</td>
								</tr>
								<tr>
									<td /><td>DROP USER</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des utilisateurs.</td>
								</tr>
								<tr><td>VIEWS</td><td>CREATE VIEW</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des vues dans le sch&eacute;ma du b&eacute;n&eacute;ficiaire.</td>
								</tr>
								<tr>
									<td /><td>CREATE ANY VIEW</td><td>Accorde le privil&egrave;ge permettant de cr&eacute;er des vues dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>DROP ANY VIEW</td><td>Accorde le privil&egrave;ge permettant d&acute;&eacute;liminer des vues dans n&acute;importe quel sch&eacute;ma.</td>
								</tr>
								<tr><td>MISCELLANEOUS</td><td>ANALYZE ANY</td><td>Analyse tout index, table ou cluster d&acute;un sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>AUDIT ANY</td><td>Audite tout objet d&acute;un sch&eacute;ma au moyen des instructions <span class="emphasis">AUDIT</span><span class="emphasis">schema_objects</span>.</td>
								</tr>
								<tr>
									<td /><td>COMMENT ANY TABLE</td><td>Effectue des commentaires sur toute table, vue ou colonne d&acute;un sch&eacute;ma.</td>
								</tr>
								<tr>
									<td /><td>FORCE ANYTRANSACTION</td><td>Force la validation ou l&acute;annulation d&acute;une transaction distribu&eacute;e suspecte dans la base de donn&eacute;es locale; entra&icirc;ne l&acute;&eacute;chec d&acute;une transaction distribu&eacute;e.</td>
								</tr>
								<tr>
									<td /><td>FORCE TRANSACTION</td><td>Force la validation ou l&acute;annulation des transactions distribu&eacute;es suspectes du b&eacute;n&eacute;ficiaire dans la base de donn&eacute;es locale.</td>
								</tr>
								<tr>
									<td /><td>GRANT ANYPRIVILEGE</td><td>Accorde n&acute;importe quel privil&egrave;ge syst&egrave;me.</td>
								</tr>
								<tr>
									<td /><td>SYSDBA</td><td>Autorise l&acute;utilisateur &agrave; effectuer les op&eacute;rations suivantes:
										<ol><li>Ex&eacute;cuter les op&eacute;rations <span class="emphasis">STARTUP</span> et <span class="emphasis">SHUTDOWN</span></li><li><span class="emphasis">ALTER DATABASE</span><span class="literal">:</span> ouvrir, monter, sauvegarder ou modifier les jeux de caract&egrave;res</li><li><span class="emphasis">CREATE DATABASE</span></li><li><span class="emphasis">ARCHIVELOG</span> et <span class="emphasis">RECOVERY</span></li><li>Inclut le privil&egrave;ge <span class="emphasis">RESTRICTED SESSION</span></li></ol>
									</td>
								</tr>
								<tr>
									<td /><td>SYSOPER</td><td>Autorise l&acute;utilisateur &agrave; effectuer les op&eacute;rations suivantes:
										<ol><li>Ex&eacute;cuter les op&eacute;rations <span class="emphasis">STARTUP</span> et <span class="emphasis">SHUTDOWN</span></li></ol>
										<ol><li><span class="emphasis">ALTER DATABASE OPEN/MOUNT/BACKUP &8212; ARCHIVELOG</span> et <span class="emphasis">RECOVERY</span></li></ol>
										<ol><li>Inclut le privil&egrave;ge <span class="emphasis">RESTRICTED SESSION</span></li></ol>
									</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>GRANT { ALL| SELECT| INSERT| DELETE| UPDATE| RULE } [,...n]ON { object_name }TO {grantee_name | PUBLIC | GROUP group_name}</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL ne prend pas en charge les permissions de colonne ou la clause <span class="emphasis">WITH GRANT OPTION</span>. L&acute;impl&eacute;mentation PostgreSQL de <span class="emphasis">GRANT</span> consid&egrave;re que la clause <span class="emphasis">WITH GRANT OPTION</span> est toujours activ&eacute;e. Tout utilisateur ayant re&ccedil;u une permission peut accorder ce m&ecirc;me privil&egrave;ge aux autres utilisateurs. PostgreSQL permet d&acute;attribuer les permissions &agrave; un <span class="emphasis">GROUPE</span>, &agrave; condition qu&acute;il s&acute;agisse d&acute;un <span class="emphasis">nom_groupe</span> existant valide.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Contrairement &agrave; d&acute;autres &eacute;diteurs de base de donn&eacute;es, PostgreSQL ne prend pas en charge <span class="emphasis">GRANT</span> dans les commandes syst&egrave;me.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La prise en charge par PostgreSQL de l&acute;instruction <span class="emphasis">GRANT</span> est fort simple:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>GRANT INSERT ON publishers TO PUBLIC;GRANT SELECT, UPDATE ON sales TO emily;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="INSERT">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">INSERT</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">INSERT</span> ajoute des lignes de donn&eacute;es dans une table ou une vue. L&acute;instruction <span class="emphasis">INSERT</span> permet d&acute;entrer des enregistrements dans une table par l&acute;une des m&eacute;thodes suivantes:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ol><li>La premi&egrave;re m&eacute;thode consiste &agrave; ins&eacute;rer des enregistrements sur la base des valeurs <span class="emphasis">DEFAULT</span> cr&eacute;&eacute;es dans les colonnes de la table au moyen des instructions <span class="emphasis">CREATE TABLE</span> ou <span class="emphasis">ALTER TABLE</span>. (Oracle ne prend pas cette m&eacute;thode en charge.)</li><li>La deuxi&egrave;me m&eacute;thode, qui est aussi la plus courante, consiste &agrave; d&eacute;clarer les valeurs exactes &agrave; ins&eacute;rer dans les colonnes de l&acute;enregistrement.</li><li>La troisi&egrave;me m&eacute;thode,qui permet d&acute;entrer rapidement les enregistrements dans une table, consiste &agrave; ins&eacute;rer dans une table le jeu de r&eacute;sultats d&acute;une instruction <span class="emphasis">SELECT</span>.</li></ol>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>INSERT [INTO] [[database_name.]owner.] {table_name | view_name} [(column_    list)]{[DEFAULT] VALUES | VALUES (value[,...]) | SELECT_statement }</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour utiliser l&acute;instruction <span class="emphasis">INSERT</span>, vous devez commencer par d&eacute;clarer la table (ou la vue) dans laquelle vous voulez ins&eacute;rer les donn&eacute;es. Le mot-cl&eacute; <span class="emphasis">INTO</span> est optionnel. Sp&eacute;cifiez les colonnes de la table qui recevront les donn&eacute;es: placez-les entre parenth&egrave;ses, en les s&eacute;parant par une virgule, dans <span class="emphasis">column_list</span>. Si vous ignorez cette &eacute;tape (ce qui est possible), les colonnes d&eacute;finies pour la table seront toutes utilis&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La m&eacute;thode <span class="emphasis">DEFAULT VALUES</span> est incompatible avec les m&eacute;thodes <span class="emphasis">list_of_values</span> et <span class="emphasis">SELECT_statement</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">INSERT . . . VALUES</span> ajoute une ligne de donn&eacute;es dans une table, sur la base des valeurs litt&eacute;rales qu&acute;elle contient. Combin&eacute;e &agrave; une instruction <span class="emphasis">SELECT</span>, l&acute;instruction <span class="emphasis">INSERT</span> permet de remplir rapidement plusieurs lignes d&acute;une table. Lorsque <span class="emphasis">INSERT . . . SELECT</span> est utilis&eacute;e entre deux tables, il convient de s&acute;assurer que ces derni&egrave;res poss&egrave;dent des structures et des types de donn&eacute;es compatibles; il est cependant possible de compenser les incompatibilit&eacute;s entre les deux tables dans l&acute;instruction <span class="emphasis">SELECT</span>. <span class="emphasis"> INSERT . . . SELECT</span> est &eacute;galement prise en charge par PostgreSQL.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe Microsoft SQL Server et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>INSERT [INTO] [[database_name.]owner.]    {table_name | view_name} [(column_list)]{[DEFAULT] VALUES | list_of_values | SELECT_statement | EXEC[UTE] { procedure_name }    [[@parameter_name=] {value [OUTPUT] | DEFAULT}[,...]}</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;impl&eacute;mentation de la commande <span class="emphasis">INSERT</span> est diff&eacute;rente dans Microsoft SQL Server, dans la mesure o&ugrave; elle autorise le mot-cl&eacute; <span class="emphasis">DEFAULT</span>. Le mot-cl&eacute; <span class="emphasis">DEFAULT</span> indique &agrave; l&acute;instruction <span class="emphasis">INSERT</span> de cr&eacute;er un nouvel enregistrement sur la base de toutes les valeurs par d&eacute;faut d&eacute;clar&eacute;es pour une table donn&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La diff&eacute;rence pour l&acute;impl&eacute;mentation de cet &eacute;diteur r&eacute;side dans le mot-cl&eacute; <span class="emphasis">EXECUTE</span>. La clause <span class="emphasis">EXECUTE</span> indique &agrave; SQL Server de stocker le jeu de r&eacute;sultats renvoy&eacute; par une instruction Transact-SQL dynamique, une proc&eacute;dure stock&eacute;e par le syst&egrave;me, une proc&eacute;dure stock&eacute;e par l&acute;utilisateur, un RPC (Remote Procedure Call) ou une proc&eacute;dure stock&eacute;e &eacute;tendue d&acute;une table locale.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Par exemple, l&acute;instruction <span class="emphasis">INSERT</span> qui suit r&eacute;cup&egrave;re le r&eacute;pertoire <span class="emphasis">C:\temp</span> et le stocke dans la table temporaire <span class="emphasis">#ins_exec_container</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>INSERT INTO #ins_exec_containerEXEC master..xp_cmdshell "dir c:\temp"GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans MySQL </span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>INSERT [LOW_PRIORITY | DELAYED] [IGNORE][INTO] [[database_name.]owner.] {table_name | view_name} [(column_list)]{VALUES (value[,...]) | SELECT_statement | SET column=value[,...n]}</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;option <span class="emphasis">LOW_PRIORITY</span> indique &agrave; MySQL de reporter l&acute;ex&eacute;cution de la commande <span class="emphasis">INSERT</span> jusqu&acute;&agrave; ce que les autres clients aient fini de consulter la table. L&acute;attente peut &ecirc;tre assez longue. L&acute;option <span class="emphasis">DELAYED</span> permet au client de poursuivre imm&eacute;diatement, m&ecirc;me si la commande <span class="emphasis">INSERT</span> n&acute;est pas termin&eacute;e. Le mot-cl&eacute; <span class="emphasis">IGNORE</span> indique &agrave; MySQL de ne pas essayer d&acute;ins&eacute;rer des enregistrements qui risqueraient de dupliquer la valeur d&acute;une cl&eacute; principale ou unique; dans ce cas, la commande <span class="emphasis">INSERT</span> &eacute;choue sans cette clause. La syntaxe <span class="emphasis">SET column=value</span> permet de d&eacute;clarer les colonnes de la table et d&acute;y ins&eacute;rer les valeurs.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe Oracle et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>INSERT [INTO] [[database_name.]owner.] {table_name | view_name}   [PARTITION partition_name | SUBPARTITION subpartition_name][(column_list)]{VALUES (value1[,...n]) RETURNING expression1 [,...n] INTO variable1   [,...n] |SELECT_statement[WITH {READ ONLY | CHECK OPTION [CONSTRAINT constraint_name]} }</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;impl&eacute;mentation dans Oracle de l&acute;instruction <span class="emphasis">INSERT</span> permet d&acute;ins&eacute;rer des donn&eacute;es non seulement dans une table, une vue ou un instantan&eacute; sp&eacute;cifique, mais &eacute;galement dans une partition ou une sous-partition particuli&egrave;re d&acute;une table, au moyen des mots-cl&eacute; <span class="emphasis">PARTITION</span> et <span class="emphasis">SUBPARTITION</span> keywords.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>De nouvelles r&egrave;gles s&acute;appliquent lorsque l&acute;instruction <span class="emphasis">INSERT</span> est en corr&eacute;lation avec une clause <span class="emphasis">SELECT</span>. Si la clause <span class="emphasis">SELECT</span> est associ&eacute;e &agrave; une clause <span class="emphasis">VALUES</span>, une seule ligne est ins&eacute;r&eacute;e dans la table &8212; la premi&egrave;re ligne renvoy&eacute;e par la clause <span class="emphasis">SELECT</span>. Si la clause <span class="emphasis">SELECT</span> est utilis&eacute;e dans la clause <span class="emphasis">VALUES</span>, les lignes renvoy&eacute;es par la requ&ecirc;te sont toutes ins&eacute;r&eacute;es dans la table.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">RETURNING</span> ne permet pas d&acute;ins&eacute;rer les valeurs dans une table, mais dans des variables. Une correspondance bijective doit lier les expressions et les variables de la clause <span class="emphasis">RETURNING</span>. Les expressions renvoy&eacute;es par la clause ne doivent pas n&eacute;cessairement correspondre &agrave; celles mentionn&eacute;es dans la clause <span class="emphasis">VALUES</span>. Par exemple, l&acute;instruction INSERT qui suit place un enregistrement dans la table <span class="emphasis">sales</span>, mais place une valeur totalement diff&eacute;rente dans une variable attach&eacute;e:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>INSERT authors (au_id, au_lname, au_fname, contract )VALUES ('111-11-1111', 'Rabbit', 'Jessica', 1)RETURNING hire_date INTO:temp_hr_dt;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">RETURNING</span> renvoie <span class="emphasis">hire_date</span> m&ecirc;me si <span class="emphasis">hire_date</span> ne compte pas parmi les valeurs indiqu&eacute;es dans la clause <span class="emphasis">VALUES</span>. (Dans le cas de notre exemple, nous pouvons supposer qu&acute;une valeur par d&eacute;faut a &eacute;t&eacute; d&eacute;finie pour la colonne <span class="emphasis">hire_date</span>.) La clause <span class="emphasis">RETURNING</span> ne permet pas de manipuler les types de donn&eacute;es LONG. La clause <span class="emphasis">RETURNING</span> ne peut pas s&acute;appliquer aux vues dot&eacute;es de triggers <span class="emphasis">INSTEAD OF</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>De plus, la clause <span class="emphasis">SELECT</span> peut utiliser l&acute;option <span class="emphasis">WITH</span>. La clause <span class="emphasis">WITH READ ONLY</span> sp&eacute;cifie que l&acute;instruction <span class="emphasis">INSERT</span> ne peut pas servir &agrave; modifier le jeu de r&eacute;sultats r&eacute;cup&eacute;r&eacute; par la clause <span class="emphasis">SELECT</span>. La clause <span class="emphasis">WITH CHECK OPTION</span> indique &agrave; Oracle d&acute;interdire toute modification de donn&eacute;es susceptible de g&eacute;n&eacute;rer des lignes qui ne soient pas incluses dans le jeu de r&eacute;sultats de la clause <span class="emphasis">SELECT</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe PostgreSQL et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL prend en charge la norme SQL99 pour l&acute;instruction <span class="emphasis">INSERT</span>. Reportez-vous &agrave; la section pr&eacute;c&eacute;dente pour plus de d&eacute;tails sur la syntaxe et l&acute;utilisation de SQL99.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans cet exemple, une nouvelle ligne est ins&eacute;r&eacute;e dans la table <span class="emphasis">authors</span> pour l&acute;auteur Jessica Rabbit dans une base de donn&eacute;es Microsoft SQL Server:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>INSERT INTO authors (au_id, au_lname, au_fname, phone, address, city,     state, zip, contract )VALUES ('111-11-1111', 'Rabbit', 'Jessica', DEFAULT, '1717 Main St', NULL,    'CA', '90675', 1)</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>A chaque colonne est assign&eacute;e une valeur litt&eacute;rale sp&eacute;cifique, &agrave; l&acute;exception de la colonne <span class="emphasis">phone</span>, qui re&ccedil;oit la valeur par d&eacute;faut (attribu&eacute;e dans le cadre de l&acute;instruction <span class="emphasis">CREATE TABLE</span> ou <span class="emphasis">ALTER TABLE</span>) et <span class="emphasis">city</span>, qui a la valeur null.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;exemple suivant illustre une instruction <span class="emphasis">INSERT</span> partielle sur une base de donn&eacute;es Microsoft SQL Server contenant les m&ecirc;mes donn&eacute;es:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>INSERT authors (au_id, au_lname, au_fname,  phone, contract )VALUES ('111-11-1111', 'Rabbit', 'Jessica', DEFAULT, 1)</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour charger des donn&eacute;es de la table <span class="emphasis">sales</span> dans la table <span class="emphasis">new_sales</span>, il est possible d&acute;utiliser <span class="emphasis">INSERT . . . SELECT</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>INSERT sales    (stor_id,    ord_num,    ord_date,    qty,    payterms,    title_id)SELECT    CAST(store_nbr AS CHAR(4)),    CAST(order_nbr AS VARCHAR(20)),    order_date,    quantity,    SUBSTRING(payment_terms,1,12),    CAST(title_nbr AS CHAR(1))FROM new_salesWHERE order_date &gt;= '01/01/2000'         -- retrieve only the newer records</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="Op&eacute;rateur LIKE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">Op&eacute;rateur LIKE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L&acute;op&eacute;rateur <span class="emphasis">LIKE</span>   permet de sp&eacute;cifier des mod&egrave;les de cha&icirc;ne dans les instructions <span class="emphasis">SELECT</span>   , <span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span> et <span class="emphasis">DELETE</span> choisies pour la correspondance. Le mod&egrave;le sp&eacute;cifi&eacute; peut m&ecirc;me inclure des caract&egrave;res g&eacute;n&eacute;riques sp&eacute;ciaux.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>WHERE expression [NOT] LIKE string_pattern</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;utilit&eacute; de <span class="emphasis">LIKE</span> repose sur les op&eacute;rateurs g&eacute;n&eacute;riques qu&acute;il prend en charge. <span class="emphasis">LIKE</span> renvoie la valeur bool&eacute;enne <span class="emphasis">TRUE</span> lorsque la comparaison trouve au moins une valeur correspondante. La sensibilit&eacute; &agrave; la casse par d&eacute;faut du SGBD rev&ecirc;t une grande importance pour le comportement de <span class="emphasis">LIKE</span>. Par exemple, Microsoft SQL Server n&acute;est pas par d&eacute;faut sensible &agrave; la casse (mais vous pouvez le configurer dans ce sens). Ainsi, la requ&ecirc;te:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT *FROM authorsWHERE lname LIKE 'LARS%'</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>va trouver les auteurs dont le nom de famille est stock&eacute; sous `larson' ou `lars', m&ecirc;me si la recherche initiale portait sur `LARS%' (en majuscules). Oracle est sensible &agrave; la casse pour les caract&egrave;res de mod&egrave;le "<span class="emphasis">%</span>" et "<span class="emphasis">_</span>", et propose, sur la base d&acute;op&eacute;rateurs autres que <span class="emphasis">LIKE</span>, d&acute;autres correspondances de mod&egrave;les dans le cadre des expressions r&eacute;guli&egrave;res. Les op&eacute;rateurs g&eacute;n&eacute;riques sont r&eacute;pertori&eacute;s dans le Tableau 3.3.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Op&eacute;rateur g&eacute;n&eacute;rique</th><th>Exemple</th><th>Description</th></tr>
								<tr><td><span class="emphasis">%</span></td><td>R&eacute;cup&egrave;re tout enregistrement de ville dont le nom inclut la cha&icirc;ne "ville". (Pris en charge par tous les &eacute;diteurs.)<pre>SELECT * FROM authorsWHERE city LIKE '%ville%'</pre>
									</td><td>Repr&eacute;sente n&acute;importe quelle cha&icirc;ne; est similaire &agrave; l&acute;op&eacute;rateur * dans les op&eacute;rations DOS.</td>
								</tr>
								<tr><td><span class="emphasis">[ ]</span></td><td>R&eacute;cup&egrave;re tout auteur dont le nom de famille est similaire &agrave; Carson, Carsen, Karson ou Karsen. (Non pris en charge par Oracle. Pris en charge par Microsoft SQL Server.)<pre>SELECT * FROM authorsWHERE au_lname LIKE '[CK]ars[eo]n'</pre>
									</td><td>Repr&eacute;sente n&acute;importe quelle valeur du jeu sp&eacute;cifi&eacute; (par exemple, [abc]) ou n&acute;importe quelle page (par exemple, [k-n]).</td>
								</tr>
								<tr><td><span class="emphasis">[^ ]</span></td><td>R&eacute;cup&egrave;re tout auteur dont le nom de famille se termine par arson ou arsen, <span class="emphasis">sauf</span> Larsen ou Larson. (Pris en charge par Microsoft SQL Server.)<pre>SELECT * FROM authorsWHERE au_lname LIKE '[A-Z^L]ars[eo]n'</pre>
									</td><td>Repr&eacute;sente n&acute;importe quelle caract&egrave;re qui n&acute;appartient pas au jeu ou &agrave; la plage sp&eacute;cifi&eacute;.</td>
								</tr>
								<tr><td><span class="emphasis">_ (soulign&eacute;)</span></td><td>R&eacute;cup&egrave;re tout auteur dont le pr&eacute;nom est <span class="emphasis">diff&eacute;rent</span> de Sheryl ou Cheryl. (Pris en charge par tous les &eacute;diteurs.)<pre>SELECT * FROM authorsWHERE au_fname NOT LIKE '_heryl'</pre>
									</td><td>Repr&eacute;sente n&acute;importe quel caract&egrave;re.</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans le cadre des comparaisons de cha&icirc;nes avec <span class="emphasis">LIKE</span>, tous les caract&egrave;res du mod&egrave;le rev&ecirc;tent une grande importance, y compris les espaces blancs en t&ecirc;te ou en queue .</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="OPEN">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">OPEN </td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">OPEN</span> ouvre un curseur serveur cr&eacute;&eacute; au moyen d&acute;une instruction <span class="emphasis">DECLARE CURSOR</span>. MySQL ne prend pas en charge les curseurs serveur de style ANSI.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>OPEN { cursor_name }</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">cursor_name</span> repr&eacute;sente le nom du curseur cr&eacute;&eacute; au moyen de la commande <span class="emphasis">DECLARE CURSOR</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>En plus des curseurs serveur standard, Microsoft SQL Server permet de d&eacute;clarer des curseurs globaux (au format <span class="emphasis">OPEN GLOBAL cursor_name</span>) qui seront r&eacute;f&eacute;renc&eacute;s par plusieurs utilisateurs. De plus, Oracle permet de transmettre des param&egrave;tres directement au curseur &agrave; l&acute;ouverture de ce dernier (au format <span class="emphasis">OPEN cursor_name parameter1 [,...n]</span>).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;exemple suivant, qui repose sur Microsoft SQL Server, ouvre un curseur et rel&egrave;ve toutes les lignes. Vous pouvez activer la m&ecirc;me fonctionnalit&eacute; dans Oracle et PostgreSQL sans la clause <span class="emphasis">DEALLOCATE</span> finale:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>DECLARE employee_cursor CURSOR FOR  SELECT lname, fname  FROM pubs.dbo.authors  WHERE lname LIKE 'K%'OPEN employee_cursorFETCH NEXT FROM employee_cursorWHILE @@FETCH_STATUS = 0BEGIN  FETCH NEXT FROM Employee_CursorENDCLOSE employee_cursorDEALLOCATE employee_cursor-- DEALLOCATE is specific to Microsoft SQL Server and non-ANSI-- standard.</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="Op&eacute;rateurs">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">Op&eacute;rateurs</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>Un op&eacute;rateur est un symbole servant &agrave; sp&eacute;cifier une action ex&eacute;cut&eacute;e sur une ou plusieurs expressions. Les op&eacute;rateurs sont surtout utilis&eacute;s dans les instructions <span class="emphasis">DELETE</span>, <span class="emphasis">INSERT</span>, <span class="emphasis">SELECT</span> ou <span class="emphasis">UPDATE</span>, mais ils servent aussi dans une large mesure &agrave; la cr&eacute;ationd&acute;objets de base de donn&eacute;es (proc&eacute;dures stock&eacute;es, fonctions, triggers et vues, notamment).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les op&eacute;rateurs entrent normalement dans les cat&eacute;gories logiques suivantes:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ul><li><i><span class="emphasis">Op&eacute;rateurs arithm&eacute;tiques</span></i><br>&#160;						  Pris en charge par toutes les bases de donn&eacute;es</li><li><i><span class="emphasis">Op&eacute;rateurs d'affectation</span></i><br>&#160;						  Pris en charge par toutes les bases de donn&eacute;es</li><li><i>Op&eacute;rateurs <span class="emphasis">binaires</span><span class="emphasis"></span></i><br>&#160;						  Pris en charge par Microsoft SQL Server</li><li><i>Op&eacute;rateurs de <span class="emphasis">comparaison</span><span class="emphasis"></span></i><br>&#160;						  Pris en charge par toutes les bases de donn&eacute;es</li><li><i>Op&eacute;rateurs <span class="emphasis">logiques</span><span class="emphasis"></span></i><br>&#160;						  Pris en charge par Oracle, Microsoft SQL Server et PostgreSQL</li><li><i><span class="emphasis">Op&eacute;rateurs unaires</span></i><br>&#160;						  Pris en charge par Oracle</li></ul>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Op&eacute;rateurs arithm&eacute;tiques</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les op&eacute;rateurs arithm&eacute;tiques effectuent des op&eacute;rations math&eacute;matiques sur deux expressions de n&acute;importe quel type de donn&eacute;es dans la cat&eacute;gorie du type de donn&eacute;es num&eacute;rique. Voir Tableau 3.4 pour obtenir la liste des op&eacute;rateurs arithm&eacute;tiques.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Op&eacute;rateurs arithm&eacute;tiques</th><th>Signification</th></tr>
								<tr><td><span class="emphasis">+</span></td><td>Addition</td>
								</tr>
								<tr><td><span class="emphasis">- </span></td><td>Soustraction</td>
								</tr>
								<tr><td><span class="emphasis">* </span></td><td>Multiplication</td>
								</tr>
								<tr><td><span class="emphasis">/ </span></td><td>Division</td>
								</tr>
								<tr><td><span class="emphasis">% </span></td><td>Modulo (SQL Server uniquement); renvoie le reste d&acute;une division sous la forme d&acute;un nombre entier.</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Oracle et SQL Server, les op&eacute;rateurs + et &#8211; permettent &eacute;galement d&acute;ex&eacute;cuter des op&eacute;rations arithm&eacute;tiques sur les valeurs de date.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Op&eacute;rateurs d'affectation</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Sauf dans Oracle,  l&acute;op&eacute;rateur d'affectation (<span class="emphasis">=</span>) attribue la valeur &agrave; une variable ou &agrave; l&acute;alias d&acute;un en-t&ecirc;te de colonne. Dans Microsoft SQL Server, le mot-cl&eacute; <span class="emphasis">AS</span> peut &ecirc;tre attribu&eacute; en tant qu&acute;op&eacute;rateur pour les alias d&acute;en-t&ecirc;tes de table ou de colonne.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Op&eacute;rateurs binaires</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Microsoft SQL Server, les op&eacute;rateurs binaires servent de raccourcis pour l&acute;ex&eacute;cution de manipulations par bit entre des expressions de deux nombres entiers (voir Tableau 3.5). Les types de donn&eacute;es valides auxquels les op&eacute;rateurs binaires peuvent acc&eacute;der incluent <span class="emphasis">binary</span>, <span class="emphasis">bit</span>, <span class="emphasis">int</span>, <span class="emphasis">smallint</span>, <span class="emphasis">tinyint</span> et <span class="emphasis">varbinary</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Op&eacute;rateurs binaires</th><th>Signification</th></tr>
								<tr><td><span class="emphasis">&amp; </span> </td><td>AND binaire (deux op&eacute;randes)</td>
								</tr>
								<tr><td><span class="emphasis">| </span> </td><td>OR binaire (deux op&eacute;randes)</td>
								</tr>
								<tr><td><span class="emphasis">^ </span> </td><td>OR exclusif binaire (deux op&eacute;randes)</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Op&eacute;rateurs de comparaison</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les op&eacute;rateurs de comparaison v&eacute;rifient si deux expressions sont &eacute;gales ou in&eacute;gales. Le r&eacute;sultat d&acute;une op&eacute;ration de comparaison est une valeur bool&eacute;enne: <span class="emphasis">TRUE</span>, <span class="emphasis">FALSE</span> ou <span class="emphasis">UNKNOWN</span>. De plus, le comportement ANSI standard pour une op&eacute;ration de comparaison dans laquelle une ou plusieurs expressions ont la valeur <span class="emphasis">NULL</span> est <span class="emphasis">NULL</span>. Par exemple, l&acute;expression <span class="emphasis">23 + NULL</span> renvoie <span class="emphasis">NULL</span>, au m&ecirc;me titre que l&acute;expression <span class="emphasis">Feb 23, 2002 + NULL</span>. Voir Tableau 3.6 pour obtenir la liste des op&eacute;rateurs de comparaison.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Op&eacute;rateurs de comparaison</th><th>Signification</th></tr>
								<tr><td><span class="emphasis">=</span></td><td>Egal &agrave;</td>
								</tr>
								<tr><td><span class="emphasis">&gt;</span></td><td>Sup&eacute;rieur &agrave;</td>
								</tr>
								<tr><td><span class="emphasis">&lt;</span></td><td>Inf&eacute;rieur &agrave;</td>
								</tr>
								<tr><td><span class="emphasis">&gt;=</span></td><td>Sup&eacute;rieur ou &eacute;gal &agrave;</td>
								</tr>
								<tr><td><span class="emphasis">&lt;=</span></td><td>Inf&eacute;rieur ou &eacute;gal &agrave;</td>
								</tr>
								<tr><td><span class="emphasis">&lt;&gt;</span></td><td>Diff&eacute;rent de</td>
								</tr>
								<tr><td><span class="emphasis">!=</span>     </td><td>Diff&eacute;rent de (ce n&acute;est pas une norme ANSI)</td>
								</tr>
								<tr><td><span class="emphasis">!&lt;</span></td><td>Sup&eacute;rieur &agrave; (ce n&acute;est pas une norme ANSI)</td>
								</tr>
								<tr><td><span class="emphasis">!&gt;</span></td><td>Inf&eacute;rieur &agrave; (ce n&acute;est pas une norme ANSI)</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les op&eacute;rateurs de comparaison bool&eacute;ens sont surtout utilis&eacute;s dans uneclause <span class="emphasis">WHERE</span> pour filtrer les lignes qui respectent les crit&egrave;res de recherche. L&acute;exemple Microsoft SQL Server qui suit utilise l&acute;op&eacute;ration de comparaison sup&eacute;rieur ou &eacute;gal &agrave;:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT *   FROM Products   WHERE ProductID &gt;= @MyProduct</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Op&eacute;rateurs logiques</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les op&eacute;rateurs logiques sont souvent utilis&eacute;s dans une clause <span class="emphasis">WHERE</span> pour tester la v&eacute;racit&eacute; d&acute;une condition sp&eacute;cifique. Les op&eacute;rateurs logiques renvoient la valeur bool&eacute;enne <span class="emphasis">TRUE</span> ou <span class="emphasis">FALSE</span>. Les op&eacute;rateurs logiques sont &eacute;galement pr&eacute;sent&eacute;s dans le cadre de la rubrique <span class="emphasis">SELECT</span>. Les SGBDR ne g&egrave;rent pas syst&eacute;matiquement tous les op&eacute;rateurs. Voir Tableau 3.7 pour obtenir la liste des op&eacute;rateurs logiques.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Op&eacute;rateurs logiques</th><th>Signification</th></tr>
								<tr><td><span class="emphasis">ALL</span></td><td>TRUE si toutes les comparaisons d&acute;un jeu ont la valeur TRUE</td>
								</tr>
								<tr><td><span class="emphasis">AND </span>         </td><td>TRUE si les deux expressions bool&eacute;ennes ont la valeur TRUE</td>
								</tr>
								<tr><td><span class="emphasis">ANY</span></td><td>TRUE si l&acute;une des comparaisons d&acute;un jeu a la valeur TRUE</td>
								</tr>
								<tr><td><span class="emphasis">BETWEEN</span></td><td>TRUE si l&acute;op&eacute;rande est inclus dans une plage</td>
								</tr>
								<tr><td><span class="emphasis">EXISTS</span></td><td>TRUE<span class="emphasis"></span> si une sous-requ&ecirc;te contient des lignes</td>
								</tr>
								<tr><td><span class="emphasis">IN</span></td><td>TRUE si l&acute;op&eacute;rande est &eacute;gal &agrave; une liste d&acute;expressions</td>
								</tr>
								<tr><td><span class="emphasis">LIKE</span></td><td>TRUE si l&acute;op&eacute;rande correspond &agrave; un mod&egrave;le</td>
								</tr>
								<tr><td><span class="emphasis">NOT</span></td><td>Inverse la valeur de tout autre op&eacute;rateur bool&eacute;en</td>
								</tr>
								<tr><td><span class="emphasis">OR</span></td><td>TRUE si l&acute;une des expression bool&eacute;enne a la valeur TRUE</td>
								</tr>
								<tr><td><span class="emphasis">SOME</span></td><td>TRUE si certaines comparaisons d&acute;un jeu ont la valeur TRUE</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Op&eacute;rateurs unaires</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les op&eacute;rateurs unaires ex&eacute;cutent une op&eacute;ration sur une seule expression de tout type de donn&eacute;es de la cat&eacute;gorie num&eacute;rique. Vous pouvez utiliser les op&eacute;rateurs unaires pour les nombres entiers, mais les valeurs positives et n&eacute;gatives peuvent s&acute;appliquer &agrave; tout type de donn&eacute;es num&eacute;rique (voir Tableau 3.8).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Op&eacute;rateurs unaires</th><th>Signification</th></tr>
								<tr><td><span class="emphasis">+</span></td><td>La valeur num&eacute;rique est positive</td>
								</tr>
								<tr><td><span class="emphasis">-</span>  </td><td>La valeur num&eacute;rique est n&eacute;gative</td>
								</tr>
								<tr><td><span class="emphasis">~</span></td><td>L&acute;op&eacute;rateur NOT binaire renvoie le compl&eacute;ment du nombre (ne s&acute;applique pas dans Oracle)</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Priorit&eacute; des op&eacute;rateurs</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il arrive que les expressions d&acute;op&eacute;rateur atteignent une grande complexit&eacute;. Si une expression comporte plusieurs op&eacute;rateurs, la <span class="emphasis">priorit&eacute; des op&eacute;rateurs</span> d&eacute;termine l&acute;ordre d&acute;ex&eacute;cution des op&eacute;rations. Cet ordre peut avoir une incidence consid&eacute;rable sur le r&eacute;sultat.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les op&eacute;rateurs respectent les niveaux de priorit&eacute; suivants. Les op&eacute;rateurs de niveau sup&eacute;rieur sont toujours &eacute;valu&eacute;s avant les op&eacute;rateurs de niveau inf&eacute;rieur:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ol><li>( ) (expressions entre parenth&egrave;ses)</li><li>+, -, ~ (op&eacute;rateurs unaires)</li><li>*, /, % (op&eacute;rateurs math&eacute;matiques)</li><li>+, - (op&eacute;rateurs arithm&eacute;tiques)</li><li>=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, !=, !&gt;, !&lt; (op&eacute;rateurs de comparaison)</li><li>^ (OR exclusif binaire), &amp; (AND binaire), | (OR binaire)</li><li><span class="emphasis">NOT </span></li><li><span class="emphasis">AND </span></li><li><span class="emphasis">ALL</span>, <span class="emphasis">ANY</span>, <span class="emphasis">BETWEEN</span>, <span class="emphasis">IN</span>, <span class="emphasis">LIKE</span>, <span class="emphasis">OR</span>, <span class="emphasis">SOME</span></li><li>= (affectation variable)</li></ol>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;&eacute;valuation des op&eacute;rateurs s&acute;effectue de gauche &agrave; droite lorsqu&acute;ils poss&egrave;dent le m&ecirc;me niveau de priorit&eacute;. Cependant, les parenth&egrave;ses permettent d&acute;outrepasser la priorit&eacute; par d&eacute;faut des op&eacute;rateurs dans une expression. Les expressions mises entre parenth&egrave;ses sont &eacute;valu&eacute;es en premier, suivies des op&eacute;rations en dehors de ces parenth&egrave;ses.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Par exemple, les expressions suivantes dans une requ&ecirc;tre Oracle renvoient des r&eacute;sultats tr&egrave;s diff&eacute;rents:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT 2 * 4 + 5 FROM dual-- Evaluates to 8 + 5 which yields an expression result of 13.SELECT 2 * (4 + 5) FROM dual-- Evaluates to 2 * 9 which yields an expression result of 18.</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans les expressions dot&eacute;es de parenth&egrave;ses imbriqu&eacute;es, l&acute;&eacute;valuation commence par l&acute;expression qui poss&egrave;de le niveau d&acute;imbrication le plus &eacute;lev&eacute;.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;exemple qui suit contient des parenth&egrave;ses imbriqu&eacute;es; l&acute;expression <span class="emphasis">5 -3</span> est incluse dans le jeu de parenth&egrave;ses qui poss&egrave;de le niveau d&acute;imbrication le plus &eacute;lev&eacute;. Cette expression renvoie la valeur <span class="emphasis">2</span>. L&acute;op&eacute;rateur d&acute;addition (+) ajoute ensuite ce r&eacute;sultat &agrave; <span class="emphasis">4</span>, pour renvoyer la valeur <span class="emphasis">6</span>. Enfin, la valeur <span class="emphasis">6</span> est multipli&eacute;e par <span class="emphasis">2</span> pour renvoyer le r&eacute;sultat de l&acute;expression, en l&acute;occurrence <span class="emphasis">12</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT 2 * (4 + (5 - 3) ) FROM dual-- Evaluates to 2 * (4 + 2) which further evaluates to 2 * 6, and-- yields an expression result of 12.</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="RETURN">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">RETURN </td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">RETURN</span> termine le traitement d&acute;une fonction appel&eacute;e par SQL (par opposition &agrave; une fonction appel&eacute;e par un h&ocirc;te) et renvoie, sous forme de valeur, le r&eacute;sultat de cette fonction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>RETURNS return_parameter_value | NULL</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La fonction <span class="emphasis">RETURN</span> s&acute;utilise dans une fonction pour mettre fin &agrave; son traitement. L&acute;utilisation de la clause <span class="emphasis">NULL</span> met fin &agrave; la fonction sans renvoyer de valeur. Sinon, la valeur de param&egrave;tre sp&eacute;cifi&eacute;e est renvoy&eacute;e sous forme de variable ou d&acute;expression litt&eacute;rale.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">RETURN</span> est consid&eacute;r&eacute;e comme une commande s&eacute;par&eacute;e dans SQL, mais elle est profond&eacute;ment entrelac&eacute;e avec l&acute;instruction <span class="emphasis">CREATE FUNCTION</span> . Reportez-vous &agrave; l&acute;instruction <span class="emphasis">CREATE FUNCTION</span> pour plus de d&eacute;tails sur l&acute;impl&eacute;mentation de <span class="emphasis">RETURN</span> par chaque &eacute;diteur.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cet exemple cr&eacute;e une fonction, qui renvoie &agrave; la session d&acute;appel la valeur stock&eacute;e dans la variable <span class="emphasis">proj_rev</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE FUNCTION project_revenue (project IN varchar2)RETURN NUMBERAS   proj_rev NUMBER(10,2);BEGIN   SELECT SUM(DECODE(action,'COMPLETED',amount,0) -          SUM(DECODE(action,'STARTED',amount,0)   +          SUM(DECODE(action,'PAYMENT',amount,0)   INTO proj_rev   FROM construction_actions   WHERE project_name = project;   RETURN (proj_rev);END;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cet exemple cr&eacute;e une fonction qui renvoie une valeur calcul&eacute;e &agrave; la session d&acute;appel:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>CREATE FUNCTION metric_volume -- Input dimensions in centimeters.   (@length decimal(4,1),   @width decimal(4,1),   @height decimal(4,1) )RETURNS decimal(12,3) -- Cubic Centimeters.ASBEGIN   RETURN ( @length * @width * @height )ENDGO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="REVOKE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">REVOKE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">REVOKE</span> supprime les permissions accord&eacute;es &agrave; un utilisateur, un groupe ou un r&ocirc;le pour un objet de base de donn&eacute;es ou une commande syst&egrave;me sp&eacute;cifique.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>REVOKE [GRANT OPTION FOR]{ ALL PRIVILEGES }| SELECT| INSERT| DELETE| UPDATE| REFERENCES| USAGE }[,...n]ON { [TABLE] table_name| DOMAIN domain_name| COLLATION collation_name| CHARACTER SET character_set_name| TRANSLATION translation_name }FROM {grantee_name | PUBLIC} [,...n]{CASCADE | RESTRICT}</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">REVOKE privilege_name ON object_name FROM grantee_name</span> permet de r&eacute;voquer pour un seul utilisateur un privil&egrave;ge sp&eacute;cifique applicable &agrave; un objet de base de donn&eacute;es particulier. La clause <span class="emphasis">PUBLIC</span> permet de r&eacute;voquer pour tous les utilisateurs un privil&egrave;ge sp&eacute;cifique applicable &agrave; un objet de base de donn&eacute;es particulier. <span class="emphasis">WITH GRANT OPTION</span> permet de r&eacute;voquer les permissions au moyen de la clause <span class="emphasis">REVOKE GRANT OPTION FOR</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;option <span class="emphasis">RESTRICT</span> r&eacute;voque uniquement le privil&egrave;ge sp&eacute;cifi&eacute;. L&acute;option <span class="emphasis">CASCADE</span> r&eacute;voque le privil&egrave;ge sp&eacute;cifi&eacute;, ainsi que tous les privil&egrave;ges qui en d&eacute;pendent. Une r&eacute;vocation en cascade peut pr&eacute;senter un comportement diff&eacute;rent en fonction de la plate-forme de base de donn&eacute;es utilis&eacute;e; veillez donc &agrave; lire la documentation de l&acute;&eacute;diteur afin de conna&icirc;tre l&acute;impl&eacute;mentation correcte pour cette option.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>REVOKE [GRANT OPTION FOR]{ALL [ PRIVILEGES ]| SELECT| INSERT| DELETE| UPDATE| REFERENCES| EXECUTE| CREATE {DATABASE | DEFAULT | FUNCTION | PROCEDURE | RULE | TABLE | VIEW}| BACKUP {DATABASE | LOG} } [,...n]ON { {table_name | view_name} [(column [,...n])]| stored_procedure_name| extended_stored_procedure_name| user_defined_function_name| [(column [,...n] ON {table_name | view_name} }{TO | FROM} {grantee_name} [,...n][CASCADE][AS {group_name | role_name} ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette commande est surtout compatible avec SQL99, &agrave; l&acute;exception des extensions apport&eacute;es par la commande <span class="emphasis">GRANT</span> .</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Si les commandes ont &eacute;t&eacute; accord&eacute;es &agrave; un utilisateur pour lequel <span class="emphasis">WITH GRANT OPTION</span> est activ&eacute;, il faut utiliser &agrave; la fois <span class="emphasis">WITH GRANT OPTION</span> et <span class="emphasis">CASCADE</span> pour r&eacute;voquer le privil&egrave;ge en question.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">REVOKE</span> s&acute;utilise uniquement dans la base de donn&eacute;es active. <span class="emphasis">REVOKE</span> permet &eacute;galement de d&eacute;sactiver les param&egrave;tres <span class="emphasis">DENY</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server prend de plus en charge l&acute;instruction <span class="emphasis">DENY</span> . <span class="emphasis">DENY</span> utilise une syntaxe similaire &agrave; celle de <span class="emphasis">REVOKE</span>. Cependant, sa conception est diff&eacute;rente dans la mesure o&ugrave; <span class="emphasis">REVOKE</span> neutralise les privil&egrave;ges d&acute;un utilisateur, tandis que <span class="emphasis">DENY</span> les interdit explicitement. L&acute;instruction <span class="emphasis">DENY</span> permet d&acute;interdire &agrave; un utilisateur ou un r&ocirc;le l&acute;acc&egrave;s &agrave; un privil&egrave;ge.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>REVOKE CREATE DATABASE, CREATE TABLE FROM emily, sarahGOREVOKE GRANT OPTION FORSELECT, INSERT, UPDATE, DELETE ON titlesTO editorsGO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans MySQL </span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>REVOKE { ALL PRIVILEGES| SELECT| INSERT [ (column_name [,...n]) ]| UPDATE [ (column_name [,...n]) ]| REFERENCES [ (column_name [,...n]) ]| DELETE| USAGE| ALTER| CREATE| DROP| FILE| INDEX| PROCESS| RELOAD| SHUTDOWN } [,...n]ON {table_name | * | *.* | database_name.*}FROM user_name [,...n]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">REVOKE</span> annule les permissions pr&eacute;alablement accord&eacute;es &agrave; un ou plusieurs utilisateurs. Les permissions peuvent faire l&acute;objet d&acute;une r&eacute;vocation globale, comme d&eacute;crit dans le cadre de l&acute;instruction <span class="emphasis">GRANT</span>. De plus, l&acute;impl&eacute;mentation de <span class="emphasis">REVOKE</span> dans MySQL n&acute;annule pas explicitement les permissions relatives aux objets &eacute;limin&eacute;s. Il est donc n&eacute;cessaire de r&eacute;voquer (<span class="emphasis">REVOKE</span>) explicitement les permissions applicables &agrave; une table, m&ecirc;me si cette derni&egrave;re est &eacute;limin&eacute;e. Pour le reste, MySQL respecte la norme SQL99 applicable &agrave; la commande <span class="emphasis">REVOKE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La premi&egrave;re commande r&eacute;voque tous les privil&egrave;ges applicables &agrave; la table <span class="emphasis">sales</span> pour Emily et Dylan, tandis que la seconde r&eacute;voque tous les privil&egrave;ges pour l&acute;utilisateur Kelly dans la base de donn&eacute;es active:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>REVOKE ALL PRIVILEGES ON sales FROM emily, dylan;REVOKE * employee FROM kelly;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>REVOKE {ALL [PRIVILEGES] | [object_privilege] }ON { [schema_name.][object] | [DIRECTORY directory_object_name] }FROM {grantee_name | role | PUBLIC} [,...n][CASCADE [CONSTRAINTS] ] [FORCE];REVOKE {system_privilege | role}FROM {grantee_name | role | PUBLIC} [,...n];</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">REVOKE</span> permet de r&eacute;voquer non seulement les privil&egrave;ges objet et syst&egrave;me, mais elle peut &eacute;galement r&eacute;voquer un r&ocirc;le pour un utilisateur sp&eacute;cifique ou un autre r&ocirc;le. Reportez-vous &agrave; l&acute;instruction <span class="emphasis">GRANT</span> pour de plus amples informations sur les privil&egrave;ges objet et syst&egrave;me sp&eacute;cifiquement pris en charge par la commande <span class="emphasis">REVOKE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les deux formes de la commande <span class="emphasis">REVOKE</span>, <span class="emphasis">REVOKE object_privilege</span> et <span class="emphasis">REVOKE system_privilege</span>, sont incompatibles. Vous ne devez pas essayer de les inclure dans une m&ecirc;me instruction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La r&eacute;vocation des privil&egrave;ges d&acute;un utilisateur r&eacute;voque en m&ecirc;me temps les privil&egrave;ges qu&acute;il a accord&eacute;s &agrave; d&acute;autres utilisateurs.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les utilisateurs qui poss&egrave;dent le privil&egrave;ge syst&egrave;me <span class="emphasis">GRANT ANY ROLE</span> peuvent &eacute;galement r&eacute;voquer n&acute;importe quel r&ocirc;le. La commande <span class="emphasis">REVOKE</span> peut uniquement r&eacute;voquer les privil&egrave;ges qui ont &eacute;t&eacute; sp&eacute;cifiquement accord&eacute;s au moyen de la commande <span class="emphasis">GRANT</span>, mais non les privil&egrave;ges accord&eacute;s par le biais de r&ocirc;les ou du syst&egrave;me d&acute;exploitation.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">ON DIRECTORY</span> identifie un objet r&eacute;pertoire dont les permissions sont r&eacute;voqu&eacute;es. La clause <span class="emphasis">CASCADE CONSTRAINTS</span> supprime toutes les contraintes d&acute;int&eacute;grit&eacute; r&eacute;f&eacute;rentielle cr&eacute;&eacute;es par les utilisateurs lorsque leur privil&egrave;ge <span class="emphasis">REFERENCES</span> est r&eacute;voqu&eacute;. La clause <span class="emphasis">FORCE</span> r&eacute;voque les permissions <span class="emphasis">EXECUTE</span> pour les objets table et type connexes d&eacute;finis par l&acute;utilisateur. Ces objets seront donc marqu&eacute;s comme non valides et inutilisables jusqu&acute;&agrave; recompilation.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour r&eacute;voquer un r&ocirc;le pour un utilisateur:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>REVOKE read-only FROM sarah;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour r&eacute;voquer un privil&egrave;ge de commande syst&egrave;me:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>REVOKE CREATE ANY SEQUENCE, CREATE ANY DIRECTORY FROM read_only;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour r&eacute;voquer un privil&egrave;ge <span class="emphasis">REFERENCES</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>REVOKE REFERENCESON pubs_new_york.empFROM dylanCASCADE CONSTRAINTS;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>REVOKE { ALL| SELECT| INSERT| DELETE| UPDATE| RULE| REFERENCES| USAGE} [,...n]ON {object_name}TO {grantee_name | PUBLIC | GROUP group_name}{CASCADE | RESTRICT}</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;acc&egrave;s aux tables, vues et s&eacute;quences peut &ecirc;tre r&eacute;voqu&eacute; dans PostgreSQL. Cette commande est autrement identique &agrave; la commande SQL99. Reportez-vous &agrave; la pr&eacute;sentation de la syntaxe de <span class="emphasis">REVOKE</span> pour SQL99, ainsi qu&acute;&agrave; la pr&eacute;sentation de <span class="emphasis">GRANT</span> pour SQL99.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="ROLLBACK">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">ROLLBACK</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">ROLLBACK</span>  annule une transaction ou r&eacute;tablit l&acute;&eacute;tat qu&acute;elle avait &agrave; un <span class="emphasis">SAVEPOINT</span> pr&eacute;alablement d&eacute;clar&eacute;. Elle ferme les curseurs ouverts et lib&egrave;re les verrous selon le m&ecirc;me principe que <span class="emphasis">COMMIT</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ROLLBACK [WORK][TO SAVEPOINT savepoint_name]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Outre qu&acute;elle finalise une seule op&eacute;ration de manipulation de donn&eacute;es ou un groupe de telles op&eacute;rations, l&acute;instruction <span class="emphasis">ROLLBACK</span> annule toutes les transactions jusqu&acute;&agrave; la derni&egrave;re instruction <span class="emphasis">BEGIN</span> ou <span class="emphasis">SAVEPOINT</span> &eacute;mise.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>SQL99 propose les nouveaux mots-cl&eacute; optionnels <span class="emphasis">AND CHAIN</span>. Aucun des quatre &eacute;diteurs ne prend cette commande en charge pour le moment. Cette nouvelle syntaxe est la suivante:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ROLLBACK [WORK] [AND [NO] CHAIN]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;option <span class="emphasis">AND CHAIN</span> indique au SGBD de mettre fin &agrave; la transaction en cours, tout en partageant l&acute;environnement de transaction commun (le niveau d&acute;isolation de transaction, par exemple) avec la transaction suivante. L&acute;option <span class="emphasis">AND NO CHAIN</span> met fin &agrave; la transaction unique. D'un point de vue fonctionnel, la commande <span class="emphasis">ROLLBACK</span> est &eacute;quivalente &agrave; la commande <span class="emphasis">ROLLBACK WORK AND NO CHAIN</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ROLLBACK [TRAN[SACTION] [transaction_name | @tran_name_variable |savepoint_name | @savepoint_variable] ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">ROLLBACK</span> annule toutes les modifications de donn&eacute;es apport&eacute;es &agrave; la transaction active ou &agrave; un point de reprise existant sp&eacute;cifique. Si elle est &eacute;mise toute seule, l&acute;instruction <span class="emphasis">ROLLBACK</span> annule la transaction ouverte active. <span class="emphasis">ROLLBACK</span> lib&egrave;re normalement les verrous, mais tel n&acute;est pas le cas pour une annulation &agrave; un point de reprise. L&acute;instruction <span class="emphasis">ROLLBACK</span> a un comportement similaire &agrave; <span class="emphasis">COMMIT</span> en ce qui concerne les triggers imbriqu&eacute;s, puisqu&acute;elle d&eacute;cr&eacute;mente la variable syst&egrave;me <span class="emphasis">@@TRANCOUNT</span> d&acute;une unit&eacute;.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Emise dans un trigger, l&acute;instruction <span class="emphasis">ROLLBACK TRANSACTION</span> annule toutes les modifications de donn&eacute;es, y compris celles ex&eacute;cut&eacute;es par le trigger, jusqu&acute;&agrave; l&acute;emplacement de l&acute;instruction <span class="emphasis">ROLLBACK</span>. Les triggers imbriqu&eacute;s ne sont pas ex&eacute;cut&eacute;s s&acute;ils suivent une instruction <span class="emphasis">ROLLBACK</span> dans un trigger; cependant, le rollback n&acute;a aucune incidence sur les instructions incluses dans le trigger qui le suit.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>ROLLBACK [WORK] [TO savepoint_name] [FORCE text];</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">ROLLBACK</span> annule toutes les modifications de donn&eacute;es apport&eacute;es &agrave; la transaction ouverte active ou &agrave; un point de reprise sp&eacute;cifique. L&acute;impl&eacute;mentation de cette commande dans Oracle respecte scrupuleusement la norme SQL, sauf en ce qui concerne l&acute;option <span class="emphasis">FORCE</span>. <span class="emphasis">ROLLBACK FORCE</span> revient &agrave; une transaction distribu&eacute;e suspecte. Ces transactions font l&acute;objet d&acute;une description dans la vue syst&egrave;me Oracle, <span class="emphasis">DBA_2PC_PENDING</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>{ROLLBACK | ABORT} [WORK | TRANSACTION];</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">ROLLBACK</span> annule toutes les modifications de donn&eacute;es apport&eacute;es &agrave; la transaction ouverte active ou &agrave; un point de reprise sp&eacute;cifique. PostgreSQL prend en charge l&acute;option <span class="emphasis">WORK</span> de SQL99 et l&acute;option <span class="emphasis">TRANSACTION</span>. PostgreSQL ne prend pas en charge le retour &agrave; un point de reprise. L&acute;option <span class="emphasis">ABORT</span> peut servir de synonyme complet pour <span class="emphasis">ROLLBACK</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le lot Transact-SQL suivant utilise <span class="emphasis">COMMIT</span> et <span class="emphasis">ROLLBACK</span> dans Microsoft SQL Server. Il ins&egrave;re un enregistrement dans la table <span class="emphasis">sales</span>. En cas d&acute;&eacute;chec, la transaction est annul&eacute;e; si l&acute;instruction aboutit, la transaction est valid&eacute;e:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>BEGIN TRAN -- initializes a transaction-- the transaction itselfINSERT INTO salesVALUES('7896','JR3435','Oct 28 1997',25,'Net 60','BU7832')-- some error-handling in the event of a failureIF @@ERROR &lt;&gt; 0BEGIN    -- raises an error in the event log and skips to the end    RAISERROR 50000 'Insert of sales record failed'    ROLLBACK WORK    GOTO end_of_batchEND-- the transaction is committed if no errors are detectedCOMMIT TRAN-- the GOTO label that enables the batch to skip to the end without-- committingend_of_batch:GO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="SAVEPOINT">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">SAVEPOINT </td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>Cette commande cr&eacute;e un point de reprise dans la transaction active. La commande <span class="emphasis">SAVEPOINT</span> permet de diviser les transactions en points d&acute;interruption logiques. Vous pouvez sp&eacute;cifier plusieurs points de reprise dans une m&ecirc;me transaction. La commande <span class="emphasis">SAVEPOINT</span> pr&eacute;sente un avantage primordial: les transactions peuvent faire l&acute;objet d&acute;un retour &agrave; un marqueur de point de reprise unique, au moyen de la commande <span class="emphasis">ROLLBACK</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SAVEPOINT savepoint_name</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il est d&eacute;sonseill&eacute;, bien que certains &eacute;diteurs l&acute;autorisent, de dupliquer les noms de points de reprise au sein d&acute;une m&ecirc;me transaction. Il est &eacute;galement inclure des identificateurs de points de reprise de remplacement (au format:X) afin que le SGBD puisse assurer le suivi du point de reprise sur la base d&acute;un nombre entier plut&ocirc;t que d&acute;un nom. Les &eacute;diteurs ne prennent pas tous en charge cette approche, qui est de toute fa&ccedil;on d&eacute;conseill&eacute;e.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>SQL99 prend en charge l&acute;instruction <span class="emphasis">RELEASE SAVEPOINT savepoint_name</span>, et cela permet d&acute;&eacute;liminer un point de reprise existant. Cependant, cette instruction n&acute;est prise en charge par aucun des &eacute;diteurs mentionn&eacute;s dans cet ouvrage.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SAVE TRAN[SACTION] {savepoint_name | @savepoint_variable}</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server ne prend pas en charge la commande <span class="emphasis">SAVEPOINT</span>. Il utilise &agrave; la place la commande <span class="emphasis">SAVE</span> . Si vous ne voulez pas d&eacute;clarer le nom litt&eacute;ral du point de reprise, vous pouvez faire r&eacute;f&eacute;rence &agrave; une variable contenant le nom de ce point de reprise.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>A l&acute;ex&eacute;cution de la commande <span class="emphasis">ROLLBACK TRAN savepoint_name</span>, SQL Server retourne la transaction au point de reprise appropri&eacute;, puis poursuit le traitement au niveau de la prochaine commande Transact-SQL valide suivant l&acute;instruction <span class="emphasis">ROLLBACK</span>. Enfin, la transaction doit se terminer par une instruction <span class="emphasis">COMMIT</span> ou <span class="emphasis">ROLLBACK</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SAVEPOINT savepoint_name</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle prend totalement en charge l&acute;impl&eacute;mentation SQL99.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cet exemple ex&eacute;cute plusieurs modifications de donn&eacute;es, retourne la transaction &agrave; un point de reprise, puis l&acute;annule compl&egrave;tement:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>INSERT INTO sales VALUES('7896','JR3435','Oct 28 1997',25,'Net60','BU7832');SAVEPOINT after_insert;UPDATE sales SET terms = 'Net 90'WHERE sales_id = '7896';SAVEPOINT after_update;DELETE sales;ROLLBACK TO after_insert;ROLLBACK;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="SELECT">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name"> SELECT</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p><span class="emphasis"></span>L&acute;instruction <span class="emphasis">SELECT</span> r&eacute;cup&egrave;re des lignes, des colonnes et des valeurs d&eacute;riv&eacute;es d&acute;une ou plusieurs des tables d&acute;une base de donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations (prise en charge des jointures ANSI)</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations (prise en charge partielle des jointures ANSI)</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations (pas de prise en charge des jointures ANSI)</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations (prise en charge partielle des jointures ANSI)</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La syntaxe compl&egrave;te de l&acute;instruction <span class="emphasis">SELECT</span> allie puissance et complexit&eacute;, mais vous pouvez la d&eacute;composer en plusieurs clauses principales:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT [ALL | DISTINCT] select_listFROM table_name1 [,..., table_nameN][JOIN join_condition][WHERE search_condition][GROUP BY group_by_expression][HAVING search_condition][ORDER BY order_expression [ASC | DESC] ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Chacune des clauses de l&acute;instruction <span class="emphasis">SELECT</span> poss&egrave;de une action sp&eacute;cifique. Il est donc possible de parler individuellement de la clause <span class="emphasis">FROM</span>, de la clause <span class="emphasis">WHERE</span> ou de la clause <span class="emphasis">GROUP BY</span>. Cependant, les requ&ecirc;tes n&acute;exigent pas syst&eacute;matiquement chacune de ces clauses. Une requ&ecirc;te exige au minimum une liste d&acute;&eacute;l&eacute;ments <span class="emphasis">SELECT</span> et une clause <span class="emphasis">FROM</span>. (Microsoft SQL Server et PostgreSQL prennent tous deux en charge certains types de requ&ecirc;tes qui n&acute;exigent pas de clause <span class="emphasis">FROM</span>. Reportez-vous aux exemples ci-dessous pour plus d&acute;informations.)</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Liste d&acute;&eacute;l&eacute;ments SELECT</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La <span class="emphasis">liste d&acute;&eacute;l&eacute;ments SELECT</span> inclut en gros tous les &eacute;l&eacute;ments d&acute;information qu&acute;un utilisateur veut r&eacute;cup&eacute;rer du serveur. Elle peut contenir diff&eacute;rents types d&acute;&eacute;l&eacute;ments. Il est possible de r&eacute;cup&eacute;rer des cha&icirc;nes litt&eacute;rales, des fonctions agr&eacute;gat et des calculs math&eacute;matiques. Dans Microsoft SQL Server, la liste d&acute;&eacute;l&eacute;ments <span class="emphasis">SELECT</span> peut contenir une sous-requ&ecirc;te.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">ALL</span> est la valeur par d&eacute;faut; autrement dit, tous les enregistrements sont renvoy&eacute;s, m&ecirc;me les valeurs par d&eacute;faut. Le mot-cl&eacute; <span class="emphasis">DISTINCT</span> indique &agrave; la requ&ecirc;te de filtrer tous les enregistrements dupliqu&eacute;s. Le jeu de r&eacute;sultats ne va donc inclure qu&acute;une seule occurrence des enregistrements identiques.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Diverses autres r&egrave;gles s&acute;appliquent aux &eacute;l&eacute;ments susceptibles de figurer dans la liste d&acute;&eacute;l&eacute;ments <span class="emphasis">SELECT</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ol><li>Les colonnes voulues doivent normalement &ecirc;tre s&eacute;par&eacute;es par une virgule.</li><li>L&acute;ast&eacute;risque (*) a une fonction de raccourci pour r&eacute;cup&eacute;rer toutes les colonnes des diverses tables indiqu&eacute;es dans la clause <span class="emphasis">FROM</span>, telles qu&acute;elles apparaissent dans l&acute;instruction <span class="emphasis">CREATE TABLE</span>.</li><li>Des alias de colonne sont ajout&eacute;s afin de remplacer les en-t&ecirc;tes de colonne par d&eacute;faut utilis&eacute;s dans les r&eacute;sultats. Utilisez l&acute;<span class="emphasis">alias format column AS "alias"</span> ou l&acute;<span class="emphasis">alias de colonne</span>. Cette fonction est particuli&egrave;rement utile lorsque le libell&eacute; ou la longueur d&acute;un en-t&ecirc;te de colonne n&acute;en facilite pas la compr&eacute;hension. Par exemple:</li><li>Lorsqu&acute;elles sont prises en charge, les variables locales et globales peuvent appara&icirc;tre sous la forme d&acute;un &eacute;l&eacute;ment de liste SELECT.</li><li>Le double-tiret (<span class="emphasis">&8212;</span>) ou la combinaison barre oblique-ast&eacute;risque (<span class="emphasis"> /* ... */</span>) permettent de disperser des commentaires dans l&acute;ensemble d&acute;une instruction SQL ou Transact-SQL. Le double-tiret indique &agrave; la requ&ecirc;te d&acute;ignorer le texte qui le suit, jusqu&acute;&agrave; la fin de la ligne. La barre oblique indique &agrave; la requ&ecirc;te d&acute;ignorer le texte plac&eacute; entre la combinaison barre oblique-ast&eacute;rique et la combinaison barre oblique inverse-ast&eacute;risque.</li><li>Le nom de la table doit &ecirc;tre utilis&eacute; comme pr&eacute;fixe du nom de colonne lorsque la requ&ecirc;te porte sur plusieurs tables. Sur le plan technique, le nom de la table doit s&acute;appliquer &agrave; n&acute;importe quelle colonne des <span class="emphasis">deux</span> tables (cette proc&eacute;dure est de toute fa&ccedil;on recommand&eacute;e). Par exemple, les tables <span class="emphasis">jobs</span> et <span class="emphasis">employee</span> contiennent la colonne <span class="emphasis">job_id</span>:</li><li>Le nom du sch&eacute;ma ou du propri&eacute;taire doit porter le pr&eacute;fixe d&acute;une colonne s&acute;il provient d&acute;un contexte diff&eacute;rent de celui de l&acute;utilisateur actuel. Si la table est la propri&eacute;t&eacute; d&acute;un autre nom d&acute;utilisateur, ce dernier doit &ecirc;tre inclus dans la r&eacute;f&eacute;rence de colonne. Par exemple, supposons que cet exemple de requ&ecirc;te est ex&eacute;cut&eacute; dans la base de donn&eacute;es <span class="emphasis">PUBS</span> et qu&acute;il r&eacute;cup&egrave;re &eacute;galement des donn&eacute;es de la base de donn&eacute;es <span class="emphasis">SALES</span>:</li><li>Les expressions litt&eacute;rales peuvent servir d&acute;&eacute;l&eacute;ments de liste SELECT.</li><li>Les calculs math&eacute;matiques peuvent &ecirc;tre entr&eacute;s sous la forme d&acute;&eacute;l&eacute;ments de liste SELECT. Aucune instruction <span class="emphasis">FROM</span> n&acute;est n&eacute;cessaire dans Microsoft SQL Server. Dans Oracle, le calcul doit &ecirc;tre ex&eacute;cut&eacute; par rapport &agrave; la table syst&egrave;me <span class="emphasis">DUAL</span>. La table permet &agrave; la commande SELECT de r&eacute;cup&eacute;rer des valeurs lorsqu&acute;il n&acute;existe aucune table. Par exemple:</li></ol>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Clause FROM</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">FROM</span> a g&eacute;n&eacute;ralement une double action: elle r&eacute;pertorie les tables et les vues &agrave; partir desquelles une requ&ecirc;te a r&eacute;cup&eacute;r&eacute; ses donn&eacute;es (en s&eacute;parant les noms de table par une virgule); et elle assigne un alias aux noms de table longs, afin de faciliter nettement le codage des longues requ&ecirc;tes. Il existe deux m&eacute;thodes permettant d&acute;attribuer un alias dans la clause <span class="emphasis">FROM</span>: entrer le nom de la table, un espace et l&acute;alias; entrer le nom de la table, <span class="emphasis">AS</span> et l&acute;alias. L&acute;exemple ci-dessous illustre chacune des deux techniques. Par exemple, une requ&ecirc;te permettant de r&eacute;cup&eacute;rer des donn&eacute;es &agrave; partir de plusieurs tables peut inclure une clause <span class="emphasis">FROM</span> et <span class="emphasis">WHERE</span> cod&eacute;e comme suit:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT   e.emp_id,         e.fname,         e.lname,         j.job_descFROM     employee e,         jobs AS  jWHERE    e.job_id = j.job_idORDER BY e.fname,         e.lname</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Une fois l&acute;alias assign&eacute; dans une requ&ecirc;te, vous devez veiller &agrave; l&acute;utiliser exclusivement pour des r&eacute;f&eacute;rences de tables dans cette requ&ecirc;te. Vous <span class="emphasis">ne devez pas</span> m&eacute;langer dans une requ&ecirc;te les r&eacute;f&eacute;rences renvoyant au nom de table complet et l&acute;alias.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette requ&ecirc;te r&eacute;cup&egrave;re le <span class="emphasis">emp_id</span> (pr&eacute;nom et nom de chacun des employ&eacute;s stock&eacute;s dans la table <span class="emphasis">employee</span>) et joint le <span class="emphasis">job_id</span> de l&acute;employ&eacute; (num&eacute;ro de code) &agrave; la description de poste compl&egrave;te figurant dans la table <span class="emphasis">JOBS</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Clause JOIN </span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans les impl&eacute;mentations qui ne respectent pas les normes ANSI, l&acute;op&eacute;ration de jointure est ex&eacute;cut&eacute;e dans la clause <span class="emphasis">WHERE</span> (d&eacute;crite dans la section relative aux clauses <span class="emphasis">WHERE</span>). Dans le cadre des normes ANSI SQL-92, les jointures sont ex&eacute;cut&eacute;es dans la clause <span class="emphasis">JOIN</span> de la requ&ecirc;te. Ces m&eacute;thodes de jointure sont appel&eacute;es respectivement <span class="emphasis">style th&ecirc;ta</span> et <span class="emphasis">style ANSI</span> de jointure.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour r&eacute;cup&eacute;rer les donn&eacute;es jointes &agrave; partir de deux tables ou plus, il faut d&acute;abord que ces tables partagent une relation significative. <span class="emphasis">Les tables &agrave; joindre doivent poss&eacute;der une ou plusieurs colonnes partageant un ensemble commun de valeurs qui permette d&acute;&eacute;tablir entre elles une liaison significative.</span> On appelle <span class="emphasis">cl&eacute; de jointure</span> ou <span class="emphasis">cl&eacute; commune</span> cette colonne (ou ces colonnes). Dans la plupart des cas &8212; mais pas dans tous &8212;, la cl&eacute; de jointure correspond &agrave; la cl&eacute; primaire d&acute;une table et &agrave; la cl&eacute; &eacute;trang&egrave;re d&acute;une autre table. Les jointures sont possibles tant que les donn&eacute;es des colonnes sont en correspondance.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans la base de donn&eacute;es <span class="emphasis">PUBS</span>, les tables <span class="emphasis">employee</span> et <span class="emphasis">jobs</span> contiennent toutes les deux une colonne <span class="emphasis">job_id</span>. <span class="emphasis">job_id</span> repr&eacute;sente donc la cl&eacute; commune entre les tables <span class="emphasis">employee</span> et <span class="emphasis">jobs</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pour ex&eacute;cuter une requ&ecirc;te sur la base d&acute;une jointure de style ANSI, vous devez r&eacute;pertorier la premi&egrave;re table et le mot-cl&eacute; <span class="emphasis">JOIN</span>, suivis de la table &agrave; joindre. Une fois la seconde table entr&eacute;e, tapez le mot-cl&eacute; <span class="emphasis">ON</span> et la condition de jointure qui aurait servi dans l&acute;ancienne requ&ecirc;te. L&acute;exemple suivant illustre la requ&ecirc;te originale, maintenant en style ANSI:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT   e.emp_id,         e.fname,         e.lname,         j.job_descFROM     employee AS eJOIN     jobs AS j ON e.job_id = j.job_idORDER BY e.fname,         e.lname</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Types de jointure</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Vous pouvez r&eacute;soudre ces probl&egrave;mes en utilisant des jointures de style ANSI et la combinaisoncombinaison &eacute;gal-ast&eacute;risque (`<span class="emphasis">=*</span> ' ) pour Microsoft SQL Server ouplus-ast&eacute;risque (`<span class="emphasis">+*</span> ') pour Oracle dans les jointures th&ecirc;ta. La liste qui suit vous indique la marche &agrave; suivre pour contr&ocirc;ler ce comportement dans les jointures:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ul><li><i>Jointure crois&eacute;e</i><br>&#160;						  Sp&eacute;cifie le produit cart&eacute;sien complet de deux tables. A chaque enregistrement de la premi&egrave;re table sont joints tous les enregistrements de la seconde table, et le jeu de r&eacute;sultats est <span class="emphasis">extr&ecirc;mement volumineux</span>. Cette commande, aussi appel&eacute;e &laquo;&#160; produit cart&eacute;sien&#160;&raquo;, revient &agrave; ignorer la condition de jointure. L&acute;utilisation des jointures crois&eacute;es est vivement d&eacute;conseill&eacute;e (elles sont actuellement prises en charge par Microsoft SQL Server):</li><li><i><span class="emphasis">Jointure interne</span></i><br>&#160;						  Indique qu&acute;il faut &eacute;liminer les lignes sans correspondance dans les deux tables de la jointure. Si aucun type de jointure n&acute;est explicitement d&eacute;fini dans le style ANSI, le style par d&eacute;faut est utilis&eacute; (cette fonction est actuellement prise en charge par Microsoft SQL Server, PostgreSQL et MySQL):</li><li><i><span class="emphasis">Jointure [externe] gauche</span></i><br>&#160;Sp&eacute;cifie que les enregistrements doivent tous &ecirc;tre renvoy&eacute;s &agrave; partir de la table plac&eacute;e dans la partie gauche de l&acute;instruction join. Si un enregistrement provenant de la table gauche ne dispose d&acute;aucun enregistrement correspondant dans la table droite de la jointure, il est quand m&ecirc;me renvoy&eacute;. Les colonnes plac&eacute;es dans la table de droite renvoient des valeurs NULL. (Dans ce cas, tous les enregistrements de la table employees sont renvoy&eacute;s, qu&acute;ils poss&egrave;dent ou non une description de poste.) Les sp&eacute;cialistes recommandent souvent, dans le mesure du possible, de configurer les jointures externes en tant que jointures gauches par souci de coh&eacute;rence (cette fonction est actuellement prise en charge par Microsoft SQL Server):</li><li><i><span class="emphasis">Jointure [externe] droite</span></i><br>&#160;						  Sp&eacute;cifie que les enregistrements doivent tous &ecirc;tre renvoy&eacute;s &agrave; partir de la table plac&eacute;e dans la partie droite de l&acute;instruction join, m&ecirc;me si la table de gauche ne poss&egrave;de aucun enregistrement correspondant. Les colonnes plac&eacute;es dans la table de gauche renvoient des valeurs NULL. (Dans l&acute;exemple, tou les enregistrements de la table <span class="emphasis">jobs</span> sont renvoy&eacute;s avec ou sans enregistrement correspondant dans la table <span class="emphasis">employee</span> [cette fonction est actuellement prise en charge par Microsoft SQL Server]):</li><li><i><span class="emphasis">Jointure compl&egrave;te</span></i><br>&#160;						  Sp&eacute;cifie que les lignes des deux tables doivent toutes &ecirc;tre renvoy&eacute;es, quels que soient les enregistrements correspondants dans l&acute;autre table. Le jeu de r&eacute;sultats indique des valeurs NULL s&acute;il n&acute;existe aucune donn&eacute;e dans la jointure (cette fonction est actuellement prise en charge par Microsoft SQL Server):</li></ul>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il est actuellement plus facile de comprendre les jointures dans le style ANSI que dans le style th&ecirc;ta, puisque la requ&ecirc;te indique clairement la table qui se trouve dans la partie gauche d&acute;une instruction <span class="emphasis">LEFT JOIN</span> et celle qui se trouve dans la partie droite d&acute;une instruction <span class="emphasis">RIGHT JOIN</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La syntaxe &agrave; utiliser pour ex&eacute;cuter une requ&ecirc;te similaire sur la base de cl&eacute;s complexes et de tables jointes repose dans une large mesure sur une extension de la m&ecirc;me technique.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple de jointure multitable</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>--Requ&ecirc;te dans le style th&ecirc;ta avec tables multiplesSELECT   a.au_lname,         a.au_fname,         t2.titleFROM     authors a,         titleauthor t1,         titles t2WHERE    a.au_id     = t1.au_id  AND    t1.title_id = t2.title_idORDER BY t2.title-- Requ&ecirc;te dans le style ANSI avec tables multiplesSELECT   a.au_lname,         a.au_fname,         t2.titleFROM     authors aJOIN     titleauthor AS t1 ON a.au_id     = t1.au_idJOIN     titles      AS t2 ON t1.title_id = t2.title_idORDER BY t2.title</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple de jointure multicl&eacute;:</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>--Requ&ecirc;te dans le style th&ecirc;ta avec cl&eacute;s multiplesSELECT   s1.store_id,         s1.title_id,         s2.qtyFROM     sales s1,         sales_projections s2WHERE    s1.store_id = s2.store_id  AND  s1.title_id = s2.title_idORDER BY s1.store_id, s2.title_id-- Requ&ecirc;te dans le style ANSI avec cl&eacute;s multiplesSELECT   s1.store_id,         s1.title_id,         s2.qtyFROM     sales s1JOIN     sales_projections s2 ON s1.store_id = s2.store_id   AND   s1.title_id = s2.title_idORDER BY s1.store_id, s2.title_id</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Clause WHERE</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">WHERE</span>  est un composant extr&ecirc;mement puissant de l&acute;instruction <span class="emphasis">SELECT</span>. La clause <span class="emphasis">WHERE</span> fournit la plupart des conditions de recherche permettant d&acute;&eacute;liminer de la requ&ecirc;te les donn&eacute;es ind&eacute;sirables; les conditions de recherche restantes sont satisfaites sur la base de la clause <span class="emphasis">HAVING</span> (pr&eacute;sent&eacute;e dans la suite de cette section).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Une clause <span class="emphasis">WHERE</span> mal con&ccedil;ue peut ruiner une bonne instruction <span class="emphasis">SELECT</span>; il convient donc de <span class="emphasis">ma&icirc;triser</span> dans ses moindres nuances la clause <span class="emphasis">WHERE</span>. L&acute;exemple qui suit illustre une requ&ecirc;te type et une clause <span class="emphasis">WHERE</span> en plusieurs parties:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT   a.au_lname,         a.au_fname,         t2.title,         convert(char,t2.pubdate)FROM     authors aJOIN     titleauthor t1 ON a.au_id = t1.au_idJOIN     titles t2 ON t1.title_id = t2.title_idWHERE    (t2.type = 'business' OR t2.type = 'popular_comp')  AND    t2.advance &gt; $5500ORDER BY t2.title</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Lorsque vous examinez la requ&ecirc;te, vous pouvez remarquer que les parenth&egrave;ses d&eacute;terminent l&acute;ordre de traitement des crit&egrave;res <span class="emphasis">WHERE</span> sur la base de la <span class="emphasis">priorit&eacute; des op&eacute;rateurs</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;<span class="emphasis">ordre de tri</span> par d&eacute;faut de la base de donn&eacute;es d&eacute;termine la mani&egrave;re dont la clause <span class="emphasis">WHERE</span> r&eacute;cup&egrave;re le jeu de r&eacute;sultats pour une requ&ecirc;te. Par exemple, Microsoft SQL Server, qui allie (par d&eacute;faut) l&acute;<span class="emphasis">ordre dictionnaire</span> et l&acute;<span class="emphasis">insensibilit&eacute; &agrave; la casse</span>, ne fait aucune diff&eacute;rence entre &laquo;&#160; Smith&#160;&raquo;, &laquo;&#160; smith&#160;&raquo; et &laquo;&#160; SMITH&#160;&raquo;. En revanche, Oracle, qui allie l&acute;<span class="emphasis">ordre dictionnaire</span> et la <span class="emphasis">sensibilit&eacute; &agrave; la casse</span>, diff&eacute;rencie les valeurs &laquo;&#160; Smith&#160;&raquo;, &laquo;&#160; smith&#160;&raquo; et &laquo;&#160; SMITH&#160;&raquo;.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">WHERE</span> propose davantage de fonctions sp&eacute;cifiques que cet exemple ne l&acute;illustre. Le Tableau 3.9 propose un bref r&eacute;capitulatif des fonctions communes de la clause <span class="emphasis">WHERE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Forme courte de condition de recherche</th><th>Syntaxe</th><th>Exemple</th><th>Usage et description</th></tr>
								<tr><td>V&eacute;rification bool&eacute;enne simple</td>
									<td><pre>WHERE [NOT] expressioncomparison_operator  expression</pre>
									</td>
									<td><pre>SELECT au_idFROM   authorsWHERE  au_id = '172-32-1176'SELECT au_idFROM   authorsWHERE  au_lname NOT LIKE 'John%'</pre>
									</td><td>Les op&eacute;rateurs &lt;, &gt;, &lt;&gt;, &gt;=, &lt;= et = permettent de comparer des expressions. Il existe de plus divers op&eacute;rateurs de comparaison sp&eacute;ciaux (<span class="emphasis">LIKE</span>, par exemple), dont vous trouverez la description dans la suite de ce tableau. Le mot-cl&eacute; <span class="emphasis">NOT</span> inverse les v&eacute;rifications bool&eacute;ennes sur la base des op&eacute;rateurs normaux &lt;, &gt;, &lt;&gt;, &gt;=, &lt;= et =, en plus des op&eacute;rateurs sp&eacute;ciaux tels que <span class="emphasis">LIKE</span>, <span class="emphasis">NULL</span>, <span class="emphasis">BETWEEN</span>, <span class="emphasis">IN</span>, <span class="emphasis">EXISTS</span>, <span class="emphasis">ANY,</span> et <span class="emphasis">ALL</span>.</td>
								</tr>
								<tr><td>Conditions de recherche multiples</td>
									<td><pre>WHERE [NOT] expressioncomparison_operator expression{AND | OR}expression comparison_operatorexpression</pre>
									</td>
									<td><pre>SELECT au_idFROM   authorsWHERE  au_id = '172-32-1176'  AND  au_lname = 'White'</pre>
									</td><td><span class="emphasis">AND</span> fusionne plusieurs conditions et renvoie les r&eacute;sultats lorsque <span class="emphasis">les deux</span> conditions ont la valeur true. <span class="emphasis">AND</span> a priorit&eacute; sur les autres op&eacute;rateurs.Les parenth&egrave;ses utilis&eacute;es dans la clause <span class="emphasis">WHERE</span> ont une incidence suppl&eacute;mentaire sur la priorit&eacute; des op&eacute;rateurs. <span class="emphasis">OR</span> fusionne plusieurs conditions et renvoie les r&eacute;sultats lorsque <span class="emphasis">l&acute;une</span> des conditions a la valeur true. <span class="emphasis">OR</span> occupe le second niveau de priorit&eacute; apr&egrave;s <span class="emphasis">AND</span>.</td>
								</tr>
								<tr><td>V&eacute;rification <span class="emphasis">NULL</span></td>
									<td><pre>WHERE [NOT] column_name IS [NOT]NULL</pre>
									</td>
									<td><pre>SELECT *FROM   titlesWHERE  price IS NULL</pre>
									</td><td><span class="emphasis">IS NULL</span> et <span class="emphasis">IS NOT NULL</span> indique &agrave; la requ&ecirc;te de rechercher les valeurs null (ou toutes les valeurs sauf les valeurs null).</td>
								</tr>
								<tr><td>V&eacute;rification <span class="emphasis">JOIN</span></td><td><pre>WHERE [NOT] column_value(s)[(+)]=[(+)] column_value(s)</pre> Ou<pre>WHERE [NOT] column_value(s)[*]=[*] column_value(s)</pre>
									</td>
									<td><pre>SELECT a.au_lname,       a.au_fname,       t2.titleFROM  authors a,      titleauthor t1,      titles t2WHERE a.au_id = t1.au_id  AND t1.title_id = t2.title_idORDER BY t2.title</pre>
									</td><td>Une v&eacute;rification <span class="emphasis">JOIN</span> repose sur l&acute;&eacute;valuation de la cl&eacute; commune entre deux tables au moins. Pour ex&eacute;cuter des jointures externes dans PostgreSQL, il faut ajouter l&acute;ast&eacute;risque sur le c&ocirc;t&eacute; &agrave; partir duquel les enregistrements seront r&eacute;cup&eacute;r&eacute;s. Dans Oracle, les jointures externes sont activ&eacute;es par l&acute;ajout, sur le c&ocirc;t&eacute; pour lequel les valeurs null sont autoris&eacute;es, du signe plus entre parenth&egrave;ses (+) [cette m&eacute;thode est, dans ses grandes lignes, l&acute;inverse de la m&eacute;thode reposant sur l&acute;emploi de l&acute;ast&eacute;risque]. Reportez-vous &agrave; la section pr&eacute;c&eacute;dente relative aux clauses <span class="emphasis">JOIN</span> pour de plus amples informations.</td>
								</tr>
								<tr><td>V&eacute;rification <span class="emphasis">LIKE</span></td>
									<td><pre>WHERE [NOT] column_name [NOT]LIKE 'match_string'</pre>
									</td>
									<td><pre>/* get any phone number starting with 415 */SELECT * FROM authorsWHERE phone LIKE '415%'</pre>
									</td><td><span class="emphasis">LIKE</span> indique &agrave; la requ&ecirc;te d&acute;utiliser le mod&egrave;le correspondant sur la cha&icirc;ne entre guillemets. Les symboles g&eacute;n&eacute;riques sont d&eacute;taill&eacute;s sous l&acute;entr&eacute;e <span class="emphasis">LIKE</span>.</td>
								</tr>
								<tr><td>V&eacute;rification <span class="emphasis">EXIST</span></td>
									<td><pre>WHERE [NOT] EXISTS (subquery)</pre>
									</td>
									<td><pre>SELECT p1.pub_nameFROM publishers p1WHERE EXISTS    (SELECT *    FROM titles t1    WHERE pub_id =p1.pub_id      AND type =      'psychology')</pre>
									</td><td><span class="emphasis">EXISTS</span> s&acute;utilise toujours dans le cadre d&acute;une sous-requ&ecirc;te; cette sous-requ&ecirc;te ne renvoie pas de donn&eacute;es, mais elle d&eacute;termine l&acute;existence des donn&eacute;es, sur la base de tests bool&eacute;ens. L&acute;exemple qui suit permet de renvoyer tous les &eacute;diteurs publiant des livres de psychologie.</td>
								</tr>
								<tr><td>V&eacute;rification de plage <span class="emphasis">BETWEEN</span></td>
									<td><pre>WHERE [NOT] expression [NOT] BETWEEN expression AND expression</pre>
									</td>
									<td><pre>SELECT *FROM titlesWHERE ytd_sales BETWEEN 4000 AND 9000</pre>
									</td><td><span class="emphasis">BETWEEN</span> ex&eacute;cute une v&eacute;rification de plage inclusive. Elle est identique &agrave; <span class="emphasis">WHERE</span><span class="emphasis">(expression</span>&gt;= <span class="emphasis">x et expression</span>&lt;= <span class="emphasis">y).</span></td>
								</tr>
								<tr><td>V&eacute;rification de plage <span class="emphasis">IN</span></td>
									<td><pre>WHERE [NOT] expression [NOT] IN(value_list | subquery)</pre>
									</td>
									<td><pre>SELECT *FROM storesWHERE state IN ('WA','IL','NY')SELECT *FROM storesWHERE stor_id IN  (SELECT stor_id  FROM sales  WHERE ord_date LIKE  'Oct%')</pre>
									</td><td><span class="emphasis">IN</span> renvoie soit un jeu de r&eacute;sultats correspondant &agrave; l&acute;une des listes de valeurs, soit un jeu de r&eacute;sultats de la requ&ecirc;te externe dont les valeurs correspondent &agrave; celles renvoy&eacute;es par une sous-requ&ecirc;te. La <span class="emphasis">value_list</span> ou la sous-requ&ecirc;te doivent &ecirc;tre plac&eacute;es entre parenth&egrave;ses.</td>
								</tr>
								<tr><td>V&eacute;rification de plage <span class="emphasis">SOME | ALL</span></td>
									<td><pre>WHERE [NOT] expressioncomparison_operator{[ANY | SOME] | ALL} (subquery)</pre>
									</td>
									<td><pre>-- Pour dupliquer la fonctionnalit&eacute; de INSELECT au_lname,       au_fnameFROM   authorsWHERE city = ANY    (SELECT city     FROM   publishers)-- Pour dupliquer la fonctionnalit&eacute; de NOT INSELECT au_lname,       au_fnameFROM authorsWHERE city &lt;&gt; ALL    (SELECT city     FROM   publishers)/* to find the titles that got anadvance larger than the minimumadvance amount paid New Moon Books*/SELECT titleFROM   titlesWHERE  advance &gt; ANY    (SELECT  advance     FROM publishers,      titles     WHERE titles.pub_id =       publishers.pub_id     AND pub_name = 'New       Moon Books')</pre>
									</td><td><span class="emphasis">ALL</span> et <span class="emphasis">SOME</span> s&acute;utilisent toujours dans le cadre d&acute;une sous-requ&ecirc;te, avec un op&eacute;rateur de comparaison (&lt;, &gt;, &lt;&gt;, &gt;= ou &lt;=, par exemple). Une requ&ecirc;te de type <span class="emphasis">ALL</span> &eacute;value si la valeur TRUE ou FALSE s&acute;applique lorsque <span class="emphasis">toutes</span> les valeurs r&eacute;cup&eacute;r&eacute;es par la sous-requ&ecirc;te correspondent &agrave; la valeur de la clause <span class="emphasis">WHERE</span> (ou <span class="emphasis">HAVING</span>), ou bien lorsque la sous-requ&ecirc;te ne renvoie aucune ligne de l&acute;instruction externe.<span class="emphasis">SOME</span> poss&egrave;de la m&ecirc;me fonctionnalit&eacute; que <span class="emphasis">EXISTS</span>. Elle fonctionne de la m&ecirc;me mani&egrave;re que la clause <span class="emphasis">ALL</span>, avec une diff&eacute;rence: elle renvoie TRUE lorsque <span class="emphasis">l&acute;une</span> des valeurs r&eacute;cup&eacute;r&eacute;es dans la sous-requ&ecirc;te respecte le pr&eacute;dicat de comparaison inclus dans la clause <span class="emphasis">WHERE</span> de l&acute;instruction externe.</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Comme indiqu&eacute; dans le Tableau 3.9,  les caract&egrave;res g&eacute;n&eacute;riques peuvent accro&icirc;tre les options de recherche, notamment s&acute;ils sont utilis&eacute;s avec l&acute;op&eacute;rateur <span class="emphasis">LIKE</span>. Reportez-vous &agrave; la rubrique <span class="emphasis">LIKE</span> pour de plus amples informations sur les types d&acute;op&eacute;rations g&eacute;n&eacute;riques.<span class="emphasis"></span> </p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Agr&eacute;gats et clause GROUP BY</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">GROUP BY</span> (et la clause <span class="emphasis">HAVING</span>) sont uniquement requises dans les requ&ecirc;tes qui utilisent les <span class="emphasis">fonctions agr&eacute;gat</span> (voir le d&eacute;but de ce chapitre). Les requ&ecirc;tes qui utilisent les fonctions agr&eacute;gat proposent divers types d&acute;informations r&eacute;capitulatives. Les fonctions agr&eacute;gat les plus courantes sont les suivantes:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ol><li><span class="emphasis">AVG</span> renvoie la moyenne de toutes les valeurs diff&eacute;rentes de NULL dans la ou les colonnes sp&eacute;cifi&eacute;es.</li><li><span class="emphasis">COUNT</span> compte le nombre d&acute;occurrences de toutes les valeurs diff&eacute;rentes de NULL dans la ou les colonnes sp&eacute;cifi&eacute;es.</li><li><span class="emphasis">COUNT DISTINCT</span> compte le nombre d&acute;occurrences de toutes les valeurs uniques diff&eacute;rentes de NULL dans la ou les colonnes sp&eacute;cifi&eacute;es.</li><li><span class="emphasis">COUNT(*)</span> compte tous les enregistrements de la table.</li><li><span class="emphasis">MAX</span> renvoie la plus &eacute;lev&eacute;e des valeurs diff&eacute;rentes de NULL dans la ou les colonnes sp&eacute;cifi&eacute;es.</li><li><span class="emphasis">MIN </span>renvoie la plus basse des valeurs diff&eacute;rentes de NULL dans la ou les colonnes sp&eacute;cifi&eacute;es.</li><li><span class="emphasis">SUM </span>effectue le total de toutes les valeurs diff&eacute;rentes de NULL dans la ou les colonnes sp&eacute;cifi&eacute;es.</li></ol>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La limitation des fonctions agr&eacute;gat concerne les types de donn&eacute;es auxquelles elles peuvent s&acute;appliquer. Seules les fonctions <span class="emphasis">COUNT</span> et <span class="emphasis">COUNT DISTINCT</span> peuvent s&acute;appliquer &agrave; une colonne contenant n&acute;importe quel type de donn&eacute;es. <span class="emphasis">MIN</span> et <span class="emphasis">MAX</span> s&acute;appliquent aux colonnes num&eacute;riques (quel qu&acute;en soit le type), ainsi qu&acute;aux colonnes de date et de caract&egrave;res. Les fonctions <span class="emphasis">SUM</span> et <span class="emphasis">AVG</span> s&acute;appliquent uniquement aux colonnes contenant des donn&eacute;es de type num&eacute;rique.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Si vous devez appliquer les fonctions agr&eacute;gat &agrave; des colonnes contenant des valeurs null, utilisez la fonction <span class="emphasis">ISNULL( )</span> dans SQL Server ou la fonction <span class="emphasis">NVL</span> dans Oracle pour attribuer une valeur aux colonnes null.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>On appelle valeurs d&acute;<span class="emphasis">agr&eacute;gat scalaire</span> les requ&ecirc;tes qui ne renvoient qu&acute;une seule valeur. La clause <span class="emphasis">GROUP BY</span> est inutile dans le cas des agr&eacute;gats scalaires. Par exemple:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>--Requ&ecirc;teSELECT AVG(price)FROM titles--R&eacute;sultats14.77</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>On appelle <span class="emphasis">agr&eacute;gats vectoriels</span> les requ&ecirc;tes qui renvoient &agrave; la fois des valeurs de colonne et des fonctions agr&eacute;gat. Les agr&eacute;gats vectoriels utilisent la clause <span class="emphasis">GROUP BY</span> et renvoient au moins une ligne. Il convient de suivre les r&egrave;gles suivantes lorsque vous utilisez la clause <span class="emphasis">GROUP BY</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ol><li>Respectez l&acute;ordre de la clause <span class="emphasis">GROUP BY</span> &8212; apr&egrave;s la clause <span class="emphasis">WHERE</span> et avant la clause <span class="emphasis">ORDER BY</span>.</li><li>Incluez toutes les colonnes qui ne se rapportent pas aux agr&eacute;gats dans la clause <span class="emphasis">GROUP BY</span>.</li><li>N&acute;utilisez aucun alias de colonne dans la clause <span class="emphasis">GROUP BY</span> (les alias de table sont autoris&eacute;s).</li></ol>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Supposons que vous voulez conna&icirc;tre le nombre d&acute;employ&eacute;s affect&eacute;s aux divers postes de votre entreprise:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>--Requ&ecirc;teSELECT   j.job_desc AS "Job Description",         COUNT(e.job_id) AS "Nbr in Job"FROM     employee eJOIN     jobs j ON e.job_id = j.job_idGROUP BY j.job_desc--R&eacute;sultatsJob Description                                    Nbr in Job-------------------------------------------------- -----------Acquisitions Manager                               4Business Operations Manager                        1Chief Executive Officer                            1Chief Financial Officer                            1Designer                                           3Editor                                             3Managing Editor                                    4Marketing Manager                                  4Operations Manager                                 4Productions Manager                                4Public Relations Manager                           4Publisher                                          7Sales Representative                               3</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Clause HAVING</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">HAVING</span> ajoute des conditions de recherche au r&eacute;sultat de la clause <span class="emphasis">GROUP BY</span>. Elle n&acute;a aucune incidence sur les lignes qui servent au calcul des agr&eacute;gats, mais elle affecte uniquement les lignes renvoy&eacute;es par la requ&ecirc;te.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le fonctionnement de la clause <span class="emphasis">HAVING</span> est tr&egrave;s similaire &agrave; celui de la clause <span class="emphasis">WHERE</span>. La clause <span class="emphasis">HAVING</span> utilise les m&ecirc;mes conditions de recherche que la clause WHERE pr&eacute;sent&eacute;e dans le Tableau 3.9.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Par exemple, si vous voulez trouver les postes qui comptent plus de trois employ&eacute;s:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>--Requ&ecirc;teSELECT   j.job_desc "Job Description",         COUNT(e.job_id) "Nbr in Job"FROM     employee eJOIN     jobs j ON e.job_id = j.job_idGROUP BY j.job_descHAVING   COUNT(e.job_id) &gt; 3--R&eacute;sultatsJob Description                                    Nbr in Job-------------------------------------------------- -----------Acquisitions Manager                               4Managing Editor                                    4Marketing Manager                                  4Operations Manager                                 4Productions Manager                                4Public Relations Manager                           4Publisher                                          7</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">HAVING</span> ne doit pas servir &agrave; supprimer les lignes que la clause <span class="emphasis">WHERE</span> permet de supprimer. Les conditions relatives &agrave; la clause <span class="emphasis">HAVING</span> doivent toujours inclure des valeurs d&acute;agr&eacute;gat.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Clause ORDER BY</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Vous pouvez trier un jeu de r&eacute;sultats sur la base de la clause <span class="emphasis">ORDER BY</span>, conform&eacute;ment &agrave; l&acute;ordre de tri d&eacute;fini pour la base de donn&eacute;es<span class="emphasis">.</span> Le jeu de r&eacute;sultats peut ainsi &ecirc;tre tri&eacute; par ordre ascendant (<span class="emphasis">ASC</span>) ou descendant (<span class="emphasis">DESC</span>). (Le tri est ascendant par d&eacute;faut.) Par exemple:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>--REQU&Ecirc;TESELECT   e.emp_id "Emp ID",         rtrim(e.fname) || " " || rtrim(e.lname) "Name",         j.job_desc "Job Desc"FROM     employee e,         jobs jWHERE    e.job_id = j.job_id  AND    j.job_desc = 'Acquisitions Manager'ORDER BY e.fname DESC,         e.lname ASC--RESULTATSEmp ID    Name                           Job Desc--------- ------------------------------ --------------------M-R38834F Martine Ranc&eacute;                  Acquisitions ManagerMAS70474F Margaret Smith                 Acquisitions ManagerKJJ92907F Karla Jablonski                Acquisitions ManagerGHT50241M Gary Thomas                    Acquisitions Manager</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Une fois restreint sur la base des conditions de recherche, le jeu de r&eacute;sultats fait l&acute;objet d&acute;un tri descendant par nom des auteurs. Si deux auteurs portent le m&ecirc;me nom, le tri s&acute;effectue sur la base de leur pr&eacute;nom, par ordre ascendant.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les impl&eacute;mentations trait&eacute;es dans le cadre de ce document permettent toutes d&acute;utiliser les positions ordinales dans la clause <span class="emphasis">ORDER_BY</span>. Pour d&eacute;finir l&acute;ordre du jeu de r&eacute;sultats, vous pouvez sp&eacute;cifier le nombre entier correspondant &agrave; la position de la colonne, plut&ocirc;t que le nom ou l&acute;alias de cette derni&egrave;re. Par exemple, si vous voulez d&eacute;finir l&acute;ordre suivant: <span class="emphasis">au_id</span>, <span class="emphasis">au_ fname</span> et <span class="emphasis">au_lname</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT au_fname, au_lname, au_idFROM authorsORDER BY 3, 1, 2</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>En r&egrave;gle g&eacute;n&eacute;rale, utilisez la clause ORDER BY si vous voulez contr&ocirc;ler l&acute;ordre du jeu de r&eacute;sultats de la requ&ecirc;te. Si aucune clause <span class="emphasis">ORDER BY</span> n&acute;est sp&eacute;cifi&eacute;e, les impl&eacute;mentations renvoient les donn&eacute;es, suivant l&acute;ordre physique des donn&eacute;es de la table ou l&acute;ordre de tout index employ&eacute; par la requ&ecirc;te. Cette proc&eacute;dure peut entra&icirc;ner des probl&egrave;mes en cas de modification de l&acute;index ou de l&acute;ordre de tri physique. Pensez &agrave; sp&eacute;cifier explicitement l&acute;ordre voulu.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server </span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis"></span>Microsoft propose diverses variations de l&acute;instruction <span class="emphasis">SELECT</span>, notamment des conseils d&acute;optimisation, la clause <span class="emphasis">INTO</span>, la clause <span class="emphasis">TOP</span>, les variations <span class="emphasis">GROUP BY</span>, <span class="emphasis">COMPUTE</span> et <span class="emphasis">WITH OPTIONS</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">SELECT . . . INTO</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT select_listINTO   new_table_nameFROM   table_sourceWHERE  clause</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La fonction <span class="emphasis">SELECT . . . INTO</span>  est une option de commande quelque peu sujette &agrave; controverse propre &agrave; SQL Server. La commande <span class="emphasis">SELECT . . . INTO</span> permet de copier rapidement dans une nouvelle table les lignes et les colonnes extraites d&acute;autres tables, sur la base d&acute;une op&eacute;ration non inscrite.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;exemple qui suit cr&eacute;e la table <span class="emphasis">non_mgr_employees</span> au moyen de <span class="emphasis">SELECT . . . INTO</span>. Cette table contient le num&eacute;ro (<span class="emphasis">emp_id</span>), le pr&eacute;nom et le nom de tous les employ&eacute;s (&agrave; l&acute;exception des cadres) figurant dans la table <span class="emphasis">employee</span>, assortis de leur description de poste, extraite de la table <span class="emphasis">jobs</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>--REQU&Ecirc;TESELECT   e.emp_id "emp_id",         convert(char(25),rtrim(e.fname) + " " + rtrim(e.lname)) "name",         substring(j.job_desc,1,30) "job_desc"INTO     non_mgr_employeeFROM     employee e    JOIN jobs AS j ON e.job_id = j.job_idWHERE    j.job_desc NOT LIKE '%MANAG%'ORDER BY 2,3,1</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Vous pouvez maintenant consulter la table <span class="emphasis">non_mgr_employee</span> que vous venez de cr&eacute;er et de charger. Une requ&ecirc;te simple renvoie les donn&eacute;es suivantes:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>--REQU&Ecirc;TESELECT   emp_id,         name,         job_descFROM     non_mgr_empORDER BY 3,2,1--RESULTATSemp_id    name                      job_desc--------- ------------------------- ------------------------------PTC11962M Philip Cramer             Chief Executive OfficerF-C16315M Francisco Chang           Chief Financial Officer&lt;...edited for brevity...&gt;PMA42628M Paolo Accorti             Sales RepresentativeTPO55093M Timothy O'Rourke          Sales Representative</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Vous devez uniquement utiliser <span class="emphasis">SELECT . . . INTO</span> dans un code de d&eacute;veloppement ou un autre code non li&eacute; &agrave; la production.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Clause TOP</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">TOP</span> respecte la syntaxe suivante:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT [TOP n [PERCENT] [WITH TIES]] select listFROM table_name</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette commande indique que seules les <span class="emphasis">n</span> premi&egrave;res lignes doivent &ecirc;tre r&eacute;cup&eacute;r&eacute;es dans le jeu de r&eacute;sultats de la requ&ecirc;te. Si un pourcentage est &eacute;galement sp&eacute;cifi&eacute;, seuls les <span class="emphasis">n</span> % des lignes seront r&eacute;cup&eacute;r&eacute;s. Le mot-cl&eacute; <span class="emphasis">WITH TIES</span> s&acute;utilise uniquement dans les requ&ecirc;tes qui incluent une clause <span class="emphasis">ORDER BY</span>. Cette variation indique que des lignes suppl&eacute;mentaires seront renvoy&eacute;es depuis le jeu de r&eacute;sultats de base, en fonction de la valeur incluse dans la clause <span class="emphasis">ORDER BY</span>; ces lignes seront plac&eacute;es &agrave; la fin des lignes <span class="emphasis">TOP</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Variations GROUP BY</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">GROUP BY</span>  prend en charge dans Microsoft SQL Server les variations <span class="emphasis">ALL</span>, <span class="emphasis">WITH CUBE</span> et <span class="emphasis">WITH ROLLUP</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>[ GROUP BY [ALL] <span class="replaceable">group_by_expression </span>[,...n][ WITH { CUBE | ROLLUP } ] ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Avec la variation <span class="emphasis">ALL</span>, le jeu de r&eacute;sultats contient obligatoirement la totalit&eacute; des groupes, m&ecirc;me ceux dont les lignes ne correspondent &agrave; aucun des filtres de la clause <span class="emphasis">WHERE</span>. <span class="emphasis">ALL</span> est incompatible avec <span class="emphasis">CUBE</span> ou <span class="emphasis">ROLLUP</span>. <span class="emphasis">CUBE</span> indique qu&acute;il faut extraire des lignes r&eacute;capitulatives suppl&eacute;mentaires avec le jeu de r&eacute;sultats, pour toutes les combinaisons de groupe et de sous-groupe. Le fonctionnement de <span class="emphasis">ROLLUP</span> est similaire &agrave; celui de <span class="emphasis">CUBE</span>, sauf qu&acute;il renvoie des groupes par ordre hi&eacute;rarchique r&eacute;capitulatif &8212; du niveau le plus bas au niveau le plus &eacute;lev&eacute; du groupe.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Clause COMPUTE</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">COMPUTE</span> g&eacute;n&egrave;re des totaux qui s&acute;affichent sous la forme de colonnes r&eacute;capitulatives suppl&eacute;mentaires &agrave; la fin du jeu de r&eacute;sultats. La clause <span class="emphasis">COMPUTE BY</span> g&eacute;n&egrave;re des interruptions de contr&ocirc;le et des sous-totaux dans le jeu de r&eacute;sultats. Vous pouvez inclure les clauses <span class="emphasis">COMPUTE BY</span> et <span class="emphasis">COMPUTE</span> dans la m&ecirc;me requ&ecirc;te:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>[ COMPUTE { { AVG | COUNT | MAX | MIN | STDEV | STDEVP |VAR | VARP | SUM }(expression) } [,...n][ BY expression [,...n] ] ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les arguments (<span class="emphasis">AVG</span>, <span class="emphasis">COUNT</span>, <span class="emphasis">MAX</span>, <span class="emphasis">MIN</span>, <span class="emphasis">STDEV</span>, <span class="emphasis">STDEVP</span>, <span class="emphasis">VAR</span>, <span class="emphasis">VARP</span>, <span class="emphasis">SUM</span> ) sp&eacute;cifient l&acute;agr&eacute;gation que la clause <span class="emphasis">COMPUTE</span> doit ex&eacute;cuter. La valeur <span class="emphasis">expression</span> correspond normalement &agrave; un nom de colonne. La valeur <span class="emphasis">BY expression</span> correspond &agrave; une ou plusieurs des colonnes indiqu&eacute;es dans la clause <span class="emphasis">ORDER BY</span> des requ&ecirc;tes. <span class="emphasis">COMPUTE</span> figure dans une requ&ecirc;te &agrave; la suite de la clause <span class="emphasis">ORDER BY</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Clause OPTION</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">OPTION</span> est la derni&egrave;re clause susceptible d&acute;appara&icirc;tre dans une requ&ecirc;te Microsoft SQL Server. Elle indique qu&acute;il convient d&acute;utiliser une <span class="emphasis">astuce de requ&ecirc;te</span> pour l&acute;ensemble de la requ&ecirc;te. Les astuces de requ&ecirc;te repr&eacute;sentent une m&eacute;thode qui permet d&acute;outrepasser le traitement par d&eacute;faut d&acute;une requ&ecirc;te (cette m&eacute;thode ne s&acute;inscrit pas dans la norme ANSI). Les astuces de requ&ecirc;te, de m&ecirc;me que la syntaxe et l&acute;utilisation compl&egrave;tes de la clause <span class="emphasis">OPTION</span> d&eacute;passent le cadre de cet ouvrage; vous pourrez toutefois trouver plus de d&eacute;tails dans la documentation SQL Server.<span class="emphasis"></span></p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxes et variations dans MySQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT [STRAIGHT_JOIN][SQL_SMALL_RESULT][SQL_BIG_RESULT][HIGH_PRIORITY][INTO {OUTFILE | DUMPFILE} 'file_name' options]FROM...JOIN...[LIMIT [[offset_record,] number_of_rows]];</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les extensions MySQL incluent les modifications apport&eacute;es au mot-cl&eacute; <span class="emphasis">SELECT</span> par d&eacute;faut, la prise en charge partielle de <span class="emphasis">JOIN</span>, la clause <span class="emphasis">LIMIT</span> et la clause <span class="emphasis">PROCEDURE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">STRAIGHT_ JOIN</span> est la premi&egrave;re extension &agrave; la clause <span class="emphasis">SELECT</span> par d&eacute;faut. <span class="emphasis">STRAIGHT_JOIN</span> force l&acute;optimiseur &agrave; joindre les tables en suivant l&acute;ordre exact dans lequel elles figurent dans la clause FROM. Il est possible d&acute;utiliser <span class="emphasis">SQL_SMALL_RESULT</span> et <span class="emphasis">SQL_BIG_RESULT</span> lorsque la requ&ecirc;te inclut une clause <span class="emphasis">GROUP BY</span> ou une clause <span class="emphasis">DISTINCT</span>, afin d&acute;indiquer &agrave; l&acute;optimiseur que le jeu de r&eacute;sultats attendu sera respectivement petit ou volumineux. Puisque MySQL cr&eacute;e une table temporaire si une requ&ecirc;te poss&egrave;de une clause <span class="emphasis">DISTINCT</span> ou <span class="emphasis">GROUP BY</span>, ces clauses optionnelles indiquent &agrave; MySQL de cr&eacute;er une table temporaire rapide dans la m&eacute;moire (pour <span class="emphasis">SQL_SMALL_RESULT</span>) et une table temporaire plus lente sur disque (pour <span class="emphasis">SQL_BIG_RESULT</span>) en vue de traiter la table de travail. <span class="emphasis">HIGH_PRIORITY</span> conf&egrave;re &agrave; la requ&ecirc;te un niveau de priorit&eacute; plus &eacute;lev&eacute; que celui des instructions qui servent &agrave; modifier les donn&eacute;es de la table. Cette clause doit &ecirc;tre r&eacute;serv&eacute;e aux requ&ecirc;tes rapides sp&eacute;ciales. La clause <span class="emphasis">LIMIT</span> limite le nombre de lignes renvoy&eacute;es par la requ&ecirc;te, &agrave; partir de <span class="emphasis">offset_record</span> et <span class="emphasis">returning number_of_rows</span>. Si vous n&acute;indiquez qu&acute;un seul nombre entier, ce dernier sera consid&eacute;r&eacute; comme repr&eacute;sentant le nombre d&acute;enregistrements voulus, sur la base d&acute;un d&eacute;calage par d&eacute;faut de 0.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">SELECT . . . INTO OUTFILE `file_name'</span> inscrit le jeu de r&eacute;sultats de la requ&ecirc;te dans un fichier plac&eacute; sur le syst&egrave;me de fichiers h&ocirc;te. Le nom de fichier (file_name) doit d&eacute;j&agrave; &ecirc;tre d&eacute;fini. La syntaxe <span class="emphasis">SELECT . . . INTO DUMPFILE</span> inscrit une seule ligne continue de donn&eacute;es, sans terminaisons de colonne ou de ligne, ni caract&egrave;re d&acute;&eacute;chappement. Cette option s&acute;utilise principalement avec les fichiers blob.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>MySQL prend uniquement en charge la syntaxe <span class="emphasis">JOIN</span> des types suivants:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>[CROSS JOIN]INNER JOINSTRAIGHT_JOINLEFT [OUTER] JOINNATURAL LEFT [OUTER] JOIN</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT {[ALL] [DISTINCT] | [UNIQUE]}...{columns_and_expressions_list} [,...n] AS alias[INTO {variable[,...n] | record}]FROM {[table_name [@database_link]| view_name | snapshot_name]   | subquery [WITH {READ ONLY | CHECK OPTION [CONSTRAINT constraint_name]}]   | TABLE {(nested_tbl_column)}      [PARTITION {partition_name}]      [SUBPARTITION {subpartition_name}         [SAMPLE [BLOCK] [sample_percentage]}WHERE[[START WITH clause] CONNECT BY clause]GROUP BY...[ORDER BY... [NULLS FIRST | NULLS LAST] | FOR UPDATE [OF [schema.]table[,...n]] [NOWAIT] ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle autorise diverses extensions &agrave; la fonctionnalit&eacute; ajout&eacute;e de prise en charge <span class="emphasis">SELECT</span> sur le serveur. Par exemple, puisque vous pouvez cr&eacute;er aussi bien des tables imbriqu&eacute;es que des tables partitionn&eacute;es (voir <span class="emphasis">CREATE TABLE</span>), l&acute;instruction <span class="emphasis">SELECT</span> autorise les requ&ecirc;tes provenant de ces structures nomm&eacute;es. (La clause <span class="emphasis">PARTITION</span> est inutile pour effectuer une requ&ecirc;te &agrave; partir de la partition par d&eacute;faut.)</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">SAMPLE</span> indique &agrave; Oracle de s&eacute;lectionner les enregistrements dans un &eacute;chantillon al&eacute;atoire provenant du jeu de r&eacute;sultats, plut&ocirc;t que dans la table enti&egrave;re. La clause <span class="emphasis">SAMPLE BLOCK</span> indique &agrave; Oracle d&acute;utiliser l&acute;&eacute;chantillonnage de bloc plut&ocirc;t que l&acute;&eacute;chantillonnage de ligne. Le pourcentage d&acute;&eacute;chantillonnage, qui indique &agrave; Oracle le nombre total de blocs ou de lignes &agrave; inclure dans l&acute;&eacute;chantillon, peut avoir une valeur comprise entre 0,000001 et 99. L&acute;&eacute;chantillonnage s&acute;applique uniquement aux requ&ecirc;tes portant sur une seule table.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La syntaxe <span class="emphasis">SELECT . . . INTO</span>, qui est r&eacute;serv&eacute;e au code PL/SQL, permet &agrave; l&acute;instruction <span class="emphasis">SELECT</span> d&acute;attribuer des valeurs &agrave; des variables.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Vous devez utiliser la clause <span class="emphasis">FROM TABLE nested_table_column</span> pour la consultation d&acute;une table imbriqu&eacute;e. La clause <span class="emphasis">@database_link</span> permet &agrave; la requ&ecirc;te d&acute;acc&eacute;der aux tables stock&eacute;es dans d&acute;autres bases de donn&eacute;es et sur d&acute;autres serveurs, lorsque ces bases de donn&eacute;es et ces serveurs ont &eacute;t&eacute; d&eacute;clar&eacute;s en tant que <span class="emphasis">db_link. </span>(Reportez-vous &agrave; la documentation de l'&eacute;diteur pour plus d'informations sur db_link.)</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les options <span class="emphasis">NULL FIRST</span> et <span class="emphasis">NULL LAST</span> de la clause <span class="emphasis">ORDER BY</span> indiquent que les lignes d&acute;ordre du jeu de r&eacute;sultats qui poss&egrave;dent une valeur de fin null doivent figurer respectivement en premi&egrave;re ou en derni&egrave;re place.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet de sp&eacute;cifier les jeux de r&eacute;sultats par ordre hi&eacute;rarchique. Ces <span class="emphasis">requ&ecirc;tes hi&eacute;rarchiques</span>, telles qu&acute;elles sont appel&eacute;es, poss&egrave;dent divers r&egrave;gles et comportements uniques. Reportez-vous &agrave; la documentation de l'&eacute;diteur pour des informations compl&egrave;tes sur l&acute;utilisation de ce type de requ&ecirc;te. La clause <span class="emphasis">START WITH</span> est capitale pour les requ&ecirc;tes hi&eacute;rarchiques; elle sp&eacute;cifie les lignes racine d&acute;une hi&eacute;rarchie. La clause <span class="emphasis">CONNECT BY</span> d&eacute;crit la relation qui lie les lignes parent et enfant de la hi&eacute;rarchie.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">FOR UPDATE OF</span> verrouille de fa&ccedil;on exclusive la ligne renvoy&eacute;e par la requ&ecirc;te. Elle doit &ecirc;tre imm&eacute;diatement suivie d&acute;une commande <span class="emphasis">UPDATE . . . WHERE</span>, <span class="emphasis">COMMIT</span> ou <span class="emphasis">ROLLBACK</span>. L&acute;option <span class="emphasis">NOWAIT</span> indique &agrave; Oracle de ne pas attendre si un enregistrement est d&eacute;j&agrave; verrouill&eacute;. A la place, la requ&ecirc;te se termine et elle est imm&eacute;diatement renvoy&eacute;e &agrave; l&acute;utilisateur.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SELECT...[INTO [TEMPORARY | TEMP] [TABLE] new_table_name]FROM...WHERE...[FOR UPDATE [OF class_name[,...n]][LIMIT {count | ALL} [offset [,number_of_records]] ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL permet de cr&eacute;er une nouvelle table sur la base de la syntaxe <span class="emphasis">SELECT . . . INTO</span>, qui est en gros identique &agrave; celle prise en charge par Microsoft SQL Server. PostgreSQL permet &agrave; la clause <span class="emphasis">FOR UPDATE</span> de verrouiller en mode exclusif les enregistrements s&eacute;lectionn&eacute;s par la requ&ecirc;te. PostgreSQL prend &eacute;galement en charge la clause <span class="emphasis">LIMIT</span>, similaire &agrave; la clause MySQL du m&ecirc;me nom, qui permet de limiter le nombre de lignes renvoy&eacute;es par la requ&ecirc;te.<span class="emphasis"></span>     </p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="SET CONNECTION">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">SET CONNECTION</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">SET CONNECTION</span> permet aux utilisateurs de basculer entre plusieurs connexions ouvertes sur un ou plusieurs serveurs de base de donn&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des limites</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Non prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET CONNECTION {DEFAULT | connection_name}</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette commande ne met pas fin &agrave; une connexion. A la place, elle passe de la connexion en cours &agrave; la connexion nomm&eacute;e dans la commande, ou &agrave; la connexion en cours qui utilise la clause <span class="emphasis">DEFAULT</span>. Lors du basculement d&acute;une connexion &agrave; l&acute;autre, l&acute;ancienne connexion devient inactive (sans aucune validation des modifications) et le nouvelle connexion devient active.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">CONNECT</span> permet de cr&eacute;er une nouvelle connexion et la commande <span class="emphasis">DISCONNECT</span>, de mettre fin &agrave; une connexion.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server prend uniquement en charge <span class="emphasis">SET CONNECTION</span> dans Embedded-SQL (ESQL), mais pas dans son outil de requ&ecirc;te ponctuel, SQL Query Analyzer. Microsoft SQL Server prend en charge la syntaxe SQL99 compl&egrave;te.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Ce programme ESQL complet dans SQL Server affiche <span class="emphasis">CONNECT</span>, <span class="emphasis">DISCONNECT</span> et <span class="emphasis">SET CONNECTION</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>EXEC SQL CONNECT TO chicago.pubs AS chicago1 USER sa;EXEC SQL CONNECT TO new_york.pubs AS new_york1 USER read-only;// opens connections to the servers named "chicago" ////   and "new_york"//EXEC SQL SET CONNECTION chicago1;EXEC SQL SELECT name FROM employee INTO:name;// sets the chicago1 connection as active and performs work ////   within that session //EXEC SQL SET CONNECTION new_york1;EXEC SQL SELECT name FROM employee INTO:name;// sets the new_york1 connection as active and performs work ////   within that session //EXEC SQL DISCONNECT ALL;// Terminates all sessions.  You could alternately use two ////   DISCONNECT commands, one for each named connection. //</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="SET ROLE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">SET ROLE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">SET ROLE</span> active et d&eacute;sactive des r&ocirc;les de s&eacute;curit&eacute; sp&eacute;cifiques pour la session en cours. Les instructions <span class="emphasis">CONNECT</span> et <span class="emphasis">CREATE ROLE</span> permettent respectivement de cr&eacute;er des sessions et des r&ocirc;les.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Non prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET ROLE {NONE | role_name}</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">CONNECT</span> ouvre cette session. Une fois qu&acute;une session utilisateur est lanc&eacute;e, l&acute;&eacute;mission de l&acute;instruction <span class="emphasis">SET ROLE</span> lui accorde un ensemble de privil&egrave;ges associ&eacute;s &agrave; un r&ocirc;le. La commande <span class="emphasis">SET ROLE</span> ne peut &ecirc;tre &eacute;mise qu&acute;en dehors d&acute;une transaction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">SET ROLE NONE</span> attribue la session en cours &agrave; un r&ocirc;le <span class="emphasis">NULL</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Lorsqu&acute;un r&ocirc;le est attribu&eacute; &agrave; la session utilisateur active, vous pouvez utiliser une cha&icirc;ne de caract&egrave;res, une variable de base de donn&eacute;es, voire une fonction syst&egrave;me, par exemple <span class="emphasis">CURRENT_ROLE</span> ou <span class="emphasis">SYSTEM_ROLE</span>. Dans ce cas, la valeur sp&eacute;cifi&eacute;e doit &ecirc;tre un nom de r&ocirc;le valide.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET ROLE {role_name [IDENTIFIED BY password] [,...n]| [ALL [EXCEPT role_name [,...]]|  NONE;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Lorsqu&acute;un utilisateur lance une connexion, Oracle lui attribue explicitement les privil&egrave;ges qui lui servent de r&ocirc;les. La commande <span class="emphasis">SET ROLE</span> vous permet de modifier le(s) r&ocirc;le(s) sous le(s)quel(s) cette session fonctionne. Oracle utilise le param&egrave;tre d&acute;initialisation <span class="emphasis">MAX_ENABLED_ROLES</span> pour contr&ocirc;ler le nombre maximal de r&ocirc;les qu&acute;il sera possible d&acute;ouvrir en m&ecirc;me temps.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le param&egrave;tre <span class="emphasis">role_name</span> sp&eacute;cifi&eacute; doit &ecirc;tre un nom de r&ocirc;le valide pr&eacute;alablement cr&eacute;&eacute; dans Oracle. Les r&ocirc;les qui ne sont pas sp&eacute;cifi&eacute;s ne pourront pas &ecirc;tre utilis&eacute;s dans le cadre de la session en cours. Si le param&egrave;tre <span class="emphasis">role_name</span> est dot&eacute; d&acute;un mot de passe, il doit &ecirc;tre r&eacute;pertori&eacute; au moyen de la clause <span class="emphasis">IDENTIFIED BY password</span>. Pour identifier plusieursr&ocirc;les, s&eacute;parez-les par une virgule.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">SET ROLE ALL</span> active tous les r&ocirc;les accord&eacute;s &agrave; la session en cours, y compris les r&ocirc;les accord&eacute;s par l&acute;interm&eacute;diaire d&acute;autres r&ocirc;les; la clause <span class="emphasis">EXCEPT</span> permet de dispenser d&acute;autres r&ocirc;les. Vous ne pouvez pas utiliser <span class="emphasis">SET ROLE ALL</span> lorsqu&acute;un mot de passe est n&eacute;cessaire. Seule l&acute;instruction <span class="emphasis">SET ROLE role_name IDENTIFIED BY password</span> permet d&acute;acc&eacute;der aux r&ocirc;les dot&eacute;s d&acute;un mot de passe.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">SET ROLE NONE</span> d&eacute;sactive tous les r&ocirc;les, en particulier le r&ocirc;le par d&eacute;faut.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;exemple qui suit permet d&acute;activer les r&ocirc;les <span class="emphasis">read_only</span> et <span class="emphasis">updater</span>, respectivement identifi&eacute;s par les mots de passe <span class="emphasis">editor</span> et <span class="emphasis">red_marker</span>, pour la session en cours:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET ROLE read_only IDENTIFIED BY editor, updater IDENTIFIED BY red_marker;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;exemple qui suit permet d&acute;activer tous les r&ocirc;les, &agrave; l&acute;exception du r&ocirc;le <span class="emphasis">read_write </span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET ROLE ALL EXCEPT read_write;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="SET TIME ZONE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">SET TIME ZONE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">SET TIME ZONE</span>  modifie le fuseau horaire de la session en cours, s&acute;il doit &ecirc;tre diff&eacute;rent du fuseau horaire par d&eacute;faut.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Non prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Non prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge, avec des variations</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET TIME ZONE {LOCAL | INTERVAL {+ | -}'00:00' HOUR TO MINUTE}</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>A l&acute;instar de la plupart des commandes <span class="emphasis">SET</span>, <span class="emphasis">SET TIME ZONE</span> ne peut &ecirc;tre ex&eacute;cut&eacute;e qu&acute;en dehors d&acute;une transaction explicite. La clause <span class="emphasis">LOCAL</span> substitue aux valeurs d&acute;heure de la session en cours celles du fuseau horaire par d&eacute;faut sur le serveur. Sinon, une valeur d&acute;intervalle peut &ecirc;tre d&eacute;finie pour augmenter (+) ou r&eacute;duire (-) l&acute;heure par d&eacute;faut.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET TIME ZONE {'timezone' | LOCAL | DEFAULT| INTERVAL {+ | -}'00:00' HOUR TO MINUTE};</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL permet d&acute;attribuer &agrave; l&acute;heure d&acute;une session la valeur par d&eacute;faut d&eacute;finie sur le serveur, au moyen de la clause <span class="emphasis">LOCAL</span> ou <span class="emphasis">DEFAULT</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La valeur sp&eacute;cifi&eacute;e pour le fuseau horaire d&eacute;pend du syst&egrave;me d&acute;exploitation utilis&eacute;. Par exemple, `PST8PDT' est un fuseau horaire valide pour la Californie sur les syst&egrave;mes Linux, alors que `Europe/Rome' est un fuseau horaire appropri&eacute; pour l&acute;Italie sur divers syst&egrave;mes, dont Linux. Si le fuseau horaire est incorrect, la commande utilise comme fuseau horaire le m&eacute;ridien de Greenwich (GMT).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Le fuseau horaire peut &eacute;galement &ecirc;tre d&eacute;fini comme un intervalle du fuseau horaire du serveur par d&eacute;faut.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;exemple qui suit avance le fuseau horaire de trois heures sur le fuseau horaire par d&eacute;faut actuel:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET TIME ZONE INTERVAL +'03:00' HOUR TO MINUTE;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Ensuite, l&acute;heure actuelle de la session en cours est recul&eacute;e de quatre heures et demie:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET TIME ZONE INTERVAL -'04:30' HOUR TO MINUTE;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Enfin, l&acute;heure par d&eacute;faut est r&eacute;tablie pour la session en cours:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET TIME ZONE LOCAL;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="SET TRANSACTION">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">SET TRANSACTION</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">SET TRANSACTION</span> contr&ocirc;le les diverses caract&eacute;ristiques des modifications de donn&eacute;es, par exemple l&acute;acc&egrave;s en lecture/&eacute;criture ou son niveau d'isolation.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des limites</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET [LOCAL] TRANSACTION { {READ ONLY | READ WRITE}[,...]| ISOLATION LEVEL  {READ COMMITTED  | READ UNCOMMITTED  | REPEATABLE READ  | SERIALIZABLE}[,...]| DIAGNOSTIC SIZE INT};</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Lorsqu&acute;elle est &eacute;mise, cette commande est ext&eacute;rieure au contexte d&acute;une transaction, mais elle s&acute;applique &agrave; la transaction valide suivante. Elle permet d&acute;appliquer plusieurs options, qui sont s&eacute;par&eacute;es par une virgule.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Avec la commande <span class="emphasis">LOCAL</span>, les param&egrave;tres de la transaction s&acute;appliquent uniquement au serveur. Sinon, ils s&acute;appliquent, quel que soit le serveur sur lequel la transaction est ex&eacute;cut&eacute;e. Cette option est une nouvelle fonctionnalit&eacute; de SQL99.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Vous pouvez aussi d&eacute;finir une transaction comme <span class="emphasis">READ ONLY</span> ou <span class="emphasis">READ WRITE</span>. Suivie d&acute;un nombre entier, la clause <span class="emphasis">DIAGNOSTIC SIZE</span> indique le nombre de messages d&acute;erreur &agrave; capturer pour une transaction. L&acute;instruction <span class="emphasis">GET DIAGNOSTICS</span> permet d&acute;extraire cette information.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">ISOLATION LEVEL</span> contr&ocirc;le plusieurs comportements d&acute;une transaction dans le cadre de transactions simultan&eacute;es. Les niveaux d&acute;isolation contr&ocirc;lent le comportement des transactions pour les <span class="emphasis">lectures de donn&eacute;es modifi&eacute;es (dirty reads)</span>, les <span class="emphasis">lectures uniques (non-repeatable reads)</span> et les <span class="emphasis">enregistrements fant&ocirc;mes (phantom records)</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<ul><li><i><span class="emphasis">Lectures de donn&eacute;es modifi&eacute;es (dirty reads)</span> </i><br>&#160;						  Surviennent lorsqu&acute;une transaction lit les enregistrements modifi&eacute;s d&acute;une autre transaction avant que celle-ci ne soit termin&eacute;e. Il devient donc possible de modifier les donn&eacute;es d&acute;un enregistrement qui n&acute;a peut-&ecirc;tre pas encore &eacute;t&eacute; valid&eacute; dans la base de donn&eacute;es.</li><li><i><span class="emphasis">Lectures uniques (non-repeatable reads)</span> </i><br>&#160;						  Surviennent lorsqu&acute;une transaction lit un enregistrement pendant qu&acute;une autre transaction le modifie. La premi&egrave;re transaction ne peut donc plus trouver cet enregistrement pour le relire.</li><li><i><span class="emphasis">Enregistrements fant&ocirc;mes (phantom records)</span> </i><br>&#160;						  Surviennent si des donn&eacute;es sont ajout&eacute;es ou modifi&eacute;es pendant qu&acute;une transaction lit un groupe d&acute;enregistrements, ce qui augmente le nombre d&acute;enregistrements correspondant &agrave; cette premi&egrave;re transaction.</li></ul>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La configuration du niveau d&acute;isolation a une incidence sur ces anomalies, comme d&eacute;crit dans le Tableau 3.10.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Niveau d&acute;isolation</th><th>Lectures de donn&eacute;es modifi&eacute;es (dirty reads)</th><th>Lectures uniques (non-repeatable reads)</th><th>Enregistrements fant&ocirc;mes (phantom records)</th></tr>
								<tr><td>READ COMMITTED</td><td>Non</td><td>Oui</td><td>Oui</td>
								</tr>
								<tr><td>READ UNCOMMITTED</td><td>Oui</td><td>Oui</td><td>Oui</td>
								</tr>
								<tr><td>REPEATABLE READ</td><td>non</td><td>non</td><td>oui</td>
								</tr>
								<tr><td>SERIALIZABLE</td><td>Non</td><td>Non</td><td>Non</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">SERIALIZABLE</span> correspond au niveau d&acute;isolation par d&eacute;faut dans SQL99. Les transactions <span class="emphasis">READ WRITE</span> ne peuvent pas &ecirc;tre d&eacute;finies comme <span class="emphasis">READ UNCOMMITTED</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET TRANSACTION ISOLATION LEVEL{READ COMMITTED| READ UNCOMMITTED| REPEATABLE READ| SERIALIZABLE}</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">READ COMMITTED</span> correspond &agrave; la valeur par d&eacute;faut dans SQL Server, alors que serializable correspond &agrave; la valeur par d&eacute;faut dans SQL99. Le niveau d&acute;isolation s&acute;applique pendant toute la dur&eacute;e de la session, alors que dans SQL99, il s&acute;applique &agrave; la seule transaction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle SQL Server</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET TRANSACTION READ ONLY;</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle ne prend pas en charge la syntaxe compl&egrave;te de l&acute;instruction <span class="emphasis">SET TRANSACTION</span>, et son impl&eacute;mentation de <span class="emphasis">READ ONLY</span> est &eacute;galement diff&eacute;rente. Oracle prend uniquement en charge <span class="emphasis">READ COMMITTED</span> et <span class="emphasis">SERIALIZABLE</span>. <span class="emphasis">READ COMMITTED</span> correspond au comportement par d&eacute;faut. Dans Oracle, cette commande lance une transaction poss&eacute;dant le niveau d&acute;isolation <span class="emphasis">SERIALIZABLE</span>. Oracle autorise uniquement l&acute;utilisation des commandes <span class="emphasis">SELECT</span> lorsque les commandes suivantes sont configur&eacute;es: <span class="emphasis">READ ONLY</span>, <span class="emphasis">ALTER SESSION</span>, <span class="emphasis">ALTER SYSTEM</span>, <span class="emphasis">LOCK TABLE</span> et <span class="emphasis">SET ROLE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>SET TRANSACTION ISOLATION LEVEL {READ COMMITTED | SERIALIZABLE};</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL ne prend pas en charge la syntaxe compl&egrave;te de l&acute;instruction <span class="emphasis">SET TRANSACTION</span>. Dans PostgreSQL, <span class="emphasis">SET TRANSACTION ISOLATION LEVEL READ COMMITTED</span><span class="emphasis"></span>sp&eacute;cifie les lignes en lecture seule de la transaction en cours, qui ont &eacute;t&eacute; valid&eacute;es avant le lancement de celle-ci. Il s&acute;agit de la valeur par d&eacute;faut. <span class="emphasis">SERIALIZABLE</span>, qui correspond au niveau d&acute;isolation ANSI par d&eacute;faut, sp&eacute;cifie les lignes en lecture seule de la transaction en cours, qui ont &eacute;t&eacute; valid&eacute;es avant l&acute;ex&eacute;cution de la premi&egrave;re modification de donn&eacute;es pour le lot.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="START TRANSACTION">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">START TRANSACTION</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">START TRANSACTION</span>, qui est une nouvelle fonctionnalit&eacute; de SQL99, permet d&acute;ex&eacute;cuter toutes les fonctions de <span class="emphasis">SET TRANSACTION</span> et de lancer une nouvelle transaction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Non prise en charge; voir <span class="emphasis">BEGIN TRAN</span> dans la suite de ce chapitre</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Non prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Non prise en charge; voir <span class="emphasis">BEGIN TRAN</span> dans la suite de ce chapitre</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>START TRANSACTION { {READ ONLY | READ WRITE}[,...]| ISOLATION LEVEL  {READ COMMITTED  | READ UNCOMMITTED  | REPEATABLE READ  | SERIALIZABLE}[,...]| DIAGNOSTIC SIZE INT};</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La seule diff&eacute;rence qui s&eacute;pare <span class="emphasis">SET</span> et <span class="emphasis">START</span> est la suivante: l&acute;instruction <span class="emphasis">SET</span> est ext&eacute;rieure &agrave; la transaction en cours, alors que l&acute;instruction <span class="emphasis">START</span> est consid&eacute;r&eacute;e comme la marque d&acute;une nouvelle transaction.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">BEGIN TRANSACTION</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">BEGIN TRANSACTION</span> propose des fonctionnalit&eacute;s similaires &agrave; celles de l&acute;instruction <span class="emphasis">START TRANSACTION</span>. Microsoft SQL Server et PostgreSQL reconnaissent tous deux <span class="emphasis">BEGIN TRANSACTION</span>, m&ecirc;me si leur syntaxe respective varie l&eacute;g&egrave;rement. Oracle prend en charge les transactions implicites, mais non les transactions explicites. MySQL ne prend absolument pas en charge les transactions atomiques. <span class="emphasis">BEGIN TRANSACTION</span> d&eacute;clare une transaction explicite, mais sans configurer les niveaux d&acute;isolation.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La syntaxe Microsoft SQL Server est la suivante:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>BEGIN TRAN[SACTION] [transaction_name | @transaction_variable[WITH MARK [ 'log_description' ] ] ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server permet d&acute;attribuer un nom &agrave; une transaction ou de faire r&eacute;f&eacute;rence aux transactions au moyen d&acute;une variable. Il ne permet pas de modifier ou de renforcer cette fonctionnalit&eacute;. Dans le cas de transactions imbriqu&eacute;es, seule la paire <span class="emphasis">BEGIN . . . COMMIT</span> ou <span class="emphasis">BEGIN . . . ROLLBACK</span> parente doit faire r&eacute;f&eacute;rence au nom de la transaction (le cas &eacute;ch&eacute;ant).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;option <span class="emphasis">WITH MARK</span> consigne la transaction dans le journal des &eacute;v&eacute;nements de SQL Server. Si vous sp&eacute;cifiez <span class="emphasis">WITH MARK `log_description'</span>,<span class="emphasis"> </span>vous pouvez ajouter une cha&icirc;ne descriptive &agrave; l&acute;&eacute;l&eacute;ment qui sera consign&eacute;.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La syntaxe PostgreSQL est la suivante:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>BEGIN [ WORK | TRANSACTION ]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;ex&eacute;cution de PostgreSQL s&acute;effectue normalement en mode d&acute;autovalidation, pour lequel chaque requ&ecirc;te ou modification de donn&eacute;es constitue sa propre transaction. PostgreSQL applique normalement une instruction <span class="emphasis">COMMIT</span> ou <span class="emphasis">ROLLBACK</span> implicite &agrave; la fin de la transaction. L&acute;utilisation de l&acute;instruction <span class="emphasis">BEGIN</span> permet de d&eacute;clarer explicitement l&acute;instruction <span class="emphasis">COMMIT</span> ou <span class="emphasis">ROLLBACK</span> suivante.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Pensez &agrave; inclure <span class="emphasis">BEGIN</span> dans une paire contenant <span class="emphasis">COMMIT</span> ou <span class="emphasis">ROLLBACK</span>. Sinon, le SGBD doit attendre de trouver <span class="emphasis">COMMIT</span> ou <span class="emphasis">ROLLBACK</span> pour terminer la ou les commandes. Ce processus est susceptible de g&eacute;n&eacute;rer des transactions gigantesques, dont les r&eacute;sultats sur les donn&eacute;es seront impr&eacute;visibles.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Les transactions &agrave; codage manuel sont beaucoup plus rapides dans PostgreSQL que les transactions autovalid&eacute;es. Vous devez r&eacute;gler <span class="emphasis">SET TRANSACTION ISOLATION LEVEL</span><span class="emphasis"></span> sur <span class="emphasis">SERIALIZABLE</span> imm&eacute;diatement apr&egrave;s l&acute;instruction <span class="emphasis">BEGIN</span> pour renforcer l&acute;isolation de la transaction. On peut d&eacute;nombrer diverses instructions de modification de donn&eacute;es (<span class="emphasis">INSERT</span>, <span class="emphasis">UPDATE</span>, <span class="emphasis">DELETE</span>) dans un bloc <span class="emphasis">BEGIN . . . COMMIT</span>. Suivant qu&acute;elle se solde par un succ&egrave;s ou par un &eacute;chec, la commande <span class="emphasis">COMMIT</span> entra&icirc;ne l&acute;ex&eacute;cution de toutes les transactions ou d&acute;aucune.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans l&acute;exemple qui suit, les trois instructions <span class="emphasis">INSERT</span> seront trait&eacute;es dans le cadre d&acute;une m&ecirc;me transaction:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>BEGIN TRANSACTION   INSERT INTO sales VALUES('7896','JR3435','Oct 28 2001',25,   'Net 60','BU7832')   INSERT INTO sales VALUES('7901','JR3435','Oct 28 2001',17,   'Net 60','BU7832')   INSERT INTO sales VALUES('7907','JR3435','Oct 28 2001',6,   'Net 60','BU7832')COMMITGO</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cependant, le groupe complet de transactions &eacute;choue si, par exemple, l&acute;une des instructions <span class="emphasis">INSERT</span> comporte une limite de cl&eacute; primaire.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="TRUNCATE TABLE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">TRUNCATE TABLE </td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">TRUNCATE TABLE</span> est une instruction non ANSI qui supprime toutes les lignes d&acute;une table sans consigner les suppressions de lignes individuelles. Cette commande est tr&egrave;s pratique dans la mesure o&ugrave; elle permet de supprimer rapidement tous les enregistrements d&acute;une table sans modifier la structure de cette derni&egrave;re, tout en occupant un espace extr&ecirc;mement r&eacute;duit dans les fichiers de reprise ou les journaux des transactions. Elle pr&eacute;sente cependant un inconv&eacute;nient de taille; il est impossible de r&eacute;cup&eacute;rer ou de sauvegarder les informations, puisqu&acute;elles n&acute;ont pas &eacute;t&eacute; consign&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge</td>
								</tr>
								<tr><td>MySQL</td><td>Non prise en charge</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>TRUNCATE TABLE <span class="replaceable">name</span></pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;instruction <span class="emphasis">TRUNCATE TABLE</span> a le m&ecirc;me effet qu&acute;une instruction <span class="emphasis">DELETE</span> sans clause <span class="emphasis">WHERE</span>; elles &eacute;liminent toutes les deux les lignes d&acute;une table sp&eacute;cifique. Cependant, il existe deux diff&eacute;rences de taille. <span class="emphasis">TRUNCATE TABLE</span> est plus rapide et elle n&acute;est pas consign&eacute;e; autrement dit, il n&acute;existe aucune possibilit&eacute; d&acute;annulation en cas d&acute;erreur.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>En r&egrave;gle g&eacute;n&eacute;rale, <span class="emphasis">TRUNCATE TABLE</span> n&acute;active pas les triggers et ne fonctionne pas si une table donn&eacute;e contient des cl&eacute;s &eacute;trang&egrave;res.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemple</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;exemple qui suit supprime toutes les donn&eacute;es de la table <span class="emphasis">publishers</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>TRUNCATE TABLE publishers</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>TRUNCATE { CLUSTER [owner.]cluster   | TABLE [owner.]table [{PRESERVE | PURGE} SNAPSHOT LOG]}[{DROP | REUSE} STORAGE]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Oracle permet de tronquer une table ou un index clusteris&eacute; (mais pas un cluster hash).</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Si vous choisissez de tronquer une table, Oracle permet de conserver ou de purger, le cas &eacute;ch&eacute;ant, le journal des instantan&eacute;s d&eacute;fini pour la table. <span class="emphasis">PRESERVE</span> conserve le journal des instantan&eacute;s lorsque la table master est tronqu&eacute;e, tandis que <span class="emphasis">PURGE</span> le vide.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Lorsque la clause <span class="emphasis">DROP STORAGE</span> est ajout&eacute;e, l&acute;espace disque lib&eacute;r&eacute; par la suppression des lignes n&acute;est plus allou&eacute;. Lorsque la clause <span class="emphasis">REUSE STORAGE</span> est ajout&eacute;e, l&acute;espace disque qui &eacute;tait allou&eacute; &agrave; la table ou au cluster pour les lignes supprim&eacute;es est conserv&eacute;.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Remarque pour Microsoft SQL Server et PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Ces deux impl&eacute;mentations prennent en charge la syntaxe SQL99 par d&eacute;faut.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
<div id="UPDATE">
			<table width="100%" cellspacing="0" cellpadding="0" border="0" class="main"><tr>				<td valign="top" class="name">UPDATE</td><td valign="top" nowrap class="compatibility">&#160;</td>
				</tr>
				<tr>
					<td colspan="2" class="divider"><img src="dwres:18084" width="100%" height="1"></td>
				</tr>
				<tr>
					<td><p>La commande <span class="emphasis">UPDATE</span> modifie les donn&eacute;es d&acute;une table.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td>
						<table border="1"><tbody><tr><th>Editeur</th><th>Commande</th></tr>
								<tr><td>SQL Server</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>MySQL</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>Oracle</td><td>Prise en charge, avec des variations</td>
								</tr>
								<tr><td>PostgreSQL</td><td>Prise en charge</td>
								</tr>
							</tbody></table>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe SQL99 et description</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>UPDATE {table_name | view_name}SET {column_name | variable_name} = {DEFAULT | expression} [,...n]WHERE conditions</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>A l&acute;instar d&acute;une instruction <span class="emphasis">DELETE</span>, une commande <span class="emphasis">UPDATE</span> est rarement &eacute;mise sans clause <span class="emphasis">WHERE</span>, puisque cette instruction affecte toutes les lignes de la table.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il est recommand&eacute; d&acute;&eacute;mettre une commande <span class="emphasis">SELECT</span> au moyen de la m&ecirc;me clause <span class="emphasis">WHERE</span> avant d&acute;&eacute;mettre l&acute;instruction <span class="emphasis">UPDATE</span> &agrave; proprement parler. Cette proc&eacute;dure v&eacute;rifie toutes les lignes du jeu de r&eacute;sultats avant d&acute;ex&eacute;cuter l&acute;instruction <span class="emphasis">UPDATE</span>. Les lignes renvoy&eacute;es par la commande <span class="emphasis">SELECT</span> sont toutes modifi&eacute;es par l&acute;instruction <span class="emphasis">UPDATE</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Exemples</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Une instruction <span class="emphasis">UPDATE</span> de base sans clause <span class="emphasis">WHERE</span> est similaire &agrave; celle-ci:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>UPDATE authorsSET contract = 0</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Sans clause <span class="emphasis">WHERE</span>, l&acute;&eacute;tat de contrat de tous les auteurs de la table <span class="emphasis">authors</span> est r&eacute;gl&eacute; sur (autrement dit, ils ne poss&egrave;dent plus de contrat). De m&ecirc;me, vous pouvez ajuster math&eacute;matiquement les valeurs au moyen d&acute;une instruction <span class="emphasis">UPDATE</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>UPDATE titlesSET price = price * 1.1</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette instruction <span class="emphasis">UPDATE</span> permet d&acute;augmenter de 10% le prix de tous les livres.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;ajout d&acute;une clause <span class="emphasis">WHERE</span> &agrave; une instruction <span class="emphasis">UPDATE</span> permet d&acute;apporter des modifications s&eacute;lectives aux enregistrements:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>UPDATE titlesSET    type  = 'pers_comp',       price = (price * 1.15)WHERE  type  = 'popular_com'</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Cette requ&ecirc;te apporte deux modifications &agrave; tout enregistrement du type <span class="emphasis">`popular_com'</span>. Cette commande augmente les prix de 15% et passe leur type &agrave; <span class="emphasis">`pers_comp'</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Il peut arriver que vous deviez mettre &agrave; jour les valeurs d&acute;une table donn&eacute;e sur la base des valeurs stock&eacute;es dans une autre table. Par exemple, si vous voulez mettre &agrave; jour la date de publication de tous les titres &eacute;crits par un auteur donn&eacute;, vous devez commencer par trouver cet auteur et r&eacute;pertorier la liste de ses titres par le biais de sous-requ&ecirc;tes:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>UPDATE titlesSET    pubdate = 'Jan 01 2002'WHERE  title_id IN    (SELECT title_id     FROM   titleauthor     WHERE  au_id IN         (SELECT au_id          FROM   authors          WHERE  au_lname = 'White'))</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Microsoft</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>UPDATE {table_name | view_name} [WITH (table_hint [,...n])]SET {column_name | variable_name} = {DEFAULT | expression | NULL} [,...n][FROM {table [,...n]}]WHERE {conditions | CURRENT OF [GLOBAL] cursor_name}[OPTION (query_hint [,...n])]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server peut mettre &agrave; jour les vues et les tables. Vous pouvez utiliser les clauses <span class="emphasis">WITH table_hint</span> et <span class="emphasis">OPTION</span> afin de d&eacute;clarer les astuces de l&acute;optimiseur pour les tables et les requ&ecirc;tes. Les astuces de l&acute;optimiseur outrepassent la fonctionnalit&eacute; par d&eacute;faut de l&acute;optimiseur de requ&ecirc;tes. Reportez-vous &agrave; la documentation de l'&eacute;diteur pour des informations compl&egrave;tes sur les astuces de l&acute;optimiseur.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Microsoft SQL Server prend en charge la clause <span class="emphasis">FROM</span> dans une instruction <span class="emphasis">UPDATE</span>. Cette variation pr&eacute;sente un avantage de taille: elle facilite grandement les jointures multitable. L&acute;exemple suivant illustre des jointures de tables pour les deux styles de syntaxe:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>-- ANSI styleUPDATE titlesSET    pubdate = GETDATE(  )WHERE  title_id IN    (SELECT title_id     FROM   titleauthor     WHERE  au_id IN         (SELECT au_id          FROM   authors          WHERE  au_lname = 'White'))-- Style Microsoft Transact-SQLUPDATE  titlesSET     pubdate = GETDATE(  )FROM    authors a,        titleauthor t2WHERE   a.au_id     = t2.au_id    AND t2.title_id = titles.title_id    AND a.au_lname  = 'White'</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;ex&eacute;cution de la mise &agrave; jour sur la base d&acute;une syntaxe Transact-SQL revient simplement &agrave; ex&eacute;cuter trois jointures de table (<span class="emphasis">authors</span>, <span class="emphasis">titles</span> et <span class="emphasis">titleauthor</span>). Cependant, pour effectuer la m&ecirc;me op&eacute;ration sur la base d&acute;un code conforme &agrave; ANSI, vous devez commencer par rechercher <span class="emphasis">au_id</span> dans <span class="emphasis">author</span>, puis le transmettre &agrave; la table <span class="emphasis">titleauthors</span>, dans laquelle vous devez identifier <span class="emphasis">title_id</span> avant de le transmettre &agrave; l&acute;instruction de mise &agrave; jour principale.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Utilis&eacute;e en combinaison avec un curseur, la clause <span class="emphasis">WHERE CURRENT OF cursor_name</span> indique &agrave; SQL Server de mettre uniquement &agrave; jour l&acute;enregistrement sur lequel le curseur est actuellement positionn&eacute;. Le curseur peut &ecirc;tre global ou local, conform&eacute;ment &agrave; la d&eacute;signation du mot-cl&eacute; <span class="emphasis">GLOBAL</span>.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;exemple qui suit met &agrave; jour la colonne <span class="emphasis">state</span> pour les 10 premiers auteurs de la table <span class="emphasis">authors</span>:</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>UPDATE authorsSET state = 'ZZ'FROM (SELECT TOP 10 * FROM authors ORDER BY au_lname) AS t1WHERE authors.au_id = t1.au_id</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxes et variations dans MySQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>UPDATE [LOW PRIORITY] table_nameSET {column_name | variable_name} = {DEFAULT | expression}WHERE conditions[LIMIT integer]</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>MySQL prend en charge la norme SQL99, avec deux variations: la clause <span class="emphasis">LOW PRIORITY</span> et la clause <span class="emphasis">LIMIT</span>. La clause <span class="emphasis">LOW_PRIORITY</span> indique &agrave; MySQL de reporter l&acute;ex&eacute;cution de la commande <span class="emphasis">UPDATE</span> jusqu&acute;&agrave; ce que les autres clients aient fini de consulter la table. La clause <span class="emphasis">LIMIT</span> r&eacute;duit l&acute;action de <span class="emphasis">UPDATE</span> au nombre sp&eacute;cifique de lignes indiqu&eacute; par un nombre entier.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Syntaxe et variations dans Oracle</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><span class="programlisting"><pre>UPDATE [schema.]{view_name | snapshot_name   | table_name [@database_link]      {[PARTITION partition_name] | [SUBPARTITION subpartition_name]}   | subquery [WITH {[READ ONLY]      | [CHECK OPTION [CONSTRAINT constraint_name] ]SET {column [,...] = {expression [,...n] | subquery} | VALUE value}WHERE conditions | CURRENT OF cursor_name}RETURNING expression [,...n] INTO variable [,...n];</pre>
						</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>L&acute;impl&eacute;mentation dans Oracle de l&acute;instruction <span class="emphasis">UPDATE</span> permet d&acute;effectuer des mises &agrave; jour sur la base de vues, d&acute;instantan&eacute;s et de tables dans le cadre d&acute;un sch&eacute;ma acceptable. La table &agrave; mettre &agrave; jour peut &ecirc;tre locale ou elle peut avoir &eacute;t&eacute; propos&eacute;e par <span class="emphasis">@dblink</span>. Les mises &agrave; jour interviennent toujours par rapport &agrave; une partition; cependant, la commande <span class="emphasis">UPDATE</span> prend en charge, le cas &eacute;ch&eacute;ant, les mises &agrave; jour effectu&eacute;es par rapport &agrave; une <span class="emphasis">PARTITION</span> ou une <span class="emphasis">SUBPARTITION</span> nomm&eacute;es.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">WITH</span> devient disponible si vous effectuez la mise &agrave; jour en fonction d&acute;une sous-requ&ecirc;te. La clause <span class="emphasis">WITH READ ONLY</span> sp&eacute;cifie que la sous-requ&ecirc;te ne peut pas faire l&acute;objet d&acute;une mise &agrave; jour. La clause <span class="emphasis">WITH CHECK OPTION</span> indique &agrave; Oracle d&acute;abandonner toutes les modifications qui, apport&eacute;es &agrave; la table actualis&eacute;e, ne pourraient pas figurer dans le jeu de r&eacute;sultats de la sous-requ&ecirc;te. La sous-clause <span class="emphasis">CONSTRAINT</span> indique &agrave; Oracle de limiter encore davantage les modifications sur la base d&acute;une contrainte sp&eacute;cifique.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>La clause <span class="emphasis">SET VALUE</span> permet &agrave; l&acute;utilisateur de d&eacute;finir la valeur de ligne compl&egrave;te pour n&acute;importe quelle valeur de type de donn&eacute;es de table.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>Dans Oracle, la clause <span class="emphasis">WHERE CURRENT OF</span> indique que la commande <span class="emphasis">UPDATE</span> doit &ecirc;tre uniquement ex&eacute;cut&eacute;e sur l&acute;enregistrement actuel dans le contexte du curseur.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p><span class="emphasis">RETURNING</span> r&eacute;cup&egrave;re les lignes affect&eacute;es par la commande. Quand elle est utilis&eacute;e pour mettre &agrave; jour une seule ligne, les valeurs de la ligne sont stock&eacute;es dans des variables PL/SQL et des variables attach&eacute;es. Quand elle est utilis&eacute;e pour mettre &agrave; jour plusieurs lignes, les valeurs des lignes sont stock&eacute;es dans des tableaux attach&eacute;s Le mot-cl&eacute; <span class="emphasis">INTO</span> signifie que les valeurs mises &agrave; jour doivent &ecirc;tre stock&eacute;es dans la liste des variables.</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td valign="top" colspan="2"><span class="title">Remarques pour PostgreSQL</span></td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
				<tr>
					<td><p>PostgreSQL prend en charge la norme SQL99. Reportez-vous &agrave; la Section , plus avant dans ce chapitre, pour la description compl&egrave;te de la commande <span class="emphasis">UPDATE</span> .</p>
					</td>
				</tr>
				<tr><td valign="top" colspan="2" class="clearseparation">&#160;</td>
				</tr>
			</table>
		</div>
	</body></html>